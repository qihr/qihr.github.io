---
title: CSharp笔记1.基础
tags: [CSharp]
categories: Program
date: 2019-12-17 08:55:00
---
基础内容，包括：.Net框架概述，语言规则，变量类型和存储，方法，类，表达式运算符和语句。

<!-- more -->

## 一 .Net框架

### 1.1 .net框架构成

```mermaid
graph LR;
    id1[编程工具]--产生-->id2(编译的代码);
    id2--使用-->id3[BCL基类库]
    id2--被执行-->id4[CLR公共语言运行库]
    id3--被执行-->id4
```

**BCL(Base Class Library )** :

基础类库(或者称为框架类库 Framework Class Library ， FCL)，自己写程序时也会调到BCL

**CLR(Common Language Runtime)**： 

公共语言运行库。.net框架的核心组件，在操作系统的顶层，负责**管理**程序的执行。可以从下图看到，可以看到，非托管代码CLR不提供服务。

CRL还提供这几种服务：1.自动垃圾收集，2.安全和认证。3.通过访问BCL得到广泛的编程功能，如Web服务和数据服务。

```mermaid
graph TB;
    id1-->id5
    id1-->id6
    id1-->id7
    id1-->id4
    id11[非.net程序]-->id10[操作系统]
    id7-->id10
subgraph 托管代码
    id1[程序集1]
    id2[程序集2]
    id3[程序集3]
end
subgraph CLR
    id4[内存管理\异常处理]
    id5[垃圾收集\反射服务]
    id6[JIT编辑器\类加载器]
    id7[安全服务]
end
subgraph 非托管代码
	id11
end
```

**托管代码(managed code)**：

.net编写的代码称为托管代码。

**非托管代码(unmanaged code)：**

不在CLR控制之下的代码，如Win32，C/C++ DLL。

### 1.2 编译过程

```mermaid
graph LR;
	id1[1.net兼容语言的源代码]-->id2(.net兼容编译器)
	id2-->id3[2.程序集:A.CIL B.类型信息 C.安全信息]
```

**解释：**

1. 使用c#或vb等.net语言编写的文本文件。
2. 使用编程语言写好的文件需要使用编译器生成**程序集**文件，程序集文件只能是可执行的，或者是**DLL**。并且程序集中的不是本机代码，而是CIL公共中间语言的中间语言，

**CIL（Common Intermediate Language）：**

公共语言基础结构，CIL是一组阐述了系统架构，规则，和约定的规范。也是一组数据结构，系统标准。和CIL有关的还有**IL**和**MSIL** 不过已经很少用到了。

```mermaid
graph TB
subgraph CLR
    id2[公共语言运行库CLR] 
    id3[公共语言规范CLS]
    id4[基类库BCL]
  	id5[元数据定义]
    id6[公告类型系统]
    id7[公共中间语言CIL指令组]
end
```

CLI的重要组成部分是：

1. **CTS（COmmon Type System ）**：公共类型系统，定义了托管代码中一定会使用的类型特征。.net兼容的编程语言的类型通常会映射到CTS中已定义的类型。CTS最重要的特征是，所有类型都继承公共的基类 object,使用CTS可以确保系统类型和用户定义类型能被任何.net兼容的语言所使用
2. **CLS（COmmon Language Soecification）**：公共语言规范，详细说明了.net兼任语言的规则和行为，包括参数传递，类结构，数据类型。

### 1.3 编译成本机代码并执行

```mermaid
graph LR;
	id0-->id7
	id7-->id1
	id1-->id2
	id2-->id3
	id3-->id5
	subgraph 编译时
    id0[c#源文件]
    id7[c#编译器]
    id1[程序集:A.类型信息 B.CIL]
	end
	subgraph 运行时
	id2[JIT编译器 公共语言运行库CLR]
    id3[本机代码]
    id5[操作系统服务]
	end
```

**编译步骤**：

1. 检查程序集的安全特性
2. 在内存中分配空间
3. 把程序集中的可执行代码发送给JIT，把其中一部分编译成本机代码。

**需要注意的点：**

- 程序集中的可执行代码只有在需要时才会有JIT编译，编译后被缓存起来以备后面的程序执行。不被调用的代码将不会被编译。并且被调用的代码只编译一次。
- CIL被JIT编译为本机代码后，在运行时会被CLR管理，执行GC检查数组边界参数类型异常管理的任务。
- CIL被调用运行时才会被编译成本机代码。

**JIT(Just-in-Time):**  实时编译器

Ngen工具可以将程序集转换成当前处理器的本机代码。Ngen处理过的代码可以免去运行时的JIT编译过程。

### 1.4 总结

.net的框架的结构和缩写:

```mermaid
graph TB
	subgraph 程序集
		id2[公共中间语言CILILMSIL]
	end
subgraph 公共语言基础结构
	id4[CTS公共类型系统]
	id5[CTS公共语言规范]
end
subgraph 公共语言运行库CLR
	id7[GC垃圾收集器]
	id8[JIT实时编译器]
	id9[BCL基类库]
end
```

## 二.格式规则

### 2.1 标识符

用来命名如变量，方法，参数等程序结构的字符串。命名上有一些规则：

- 字幕和下划线可以用在任何位置。
- 数字不能放在首位，但是可以放在其他地方。
- @字符只能放在标识符首位，虽然允许使用，但不推荐使用@做字符。
- 标识符区分大小写。

### 2.2 关键字

**定义：**

> 关键字是预定义的保留标识符，对编译器有特殊意义。 除非前面有 `@` 前缀，否则不能在程序中用作标识符。 例如，`@if` 是有效标识符，而 `if` 则不是，因为 `if` 是关键字。

**上下文关键字：**

> 上下文关键字仅在一部分程序上下文中有特殊含义，可以在相应上下文范围之外用作标识符。 一般来说，C# 语言中新增的关键字会作为上下文关键字添加，以免破坏用旧版语言编写的程序。

上下关键字是仅在特定语言结构中充当关键字的标识符，可以在代码的其他部分被用做标识符。

上下文关键字：

|        |           |       |         |         |            |         |
| :----- | --------- | ----- | ------- | ------- | ---------: | :-----: |
| add    | ascending | async | await   | by      | descending | dynamic |
| equals | from      | get   | global  | group   |         in |  into   |
| join   | let       | on    | orderby | partial |     remove | select  |
| set    | value     | var   | where   | yield   |            |         |

### 2.3 其他

**块：**

大括号包围的多条语句和序列，**在语法上相当于一条语句**。用于语法上只需要一条语句，但执行的动作无法用一条简单语句表达。

**WriteLine**:

{0} {1} 这叫替换值

```csharp
Console.WriteLine("aaaa {0} and {1}",3,6);
```

也可以：

```csharp
Console.WriteLine("aaaa {1} and {0}",3,6);
```

不要试图引用替换值长度列以外位置的值，比如{2}

**格式化数字字符串**：

这{1：C}叫格式说明符或者对齐说明符

```
{index(必选指定列表中的某一项),alignment(可选,指定字段宽度对齐):format(可选，指定项的格式)}
```

```csharp
//格式说明符如：
Console.WriteLine("aaaa {0:C}",3);
```

```csharp
//对齐说明符如：
//负数表示左对齐
Console.WriteLine("aaaa {0,10}",3);
```

```csharp
//标准的格式字段字符串形如:Axx，其中A代表格式说明符，XX代表精度
Console.WriteLine("aaaa {0:F4}",3.123); //像这种就表示显示四位小数点。
```

**文档注释**：

```csharp
///<summary>
///这是说明
///文档注释包含XML文本，可以生成程序文档。
///</summary>
```



## 三.类型，存储和变量

### 3.1 CSharp的相关特点

c的程序是一组函数和数据类型，c++是一组函数和类，但是**c#的程序(可执行程序或DLL)是一组类型声明。**

Main方法当然也是必须的，c#同时引入了命名空间:

**命名空间**是一种把相关的类型声明分组并命名的办法。

```csharp
namespace Game
{
    DeclarationOfTypeA
    DeclarationOfTypeB
    class C
    {
        static void Main()
        {
        }
    }
}
```

*****类就是一个模板，它本身并不是数据结构，但他说明了由模板构造的对象的特征。

### 3.2 预定义类型

```mermaid
graph TB

id6[简单类型]
id8[预定义类型]
id9[非数值类型]
id10[数值类型]
id11[整数类型]
id12[浮点类型]
id6---id10
id10---id11
id10---id12
id11---id13
id11---id15
id11---id17
id11---id18
id12---id20
id12---id21
id12---id22
id8---id6
id8---id2
id8---id3
id8---id4
id6---id9
id9---id5
id9---id7
subgraph  
	id2[object]
	id3[string]
	id4[dynamic]
end
subgraph    
id5[bool]
id7[char]
end
subgraph  
id20[decimal]
id21[float]
id22[double]
end
subgraph    
id13[8bit sbyte\byte]
id15[16bit short\ushort]
id17[32bit int\uint]
id18[ 64bitlong\along]
end

```

常用的预定义简单类型:

| 名称   | 范围                                                  | .net框架类型  | 默认值  |
| ------ | ----------------------------------------------------- | ------------- | ------- |
| byte   | 0~255 (2^8)                                           | System.Byte   | 0       |
| short  | -32768~32767 (2^16)                                   | System.Int16  | 0       |
| int    | -2147483638~2147483647 (2^32)                         | System.Int32  | 0       |
| long   | -9223372036854775808~<br />9223372036854775807 (2^64) | System.Int64  | 0       |
| float  | 1.5*10^(-45) ~ 3.4 *10^(38)                           | Sytem.Single  | 0.0F    |
| double | 5*10^(-324) ~ 1.7 *10^(308)                           | System.Double | 0.0D    |
| char   | U+0000~U+ffffSystem.Char                              | System.Char   | \ x0000 |

c#的类型名称就是.net框架类型的别名。.net框架类型可以在c#中直接使用但不推荐。

和C/C++不一样，c#数字不具有布尔意义。

预定义类型可以直接用，如int，和用户类型不一样。

### 3.3 用户类型

除了16种预定义类型，还可以创建用户定义类型，有6种类型可以由用户自己创建:

- 类类型(class)
- 结构类型(struct)
- 数组类型(array)
- 枚举类型(enum)
- 委托类型(delegate)
- 接口类型(interface)

*****用户定义类型必须先声明后实例化。

### 3.4 堆和栈

- 栈是内存数组。
- 堆是一块内存区域，GC会自动清除堆对象。

类型决定了对象的存储位置。类型有两种：值类型和引用类型。

- 值类型存放在栈里。
- 引用类型需要两块内存，一个存实际的数据，在堆中。另一个存引用，指向堆的存放位置，可能在堆中也可能在栈中。

*****对于一个引用类型，其实例数据部分始终存放在堆里，无论值还是引用

| 变量类型 | 存储位置     | 自动初始化 | 用途                       |
| -------- | ------------ | ---------- | -------------------------- |
| 本地变量 | 栈或者栈和堆 | 否         | 用于函数成员内部的本地计算 |
| 类字段   | 堆           | 是         | 类的成员                   |
| 结构字段 | 栈或堆       | 是         | 结构的成员                 |
| 参数     | 栈           | 否         | 用于把值传入或传出方法     |
| 数组元素 | 堆           | 是         | 数组的成员                 |

*注意：*

- dynamic关键字的类型在运行时才会被解析。
- c#和c++不同，不能再类型的外部声明全局变量。所有的字段都属于类型。也没有全局方法（在类型的外部)。

## 四.方法

*****方法体也是个块

### 4.1 变量的生存周期

|                | 实例字段                                                     | 本地变量                                           |
| -------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| **生存期**     | 从实例被创建开始                                             | 从它在块中被声明的那点开始，在块完成执行时结束。   |
| **隐式初始化** | 初始化该类型的默认值                                         | 没有隐式初始化。未初始化尝试使用编译器会报错。     |
| **存储区域**   | 实例字段是类的成员，所以所有字段都存在堆里。无论是值类型还是引用类型。 | 值类型：栈。引用类型：引用存在栈里，数据存在堆里。 |

*****c#和c++不一样 不允许在第一个有效范围内声明另一个同名本地变量。

### 4.2 隐式类型

- 在方法范围内声明的变量可以具有隐式类型var。var关键字不是特定类型变量的符号，只是语法速记。表示可以从右侧推断出类型。
- 隐式类型本地变量为强类型。
- var只能用于本地变量，不能用于字段，只能在变量声明中包括初始化时使用，一旦推断出类型则是固定不可更改的。
- 和js的var不一样。

### 4.3 Const关键字

- const 是核心声明的一部分必须放在类型前面。
- 必须有初始化语句，变量必须在声明时初始化，且以后不能改变。
- **const也可以是null，但不能是某个对象的引用，因为对象的引用是在运行时决定的。**

### 4.4 参数

**形参和实参**

形参（形式参数）：

- 方法的定义中的参数，一个占位符。没有数据，等到方法调用时接受传过来的参数。
- 只有在方法被调用时才会分配内存，方法调用结束后立即释放内存。

实参（实际参数）：

- 调用时传给形参。
- 实参必须有确切的值。
- 如果存在和形参类型的兼容，那么实参的类型可以和形参不一致。

**值传递参数和引用传递参数**

值传递参数：

- 把实参的值复制给形参。引用类型的实参会复制引用，对于值类型会复制值。
- 通过值传递参数，系统在栈上为形参分配内存。

引用传递参数：

- 引用传递参数不会在栈上分配内存，实际上，形参的参数名作为了实参变量的别名。指向相同的内存位置。所以修改了形参就是在修改实参。可以理解为C中的指针。
- 声明和调用使用ref修饰符。
- 实参同时必须是变量，在用作实参前必须被赋值。必须是变量的意思是 ，Function(ref 3+4)这种是不可以的。

*****数组作为实参传递，便一起会使用实参数组而不是创建新的

**引用类型作为值传递参数和引用传递参数**

无论是值参数还是引用参数，都可以在方法内部修改它的成员。但实质上还是有区别的。

作为值参数传递：

如果在方法内创建一个新对象并赋值给形参，实参和形参的关联会切断。 方法调用结束后，新对象也就不在了。

```mermaid
graph TB;
	subgraph 2对成员赋值后
	id4[栈:ref:f1]
	id5[栈:ref:a1]
	id6[堆:Val 20]
	id4-->id6
	id5-->id6
	end
	subgraph 1调用开始时
	id1[栈:ref:f1]
	id2[栈:ref:a1]
	id3[堆:Val 50]
	id1-->id3
	id2-->id3
	end
```

```mermaid
graph TB;
	subgraph 4方法完成后
	id5[栈:ref:a1]
	id6[堆:Val 50]
	id5-->id6
	end
	subgraph 3创建新对象并赋值给形参之后
	id1[栈:ref:f1]
	id2[栈:ref:a1]
	id3[堆:Val 20]
	id4[堆:Val 50]
	id1-->id3
	id2-->id4
	end
```

作为引用参数传递:

如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。

**输出参数**

输出参数用于方法体内把数据传出到调用代码,必须在声明和调用中都使用out修饰符。输出参数out，我个人理解和ref是不同功能的，out参数主要是为了将方法中的变量传出，而ref是为了将变量传入方法。

- 实参同时也必须是变量（out 3+5 不可以），不能是其他类型的表达式，因为方法需要内存位置保存返回值。
- 和引用参数相似，形参担当实参的别名，实参和形参是同一块内存。所以对形参的更改会改变实参。

输出参数有几个要求：

- 在方法中，输出参数在能够被读取前**必须被赋值**。这意味着参数的初始值是无关的，并且没必要在方法调用之前为实参赋值。
- 在方法返回前，内部贯穿的任何可能路径都必须为所有输出参数进行一次赋值。
- 此外，因为在方法内读取输出变量之前必须对其写入，所以不可能使用输出参数把数据传入方法。如果在赋值之前试图读取他，编译器会有错误信息。

**参数数组**

关键字params，允许零个或多个实参对应一个特殊的形参，注意的点：

- 参数列表中只能有一个参数数组。并且是最后一个
- 参数数组表示的所有参数必须有相同的类型。
- params修饰符不需要在调用时使用。

格式：

```csharp
void ListInts(params int[] invals)
```

可以通过两种方式给参数数组传参：

```csharp
ListInts（10,20,30）；
int[] intarray = {1,2,3};
ListInts（intarray）;
```

一些补充：

- 参数数组是一个数组，数组是引用类型，所以所有数据都保存在堆中。
- 如果对应的形参数组没有实参，编译器会创建一个有零个元素的数组使用。
- 当数组在堆中被创建时，实参的值是被**复制**到数组中，像值传递参数。
- 如果数组是值类型，则值被复制，实参不受方法内部影响。
- 如果数组是引用类型，那引用被复制，实参可能会收到方法内部影响。

**命名参数和位置参数**

一般的方法，实参和形参的顺序一致。称为位置参数。

还有一种，只需要要指定参数的名字，就可以任意顺序在方法调用中列出实参。叫做命名参数。

```csharp
Method(c:2,a:4,B:3)
```

可以同时使用位置参数和命名参数，但位置参数必须先列出来。

**可选参数**

表明某个参数是可选的，需要在方法声明时为参数提供默认值。不是所有的参数类型都可以作为可选参数：

- 只有值类型的默认值可以在编译时确定，才可以将值类型作为可选参数
- 只有默认值是null的时候引用类型才可以作为可选参数使用（意思是只能在方法签名上将此形参标记为null，而不是在签名中去尝试new这个引用类型。）
- 可选参数只能是值类型。

对于方法签名：所有必填参数必须在可选参数声明之前声明，如果有params参数必须在所有可选参数之后声明。

对于调用方法：省略参数必须在最后开始，也就是说不能前面省略，后面不省略。如果需要随意省略可选参数，必须使用命名参数的特性来实现，使用可选参数的名字来消除歧义。

- 

**参数类型语法使用总结**

| 参数类型 | 修饰符 | 是否在声明时使用 | 是否在调用时使用 |                  执行                  |
| :------: | :----: | :--------------: | :--------------: | :------------------------------------: |
|    值    |   无   |                  |                  |        系统把实参的值复制到形参        |
|   引用   |  ref   |        是        |        是        | 仅包含一个返回的值。形参是实参的别名。 |
|   输出   |  out   |        是        |        是        |  仅包含一个返回的值。形参是实参的别名  |
|   数组   | params |        是        |        否        |     允许传递可变数目的实参到方法。     |

### 4.6 重载

注意重载的讲解放入在方法章节中，可以作为提醒:重载是方法的一个性质，和类无关。

（突然想到，c支持重载吗？）

- 重载必须有和其他方法不一样的签名，签名包括：方法名称，参数数目，参数数据类型和顺序，参数修饰符。
- **返回类型不是签名的一部分，形参的名称也不是签名的一部分。**

### 4.7 栈帧

调用方法时内存从栈的顶部开始分配，保存和方法关联的数据项。这块内存叫**栈帧**(stack frame)。栈帧包括如下内容：

- 返回地址，方法退出时继续执行的位置。
- 方法的值参数，或者参数数组。
- 和方法调用相关的其他数据管理项。

栈帧的展开过程：

```mermaid
graph TB
	subgraph 从栈中弹出Methoda
	id10["Main()"]
	end
	subgraph 从栈中弹出MethodB
	id8["Main()"]
	id9["MethodA()"]
	end
	subgraph 从Main调用MethodB
	id2["Main()"]
	id3["MethodA()"]
	id4["MethodA()"]
	end
subgraph 从Main调用MethodA
	id4["Main()"]
	id5["MethodA()"]
end
subgraph 开始执行Main 
	id7["Main()"]
end
```

*****递归的调用会产生很多不同的独立栈帧。

## 五.类

类成员类型有9种：

- 数据成员：字段，常量
- 函数成员：方法，属性，运算符，构造函数，析构函数，事件，索引

声明类成员的方式：

```
[特性][修饰符]核心声明
```

多个特性和多个修饰符内部可以顺序随意，但整体上必须是这个顺序。

c#是单继承，但继承的层次没有限制。所有类都派生自object类，即使没有任何基类规格说明继承的类。object是唯一的非派生类，它是继承层次结构的基础。没有基类规格说明的类隐式派生自object。

派生类的实例由基类的实例加上派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分。

### 5.1静态成员

**Static 静态变量 **：

可修饰的类型不限，声明和构造方法种初始化，运行时是常量，只是使变量持有的引用不可变。初次构造后就确定了值。

- 静态字段被类的所有实例共享，所有实例都访问内存同一位置。
- 如果静态字段有初始化语句，那会在使用任何静态成员之前初始化该字段。但是不会在程序执行开始就初始化。
- 静态方法不能访问实例成员，但是能访问其他静态成员。
- 静态的成员当然也是在堆上。

**const常量**：

可修饰基本类型，声明的时候初始化，是常量。使用时不需要加载到内存。

- 成员常量不能被声明为静态的。
- 成员常量和本地常量差不多。同时成员常量的值必须是编译时可计算的。
- 和静态量不同，常量没有自己的存储位置，而是在编译时被编译器替换，类似于c和c++的define。

### 5.2 属性

属性不为数据存储分配内存，和字段不同，它是执行代码的。属性上不允许有除了get和set以外的其他方法，同时，访问器不能显示调用。

set 和 get访问器有预定义的语法和语义。set有一个隐式的值参数value，返回类型是void。get没有参数，且get所有路径必须包含一条return语句，返回和属性相同的类型。

属性和字段的区别：

- 属性是函数性成员不是数据成员。允许处理输入输出。字段不行
- 属性可以只读或者只写，字段不行。
- 编译后的变量和编译后的属性语义不同，这意味着将公共字段改为属性后，访问这个字段的其他程序集都需要编译。如果属性本身做一些更改，那不需要重新编译访问它的其他程序集。

**自动实现属性**

允许只声明属性而不声明后备字段。编译器会创建隐藏的后备字段，并自动挂接到get和set访问器上。自动属性使开发者在倾向于声明一个公有字段的地方很容易的插入一个属性。

- 不声明后备字段，编译器根据属性的类型分配存储。
- 不能提供访问器的方法体。也就是不能实现get和set。
- 除非通过访问器，否则不能访问后备字段。所以实现只读和只写属性没有意义，因此必须同时提供读写访问器。

静态属性：不能访问实例成员，只能被实例成员访问。不管有没有实例都是存在的。外部访问使用类名。

自动实现属性这个在具体开发的时候才能深刻理解到它存在的必要性，非常方便。

### 5.3 构造方法

构造函数声明为public可以从类的外部创建实例，需要注意的点：

- 构造函数没有返回值。
- 构造函数可以被重载。
- 如果用户声明了任何构造方法，则编译器不会提供默认的构造方法。
- 构造方法可以声明为static，用于初始化类级别的项，静态字段这种。

**静态构造方法**：

- 类中只能有一个静态构造函数，而且不能带参数。
- 静态构造函数不能有任何访问修饰符。
- 静态构造函数和静态方法一样，不能访问实例成员，因此不能使用this访问器
- 不能从程序中显示调用静态构造方法，系统会自动调用它，在：引用任何静态成员之前，创建类的任何实例之前。

**对象初始化**

两种初始化方法：

- new xxx()
- new xxx(){在此初始化设置公有字段的值}  大括号里就是初始化。这种方式也叫对象初始化语句，扩展了对象创建的语法。

*****需要注意，初始化发生在构造方法执行之后，因此构造方法中设置的值可能会在之后对象初始化中重置为相同或不相同的值。

### 5.4 析构函数 

析构函数具体在后面讲，执行类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源是指通过win32api获得的文件句柄 如果坚持使用。net类就不用编写析构方法

### 5.6 readonly修饰符

字段可以用readonly修饰符声明，作为类似const，一旦值被设定就不能改变。但有一些却别：

- const字段只能在声明语句中初始化，readonly可以在声明语句和任何构造函数中初始化。但如果readonly的字段是static的则需要在静态构造函数中初始化。
- const字段的值必须在编译的时候决定，但readonly可以在运行时决定。也就是说可以在不同的构造方法中设置不同的值。
- const的行为总是静态的，但readonly可以是实例字段，也可以是静态字段，并且在内存中有存储位置。

### 5.7 this关键字

在类中使用，对当前实例的引用。只能被用在实例构造函数、实例方法、属性和索引器的实例访问器中。this的目的是区分类的成员和本地变量或者参数，或者作为调用方法的实参。

*不能再静态方法中使用this。

### 5.8 索引器

和属性的比较：

- 和属性一样，不用分配内存来存储。
- 索引器和属性都是主要被用来访问其他数据成员。
- 属性通常表示单独的数据成员，索引通常表示多个数据成员。

*索引器不能被声明为static

需要注意：

- 索引器没有名称，在名称的位置是关键字this。

- 参数列表在方括号中间。

- 参数列表至少声明一个参数。

```csharp
ReturnType this[ Type param1,....]
{
	get{}
	set{}
}
```

**索引器的set访问器接受两项数据：**

- 隐式参数value持有的要保存的数据，
- 一个或更多索引参数表示数据应该保存到哪。

set访问器的含义:

```csharp
void set(ParameterList,Type value){}
```

get访问器必须检查索引参数确定他表示哪个字段，并返回字段值。get访问器的含义:

```csharp
void get(ParameterList){return ValueOftype}
```

*和属性一样，set和get是不能显示调用的，当索引器在表达式中取值时将自动调用get，赋值时自动调用set。

索引器的例子：

```csharp
class Empolyee
{
    public string LastName;
    public string FirstName;
    public string City;
    
    public string this[int index]
    {
        set{
            switch(idnex){
                case 0:lastName = value; break;
                    ...
                        default: throw new ArgumentOutOfRangeexception("index");}}
        get{
            case 0:return LastName; break;
                    ...
                        default: throw new ArgumentOutOfRangeexception("index");}}}
```

*索引器可以重载，一定要保持有不同的参数列表:

```csharp
class Class1
{
    int tmp1;
    int tmp2;
    public int this[int index]
    {
        get{   ... }
        set{   ... }
    }
    public int this[int index，int index]
    {
        get{...}
        set{...}
    }
}
```

### 5.9 访问器的修饰符

*注意是访问器，是属性和索引中的访问器。

属性和索引器是函数成员，并自带了get和set访问器。可以通过对get和set设置不同的访问级别，是对象的外部只能读取该属性而不能写入，这是一个非常重要的封装工具。在实际的开发中很常用这种封装方法。

但要注意，必须同时有gat和set访问器时，访问器才能有修饰符，并且只能有一个访问修饰符。访问器的修饰符必须比成员的级别更严格。 也就是访问器的访问级别必须要比成员的访问级别的位置低，也不能等于属性的访问级别。

访问级别：

```mermaid
graph LR
id0[public]-->id1[protected internal]
id1-->id2[protected]
id1-->id3[internal]
id2-->id4[private]
id3-->id4[private]
```

### 5.10 分部类和分部类型

分部类可以声明在不同或相同的文件中，局部声明要被标注为partial class。partial不是关键字，在程序中可以用于标识符。但在class struct（局部结构），interface（局部借口）前它表示分布类型。

**分部方法：**

分布方法是声明在分部类中不同部分的方法，也可以声明在同一个类中，分为两个部分：

- 定义分布方法声明：给出签名和返回类型，声明的实现部分知识一个分号。
- 实现分部方法声明：给出签名和返回类型，是以正常形式的语句块实现。

需要注意的内容：

定义和实现的签名和返回类型必须匹配。返回类型必须是void，签名不能包括访问修饰符，也就是说分部方法是私有的，列表不能包含out参数。定义和实现必须包含上下文关键字partial，直接放在关键字void之前。可以有定义而没有实现，但编译器会把方法的声明以及方法内部任何对方法的调用移除。

例子：

```csharp
public class Myclass
{
    partial void PrintSum(int x , int y); 
    
    public void Add(int x, int y)
    {
        PrintSum(x,y);
    }
}

partial class Myclass
{
    partial void PrintSum(int x, int y)
    {
        console.writeLine("xxx:" , x +y);
    }
}
```

### 5.11 屏蔽基类成员

无法删除父类的任何成员，但是可以通过声明和父类一样名字的成员来屏蔽基类成员：

1. 声明一个相同名称相同类型的成员
2. 屏蔽方法需要在派生类中声明新的带有相同签名的函数成员。
3. 使用new修饰符告诉编译器正在故意屏蔽继承的成员，否则程序会成功编译，但会警告你隐藏了一个继承的成员。

*****签名是有名称和参数列表组成，不包括返回类型。

例子：

```csharp
class Someclass
 ｛
    public string a;
   ｝
class someclass2
{
    new public string a;
}

```

可以使用基类访问（base access）表达式访问隐藏的继承成员。

```csharp
Console.WriteLine("{0}" , base.a);
```

*屏蔽基类成员再使用基类访问，并不是好的设计方式

### 5.12虚方法和覆写方法

基类引用调用派生类（derived class）方法：

1. 派生类的方法和基类的方法有享用的签名和返回类型
2. 基类的方法使用virtual标注
3. 派生类的方法使用override标注

*注意此方式和new隐藏基类成员在行为上的区别。

需要注意：

- 覆写和被覆写的方法必须具有相同的可访问性。
- 不能覆写static方法或非虚方法
- 方法，属性，索引器，以及事件，都可以被声明为virtual和override

**覆写标记为override的方法**

覆写方法可以在继承的任何层次出现，对象的基类部分引用调用一个被覆写的方法时，方法会执行标记为override的方法的最高派生版本。若更高的派生级别有该方法的其他声明，但没标记override，则不会被调用。

```csharp
Class MyBaseClass
{
	Virtual public void Print()
	{
	   //输出 base
	}
}
```

```csharp
Class myderivedClass:MyBaseClass
{
	override public void Print()
	{
	 //输出derivedclass
    }
}
```

```csharp
Class SecondDervied:MyDerivedClass
{
	override public void Print()
	{
		//输出Second
	}
}
```


几种情况：
```csharp
//1.SecondDervied的Print是正常覆写的。
SecondDervied secd = new SecondDervied() 
MyBaseClass mybb = （ MyBaseClass）d；

secd.print  //调用的是SecondDervied的方法，这是正常的
mybb.print //调用的也是SecondDervied的方法
```

```csharp
//2.使用new声明sec类的Print

SecondDervied d = new SecondDervied() 
MyBaseClass b = （ MyBaseClass）d；

d.print  //调用的是SecondDervied 的方法，这是正常的
b.print //调用的是myderivedClass的方法，也就是说，只向上传递了一级到了myderivedClass override的print方法。sec类的print方法被new屏蔽掉了无法调用。
```

*属性，事件索引器也是可以被覆写的。

**一些问题**

1. b可以调用SecondDervied 的方法，是因为它虽然是父类的引用，但堆上有子类的数据所以可以调用子类的方法。如果只是单纯的new了一个父类，是不是就没法调用子类的方法了？
2. 覆写到底是什么，和覆盖的区别是
3. 覆写，覆盖，重载？

### 5.13 构造函数的执行

- 调用对象的基类部分，需要隐式调用基类的某个构造函数作为创建实例过程的一部分。
- 继承层次中的每个类在执行自己的构造方法之前执行它的基类构造方法。
- 构造方法中调用虚方法是及其不推荐的。

**一些问题：**

如果基类的构造方法没有无参的怎么办还会自动调用吗

**指定构造方法**

派生类使用指定的基类构造函数，或使用指定的派生类构造方法，有两个办法：

1. 使用关键字base并指明使用哪一个基类构造函数 

   ```csharp
   Public aclass(int x):base(x)
   ```

2. 使用关键字this,并指明使用父类的哪一个构造函数

   ```csharp
   Public aclass(int x):this(x,"dadasdad")
   ```

   *****this的一个用处是从多个构造函数中抽离出公用的构造方法代码，书中很推荐这种做法。

   *****还有一种写法，但并不是好办法。抽离出代码，只作为一个公共方法，而不是公共构造方法，这样的坏处有两点：一是编译器知道方法是构造方法后会进行一些优化，第二有些事必须在构造方法中执行，比如readonly字段只能在构造方法中初始化。

   *****当然，如果this抽离的公共构造方法可以初始化类所需要的所有东西，那也可以作为独立有效的构造方法，反之可以设置成private，只能让其他构造方法调用。



### 5.14 类的访问级别

类的可访问级别有两种：public和internal。标记为internal的类只能被其所在的程序集中的类看到（程序集不是程序也不是dll，第二十一章讲）。

*类和成员的访问修饰符是有区别的



### 5.15 程序集间的继承

c#可以从不同的程序集内定义的基类来派生类，不同的程序集派生类需要几个条件：

1. 基类必须为public，这样才能在外部访问。
2. 在vs工程中的reference节点添加对包含该基类的程序集的引用。

*****放置一个using指令，带上要访问的类或类型所在的命名空间就可以不使用完全限定名称。

*****增加对其他程序集的引用和using指令是两回事。增加引用是告诉编译器所需的类型在哪定义，using只是允许不使用完全限定名称而已。



### 5.16 成员访问修饰符

b类能否访问a类成员，取决于a类的两个特征：

1. B是否派生自A。
2. .B是否和A在同一个程序集。

成员默认的访问级别是private，不能比类有更高级别的访问性。

**成员可访问性需要注意的点：**

- private类成员只能被自己的类成员访问，不能被继承的类访问。但private类能被嵌套类访问。
- protected的访问级别和private差不多，但它允许派生类访问该成员。（程序集外部继承也能访问）
- internal对程序集内部的所有类可见，对程序集外部的类不可见。
- Protect internal 对所有继承该类以及程序集内部的类可见。是并集，不是交集。

|       修饰符       |                    含义                    |
| :----------------: | :----------------------------------------: |
|      private       |            只在类的内部可访问。            |
|      internal      |         对该程序集内所有类可访问。         |
|     protected      |         对所有继承该类的类可访问。         |
| protected internal | 对所有继承该类或在该程序集内声明的类可访问 |
|       public       |              对任何类可访问。              |



### 5.17 抽象成员

抽象成员是被设计为覆盖的函数成员（字段和常量不可以）。

**需要注意的点：**

- 必须用abstract修饰符标记。不能实现代码。
- 抽象成员只能在抽象类中声明。方法，属性，事件，索引可以被声明为抽象的。
- virtual修饰符不能被附加到abstract。
- 实现派生类抽象成员，必须指定override修饰符。

比较虚成员和抽象成员

|                  | 虚成员                     | 抽象成员                   |
| ---------------- | -------------------------- | -------------------------- |
| 关键字           | virtual                    | abstract                   |
| 实现体           | 有实现体。                 | 没有实现体，分号代替。     |
| 在派生类中被覆写 | 能被覆写，使用override。   | 必须被覆写，使用override。 |
| 成员的类型       | 方法，属性，事件，索引器。 | 方法，属性，事件，索引器。 |

### 5.17 抽象类

抽象类是被设计为继承的类。抽象类只能被用作其他类的基类。

注意的几点：

- 不能创建抽象类的实例。
- 抽象类使用abstract修饰符声明。
- 抽象类可以包含抽象成员和普通成员。
- 抽象类可以派生自另一个抽象类。
- 派生自抽象类的类必须使用override关键字实现抽象类的所有抽象成员，除非派生类也是抽象的。

### 5.18 密封类

sealed只能被用作独立的类，不能被当作基类。继承密封类编译器会报错

### 5.19 静态类

静态类中所有成员都是静态的。数学库这样的类就很适合作为静态库。

注意的几点：

- 类必须标记为static
- 所有成员必须是静态的
- 类可以有一个静态构造函数但不能有实例构造函数。
- 静态类是隐式密封的。
- 静态类的成员是用过类名调用。

### 5.20 扩展方法

扩展方法允许编写的放和声明他的类之外的类关联。

```csharp
Static class extendmydata

｛

Public static double xxx(this 类名 md)｛｝

｝
```

注意：

- 声明的扩展方法必须声明为static。
- 扩张方法必须声明问static。
- .第一个参数类型是this 且后面跟着它想扩展的类名称。

## 六 表达式和运算符

### 6.1 简述

- 表达式求值是将每个运算符应用到它的操作数的过程。
- 运算符是符号，表示返回单个结果的操作。运算符会做：将操作数作为输入-执行某个操作-基于该操作返回一个值。比如说：a+b+c+d 就是3个运算符4个操作数。
- 操作数是指作为运算符输入的数据元素。

*表达式和运算符的关系:表达式里包含了运算符。

运算符需要注意的点：

- 特殊运算符：可空类型的特殊运算符，空接合运算符。

- 赋值运算符：对运算符右边的表达式求值，并设置为左边变量的值。赋值表达式是一个表达式，所以x=10也是一个值，所以x=z=y=10也是成立的。

- 条件运算符：和If 不一样，if是控制流语句，应当作为控制，控制两个行为执行其中一个。条件运算符返回的是一个表达式，他应该是返回两个值中的一个。

- typeof运算符：不能重载。一元运算符使用示例：

  ```csharp
  Type t =typeof(someclass);
  T.getFields();
  T.Getmethod();
  ```

### 6.2 字面量

字面量是明确，固定的值。字面量是写入源代码的，所以它的值必须在编译时可知。

- 整数字面量：可以是 123，123L，123U（无符号整型）,123UL（无符号长整形）,或者是16进制。对于已知后缀，编译器会把数字字符串解释为能表示该值而不丢失数据的最小类型。
- 实数字面量：6.2698e-12 ，123.31F.注意无后缀的实数字面量是double类型。
- 字符字面量：类型是char，简单转移数序列是反斜杠加单个字符 \n这种。
- 常规字符串字面量：包含字符，简单转移序列，16进制和Unicode转移序列。
- 逐字字符串字面量：有一个@作为前缀，并且转义字符串不会被求值。都会被打印出来。有一个例外是双引号组会被解释为单个双引号字符。

*****编译器会让相同的字符串字面量共享堆中同一内存位置以节约内存。

### 6.3 求值顺序

赋值运算符和条件是最低的，其次是位或与，接着是相等，然后是移位，移位上面是加减乘除。初级运算符（语言中的. 方法调用，索引，自增，new）是最高的，其次是一元运算符（+-!~）。

*****注意：之前上学的时候有讲过++x和x++的区别，在c#中，x++是初级运算符，++x是一元运算符。所以说他们是两种不一样的操作。

### 6.4 关系比较运算符和相等比较运算符

关系比较运算符和相等比较运算符就是< =>，比较操作数并返回bool类型值。

C#中数字不具备布尔意义。

这有一个疑问，实际上我在StackOverflow上有看过关于这个解释，因为false是0的表示，所以取反是true的同时，0取反也恰好是1，不知道c#是不是有这个意思。

#### 6.4.1 浅比较

比较两个引用类型的相等性时，一般是比较它们的引用。如果引用相等，就意味着两个变量都指向内存中同一个对象，相等性比较为true。如果两个变量不指向同一个对象，哪怕是两个对象的数据完全一致也是false。

#### 6.4.2 深比较

string类型的对象也是引用类型，但是他的比较方式不同。比较时会比较内容（区分大小写）和长度。即使两个string占据不同的内存区域，但长度和内容相等，那相等性比较的也是true。

*****委托使用的也是深比较。不看内存位置，只看内容。

### 6.5 条件逻辑运算符

短路操作：如果 expr1&&expr2 或 expr1&&expr2 中expr1的结果已经确定了就会跳过expr2的值。

因为短路操作的存在，所以不要在expr2中放置带副作用的表达式。

### 6.6 逻辑运算符

| 运算符 | 名称   | 描述                                                         |
| ------ | ------ | ------------------------------------------------------------ |
| &      | 位与   | 仅当两个操作位都为1时结果位才是1。                           |
| \|     | 位或   | 只要任意一个操作位为1结果位就是1。                           |
| ^      | 位异或 | 仅当一个而不是两个操作数为1时结果位为1。                     |
| ~      | 位非   | 一元操作符。操作数的每一个位都取反。该操作得到操作数的二进制反码。 |

### 6.7 移位运算符

#### 6.7.1 补码

底层使用二进制补码的形式表示有符号二进制数。正数使用正常的二进制形式，如果取一个数的相反数需要把这个数按位取反再加一。二进制补码中所有的负数最左边的比特位置都是1。

```csharp
0|0|0|0|1|1|0|0 //12
1|1|1|1|0|0|1|1 //按位取反
1|1|1|1|0|1|0|0 //+1 二进制补码 -12     
```

若直接将10111111转换成十进制，发现结果并不是-65，而是191。 事实上，在计算机内，如果是一个二进制数，其最左边的位是1，则我们可以判定它为负数，并且是用补码表示。 若要得到一个负二进制补码的数值，只要对补码全部取反并加1，就可得到其数值。所以说当要使用一个负数时，是有一层补码的转换的。

#### 6.7.2 移位运算完成乘法

通过位移可以迅速的完成乘法，比如把整数左移一位的结果和乘2的结果是相同的，右移一位的结果和除以2相同，移掉的位置补0。

```csharp
//乘法
0|0|0|0|1|1|1|0 //14
0|1|1|1|0|0|0|0 //14 << 3 = 112
//除法
0|0|0|0|1|1|1|0 //14
0|0|0|0|0|0|0|1 //14 >> 3 = 1   
```

但是在负数中右移会有问题，右移一位左边补0的话就变成了正数，所以，当操作数是有符号负数时，如果最左边的位是1，在左边移开的位位置用1填充，而不是0。正数还照常。

### 6.8 类型转换

隐式转换：如果有必要，编译器会自动执行转换。

显示转换：编译器只在使用显示转换运算符时才执行转换。

#### 6.8.1 用户定义转换

声明隐式转换：

```csharp
pulic static implicit operator TargetType（Sourcetype identifier）
{ Return objectoftargettype；}
```

声明显示转换：

```csharp
pulic static explicit operator TargetType（Sourcetype identifier）
{Return objectoftargettype；}
```

public和static是必须的。

### 6.9 运算符重载

运算符重载只能用于类和结构。

一元重载运算符的重载方法：

```csharp
public static LimitedInt operator-(LimitedInt x)
```

二元重载运算符的重载方法：

```csharp
public static LimitedInt operator+(LimitedInt x，double y)
```

可以重载的符号：

- 一元运算符：+，-，!，~，++，--，true,false。
- 二元运算符：+，-，*，/，%，&，|，^，<<，>>，==，!=，>，<，>=，<=

重载的符号不可以做的事情：

- 创建新运算符
- 改变运算符语法
- 重新定义运算符如何处理预定义类型
- 改变运算符的优先级或结合性

## 七 语句

### 7.1 什么是语句

简单语句由一个表达式和后面跟着的分号组成。

块是由一对大括号括起来的语句序列。括起来的语句可以包括：

- 声明语句
- 嵌入语句
- 标签语句
- 嵌套块。

### 7.2 表达式语句

表达式有返回值，但实际上表达式也有副作用。副作用是一种影响程序状态的行为，许多表达式求值只是为了他们的副作用，比如说x=10这个赋值表达式（由一个运算符和两个操作数组成），实质上我们只是想给x赋值，但给x赋值只是副作用。表达式的主要目的返回x的新值由于没人接收反而被忽略了。

可以在表达式的后面防止语句终结符，分号；来从一个表达式创建一条语句。表达式返回的值会被丢弃。

```csharp
x=10; //表示计算这个表达式的全部原因就是为了完成这个副作用。
```

### 7.3 控制流语句

控制流结构：条件执行，循环语句，跳转语句。

条件执行和循环结构（除了foreach）都需要一个测试表达式或条件来决定怎么执行。

*注意foreach不能在循环时删减遍历元素。

### 7.7 do语句

即使条件为false，do也会至少执行一次。

:grey_question: 如果在while里改变了了测试表达式的值怎么办

### 7.8 for语句

```csharp
for(initiallizer;testexpr;iterationexpr)
{
    statement;
}

```

initiallizer只执行一次，在所有for结构其他部分之前。initiallizer中的变量只在改for语句的内部可见。

### 7.9 swich语句

- 每个分支以一个或多个分支标签case开始。
- 每个分支末尾必须是break结束或者其他四种跳转语句。所以说，不是说一个case分支可以不写跳转语句而去读了下一个case的语句，而是，其实他们两个是一个分支语句，但是有两个分支标签。
- 分支标签会按顺序求值，如果case和swtich的测试表达式一致则执行该分支。然后跳到swtich语句底部。
- 如果写了default，那一定要写跳转语句。
- case后面的分支标签是常量表达式，必须在编译的时候就完全获取到运算结果。
- 与c和c++不同，每个switch段，包括default必须以一个跳转语句结尾，也不可以执行一个switch段中的代码然后直接执行接下来的部分。c#不允许一个分支到另一个分支。

### 7.10 跳转语句

break跳出最内层的封装语句。

continue转到最内层的封装语句的顶端

#### 7.10.1 标签语句

标签语句主要用于goto语句。

- 标签语句的形式：Identifier：statement
- 标签语句会执行statement，不会执行任何identifier有关的东西。
- 标签语句有自己的声明空间，所以和作用域内的其他标识符重复也没关系。
- 标签语句不能是关键字，或在范围内和其他标签标识符相同。

作用域：声明所在的块，嵌套在该块内部的块。

```csharp
xyz：x=10;
```

#### 7.10.2 goto语句

goto语句无条件转移控制到一个标签语句

goto也可以把控制转移到switch语句内部的标签中

```csharp
goto case constantexpression
goto default;
```

### 7.11 using语句

using语句用于简化释放非托管对象资源，被适当的dispose。资源是指实现了system.idisposable接口的类或者结构。idisposable接口中含有一个名称为dispose的方法。

*****using指令不等同于using语句。

using语句帮助减少了意外的运行错误带来的潜在问题，常规的资源使用流程:

```csharp
//1.分配资源
ResType Resource = new ResType(....);

//2.使用资源,如果这一段发生异常，Dispose将不被调用。
//使用Resource的语句
...
//异常导致控制转移出方法之外，步骤3将不会被调用。

//3.处置资源
Resource.Dispose;
```

使用using语句的方式：

```csharp
//圆括号内的代码分配资源
//statement是使用资源的代码
//using语句隐式产生处置该资源的代码。
using(ResType res = Expression)Statement
```

using语句的内部原理：

1. 分配资源
2. 把statement放进try块
3. 创建资源的dispose方法的调用，并放进finally块。

```csharp
using(ResType res = new ResType(....) )Statement

//内部是这样的：
{
    ResType res = new ResType(....);
    try
    {
        Statement
    }
    finally
    {
        //由using语句隐式提供
        Dispose of resource
    }
}

```

多种using语句的使用实例：

```csharp
using System;
using System.IO;
namespace UsingStatement
{
    class Program
    {
        static void Main()
        {
            using(TextWriter tw = File.CreateText("L.txt"))
            {
                tw.WriteLine("YYY");
            }
            
            //也可以用于相同类型的多个资源
            using(TextWriter tw = File.CreateText("L1.txt")
                 			 tw2 = File.CreateText("L2.txt"))
            {
                tw.WriteLine("zzzzz");
            }
            
            //也可以嵌套
            using(TextWriter tw = File.CreateText("L1.txt"))
            {
              using(TextWriter tw = File.CreateText("L3.txt"))
            	{
                tw.WriteLine("XXXX");
            	}
            }
            //另一种形式 using(资源)使用资源
            //这种形式也能确保调用dispose方法，
            //但不能防止using语句已经释放了他的非托管资源后使用该资源。
            //资源声明和之前的声明已经不同了，是在try的外面。
            TextWriter tw = File.CreateText("L4.txt");
            using(tw)
                tw.WriteLine("ccccc");
        }
    }
}
```













