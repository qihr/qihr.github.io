<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/myselficon.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/myselficon32.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/myselficon16.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","width":200,"display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="该文档主要是介绍Unity的导航系统和寻路插件使用，不同场景下寻路的工作流程，以及工作原理，没有涉及太多API讲解以及如何与其他组件的集成开发。 目录下包含一个简单的演示Demo，里面包括我作为练习写的几个Scene以及官方提供的实例，需要使用寻路导航系统的场景非常多，这些场景中彼此又具有较大的差异，如寻路时动态躲避障碍物，追逐某移动中的角色寻路，Demo中没有包含实际游戏中的全部情况，想了解更多">
<meta name="keywords" content="游戏寻路,Untiy插件,Unity">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity NavMesh和寻路插件使用">
<meta property="og:url" content="http://yoursite.com/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/index.html">
<meta property="og:site_name" content="Note">
<meta property="og:description" content="该文档主要是介绍Unity的导航系统和寻路插件使用，不同场景下寻路的工作流程，以及工作原理，没有涉及太多API讲解以及如何与其他组件的集成开发。 目录下包含一个简单的演示Demo，里面包括我作为练习写的几个Scene以及官方提供的实例，需要使用寻路导航系统的场景非常多，这些场景中彼此又具有较大的差异，如寻路时动态躲避障碍物，追逐某移动中的角色寻路，Demo中没有包含实际游戏中的全部情况，想了解更多">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/31495094.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/70165612.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/96097041.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/94681976.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/99046946.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/42872518.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/88655117.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/84206917.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/16669861.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/38863987.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/21458525.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/55686986.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/19669556.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/85524153.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/Image%200011544708028.png">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/56907644.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/22999412.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/34063515.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/48909730.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/65051244.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/32907915.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/48197356.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/43707615.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/24937663.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/50847199.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/Image%20007.png">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/67341465.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/94816236.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/80234410.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/52457988.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/97970624.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/56354906.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/19088313.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/61300703.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/68085785.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/72400628.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/42188782.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/319203.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/66303692.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/20822682.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/44968356.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/83227170.jpg">
<meta property="og:updated_time" content="2019-12-11T15:37:07.615Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unity NavMesh和寻路插件使用">
<meta name="twitter:description" content="该文档主要是介绍Unity的导航系统和寻路插件使用，不同场景下寻路的工作流程，以及工作原理，没有涉及太多API讲解以及如何与其他组件的集成开发。 目录下包含一个简单的演示Demo，里面包括我作为练习写的几个Scene以及官方提供的实例，需要使用寻路导航系统的场景非常多，这些场景中彼此又具有较大的差异，如寻路时动态躲避障碍物，追逐某移动中的角色寻路，Demo中没有包含实际游戏中的全部情况，想了解更多">
<meta name="twitter:image" content="http://yoursite.com/2019/12/11/Unity%20NavMesh和寻路插件使用/Unity%20NavMesh和寻路插件使用/31495094.jpg">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Unity NavMesh和寻路插件使用 | Note</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">How more than you show,speak less than you know.</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sayi">
      <meta itemprop="description" content="Just noob.">
      <meta itemprop="image" content="/images/myselelogin.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Unity NavMesh和寻路插件使用

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-11 23:37:07" itemprop="dateCreated datePublished" datetime="2019-12-11T23:37:07+08:00">2019-12-11</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Program/" itemprop="url" rel="index"><span itemprop="name">Program</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">14k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">13 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>该文档主要是介绍Unity的导航系统和寻路插件使用，不同场景下寻路的工作流程，以及工作原理，没有涉及太多API讲解以及如何与其他组件的集成开发。</p>
<p>目录下包含一个简单的演示Demo，里面包括我作为练习写的几个Scene以及官方提供的实例，需要使用寻路导航系统的场景非常多，这些场景中彼此又具有较大的差异，如寻路时动态躲避障碍物，追逐某移动中的角色寻路，Demo中没有包含实际游戏中的全部情况，想了解更多可以去下载官网Demo，或看一些更专业的教程，下载地址和教程以及我学习时查询的资料的链接会在附录中给出。</p>
<p>文档若出现错误，请及时指正。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>备注</strong></p>
<hr>
<p>2018.12.10 Unity的NavMesh应用于简单的静态动态场景的使用方法介绍，以及A*插件的部分使用方法介绍。<br>2018.12.14 Unity的NavMesh的工作原理概述，navgation系统中各个组件面板介绍。<br>2018.12.18 介绍Unity的NavMesh中的实时局部Bake场景，自动离网链接场景的简单使用。<br>2018.12.19 增加寻路代价实现demo</p>
<h2 id="Unity的导航系统"><a href="#Unity的导航系统" class="headerlink" title="Unity的导航系统"></a>Unity的导航系统</h2><p>Unity的导航系统主要有四个部分：<strong>NavMesh</strong>，<strong>NavMesh Agent</strong>，<strong>Off-Mesh Link</strong>，<strong>NavMesh Obstacle</strong>。</p>
<p><strong>NavMesh</strong>（ Navigation Mesh的缩写）导航网格，是一种<strong>数据结构</strong>，并将游戏中物体结构关系转化为带有信息的网格，通过网格进行计算自动寻路的路径。NavMesh数据可以通过烘焙(Bake)产生。</p>
<p><strong>NavMesh Agent</strong>导航网格代理，简称代理。是Unity导航系统的核心<strong>组件</strong>，用来存放代理周游NavMesh的路径信息的平台。角色导航避障的移动是通过<strong>代理</strong>(NavMesh Agent)实现的，也就是说除非使用其他的寻路算法，否则想让某一个物体具有寻路导航的功能，就必须要为他配置一个代理。该组件一般添加在需要寻路的角色上。</p>
<p><strong>Off-Mesh Link</strong>离网链接，该<strong>组件</strong>主要用于连接两个不连通的跳跃点，如跳过沟渠或者开门等场景。该组件一般添加在跳跃点上。</p>
<p><strong>NavMesh Obstacle</strong>导航网格障碍，该<strong>组件</strong>主要用于移动障碍。代理可以自动躲避添加了该组件的障碍物（动态和静态）。该组件一般添加在静止或移动的障碍物上。</p>
<p>导航系统的基本流程大概流程，比如一个RPG游戏的某个副本场景：</p>
<ol>
<li>为障碍物添加NavMesh Obstacle，根据实际情况对NavMesh Obstacle组件进行设置；</li>
<li>为传送点，跳跃点添加Off-Mesh Link；</li>
<li>烘焙副本场景，生成Navmesh；</li>
<li>为角色添加NavMesh Agent并指定参数；</li>
<li>角色寻路，代理根据生成好的NavMesh以及地图中的障碍物信息进行计算最佳路径。</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr>
<h4 id="NavMesh的生成"><a href="#NavMesh的生成" class="headerlink" title="NavMesh的生成"></a>NavMesh的生成</h4><p>我的理解（翻译）：</p>
<p>导航系统需要一种数据结构来存储游戏场景中的<strong>可行走区域</strong>。，可行走区域的定义是场景中<strong>代理</strong>可以站立和移动的区域。 同时，在Unity中，代理被视为圆柱体，并以圆柱的体积参数来参与计算。 <strong>可行走区域</strong>通过场景中测试代理可以站立的位置自动生成可供代理移动的，由多个多边形组成的平面（下图蓝色部分），平面置于游戏的地板（或几何体平面）之上，同时平面存储了有哪些多边形彼此相邻的信息，该表面称为导航网格（简称NavMesh）。NavMesh是可行走区域的<strong>近似值</strong>。</p>
<p>官方手册的原文：</p>
<blockquote>
<p>The navigation system needs its own data to represent the walkable areas in a game scene. The walkable areas define the places in the scene where the agent can stand and move. In Unity the agents are described as cylinders. The walkable area is built automatically from the geometry in the scene by testing the locations where the agent can stand. Then the locations are connected to a surface laying on top of the scene geometry. This surface is called the navigation mesh (NavMesh for short).<br>we store information about which polygons are neighbours to each other. This allows us to reason about the whole walkable area.</p>
<p>Another thing to keep in mind is that the NavMesh is an approximation of the walkable surface.This can be seen for example in the stairs which are represented as a flat surface, while the source surface has steps</p>
</blockquote>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/31495094.jpg" alt="@"></p>
<p>生成的蓝色NavMesh平面</p>
<p>在烘焙（Bake）后，会在场景同级目录生成一个文件夹：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/70165612.jpg" alt="文件夹"></p>
<p>文件夹</p>
<p>原文链接：</p>
<hr>
<h4 id="NavMesh生成的多边形"><a href="#NavMesh生成的多边形" class="headerlink" title="NavMesh生成的多边形"></a>NavMesh生成的多边形</h4><p>NavMesh生成的是凸多边形，凸多边形中任意两点可以以直线相连。</p>
<p>原文：</p>
<blockquote>
<p>The NavMesh stores this surface as convex polygons. Convex polygons are a useful representation, since we know that there are no obstructions between any two points inside a polygon. In addition to the polygon boundaries,</p>
</blockquote>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/96097041.jpg" alt="@"></p>
<p>AB两点无法通过直线相连</p>
<p>原文链接:</p>
<hr>
<h4 id="NavMesh-Agent如何找到路径"><a href="#NavMesh-Agent如何找到路径" class="headerlink" title="NavMesh Agent如何找到路径"></a>NavMesh Agent如何找到路径</h4><p>要查找场景中两个位置之间的路径，首先需要将起始位置和目标位置<strong>映射</strong>到附近的多边形上。 然后从起始位置开始搜索，访问所有临近多边形，直到到达目标位置。 根据被访问过的多边形，可以得到一个从起始位置到目标位置的多边形序列。，该序列被称为corridor。Unity寻找路径使用的算法是A *。</p>
<p>原文</p>
<blockquote>
<p>To find path between two locations in the scene, we first need to map the start and destination locations to their nearest polygons. Then we start searching from the start location, visiting all the neighbours until we reach the destination polygon. Tracing the visited polygons allows us to find the sequence of polygons which will lead from the start to the destination. A common algorithm to find the path is A* (pronounced “A star”), which is what Unity uses.</p>
<p>The sequence of polygons which describe the path from the start to the destination polygon is called a corridor. The agent will reach the destination by always steering towards the next visible corner of the corridor.</p>
</blockquote>
<p>关于为什么序列中储存的是多边形序列而不是路线线段：</p>
<blockquote>
<p>If you have a simple game where only one agent moves in the scene, it is fine to find all the corners of the corridor in one swoop and animate the character to move along the line segments connecting the corners.</p>
</blockquote>
<p>如果使用线段作为corridor，当场景内有多个角色在寻路时，角色之间要在互相避让彼此的同时并寻路，这样就会造成寻路路径和计算出的造成偏差。尝试使用由线段组成的路径来纠正这种偏差很快变得非常困难且容易出错。</p>
<hr>
<h4 id="障碍躲避"><a href="#障碍躲避" class="headerlink" title="障碍躲避"></a>障碍躲避</h4><p>躲避障碍是基于下一个区域的位置，并计算出到达目的地所需的期望方向和速度来完成转向。个人理解即角色遇到障碍时只考虑并计算，如何到达避开障碍物拐点需要的速度和方向。</p>
<p>原文：</p>
<blockquote>
<p>The steering logic takes the position of the next corner and based on that figures out a desired direction and speed (or velocity) needed to reach the destination. Using the desired velocity to move the agent can lead to collision with other agents.</p>
</blockquote>
<p>避障时选择了新的速度，这个速度由期望的方向和防止之后与其他寻路实体以及导航网格边缘碰撞来权衡的。 Unity目前使用RVO算法来预测和防止角色与障碍物碰撞。</p>
<hr>
<h4 id="Moving-the-Agent"><a href="#Moving-the-Agent" class="headerlink" title="Moving the Agent"></a>Moving the Agent</h4><p>在转向和避障之后，会得出最终的速度。在Unity里，寻路实体使用一个动力学的模型来模拟，通过计算加速度来使移动更自然和平滑。</p>
<hr>
<h4 id="Global-and-Local负责的工作"><a href="#Global-and-Local负责的工作" class="headerlink" title="Global and Local负责的工作"></a>Global and Local负责的工作</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/94681976.jpg" alt="img"></p>
<p>Global 的工作是在场景世界中寻找corridor。 在场景世界各地寻找计算corridor很耗费性能。</p>
<p>Local 的工作是通过线性存储的多边形导航关系路线corridor，来计算如何到达下一个拐点同时避开其他正在移动的物体。</p>
<p>打个比方，从家到公司，Globel负责计算这段路的行进路线，比如坐先公交-地铁-最后步行，但途中我如何刷卡进地铁，怎么过马路就是Local的工作了。Global负责宏观的路线规划，Local负责微观的细节处理。</p>
<p>原文：</p>
<blockquote>
<p>Global navigation is used to find the corridor across the world. Finding a path across the world is a costly operation requiring quite a lot of processing power and memory.</p>
<p>The linear list of polygons describing the path is a flexible data structure for steering, and it can be locally adjusted as the agent’s position moves. Local navigation tries to figure out how to efficiently move towards the next corner without colliding with other agents or moving objects.</p>
</blockquote>
<hr>
<h3 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍*"></a>组件介绍*</h3><hr>
<h4 id="1-Nav-Mesh-Agent"><a href="#1-Nav-Mesh-Agent" class="headerlink" title="1.Nav Mesh Agent"></a>1.Nav Mesh Agent</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/99046946.jpg" alt="@Nav Mesh Agent| cente"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Agent Type</td>
<td>代理类型，可以选择不同的代理类型</td>
</tr>
<tr>
<td>Base Offset</td>
<td>基本偏移，物体实际的锚点和代理锚点的偏移量。[1]</td>
</tr>
<tr>
<td><strong>Steering</strong></td>
<td></td>
</tr>
<tr>
<td>speed</td>
<td>速度，前往目的地的最大移动速度。</td>
</tr>
<tr>
<td>Angular Speed</td>
<td>角速度，最大的转角速度，角度/秒</td>
</tr>
<tr>
<td>Acceleration</td>
<td>加速度，最大加速度</td>
</tr>
<tr>
<td>Stopping Distance</td>
<td>停止距离，代理距离目的地小于该值时停止。[2]</td>
</tr>
<tr>
<td>Auto Braking</td>
<td>制动距离，当物体和目的地小于制动距离时，开始减速。[2]</td>
</tr>
<tr>
<td><strong>Obstacle Avoidance</strong></td>
<td></td>
</tr>
<tr>
<td>Radius</td>
<td>代理半径，该半径参数只用于寻路时使用，使用时最好比实际值大一些。[3]</td>
</tr>
<tr>
<td>Height</td>
<td>代理高度</td>
</tr>
<tr>
<td>Quality</td>
<td>避障精度，如果场景内存在大量的代理，可以通过降低精度来节省CPU消耗[4]</td>
</tr>
<tr>
<td>Priority</td>
<td>躲避优先级，当代理表现为逃避时，优先级低的代理将会被忽略。该值的范围从0到99:最重要=0，最不重要=99，默认=50。[5]</td>
</tr>
<tr>
<td><strong>Path Finding</strong></td>
<td></td>
</tr>
<tr>
<td>Auto Traverse Off MeshLink</td>
<td>自动生成离网链接，如果使用动画或某种特定方式穿过离网链接点，则应关闭此功能。[6]</td>
</tr>
<tr>
<td>Auto Repath</td>
<td>当前路径变成无效时该代理是否尝试获取新路径</td>
</tr>
<tr>
<td>Area Mask</td>
<td>代理在查找路径时会考虑的区域类型</td>
</tr>
</tbody>
</table>
<p>[1]</p>
<p>[4]又名躲避精度。通过降低该值的方式可降低CPU开销，但如果寻路物体的躲避精度为none时，虽然寻路实体依然会绕开障碍物，但寻路实体之间不会发生碰撞（寻路实体会粘合在一起）</p>
<hr>
<h4 id="2-Nav-Mesh-Obstacle"><a href="#2-Nav-Mesh-Obstacle" class="headerlink" title="2.Nav Mesh Obstacle"></a>2.Nav Mesh Obstacle</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/42872518.jpg" alt="@Nav Mesh Obstaclet"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shape</td>
<td>物体形状,盒子/胶囊体</td>
</tr>
<tr>
<td>Center</td>
<td>障碍的中心点，在对象的自身空间测量。</td>
</tr>
<tr>
<td>Size</td>
<td>障碍的大小，在对象的自身空间测量。</td>
</tr>
<tr>
<td>Carve</td>
<td>挖洞，是否打开在导航网格挖洞的模式。[1]</td>
</tr>
<tr>
<td>Move Threshold</td>
<td>移动距离阈值，物体移动距离超过阈值后将更新导航网格，导航网格将障碍物运动状态视为移动。</td>
</tr>
<tr>
<td>Time To Stationary</td>
<td>时间阈值，超过该值，刷新导航网格</td>
</tr>
<tr>
<td>Carve Only Stationary</td>
<td>勾选后，障碍物只在静止时挖洞</td>
</tr>
</tbody>
</table>
<p><strong>[1]</strong> 关于Carve:</p>
<p>障碍物有两种，一种是开启了Carve，一种是未开启，代理会根据障碍物的类型做出不同的反应：</p>
<p>Obstructing模式（关闭Carve）:障碍物没有开启Carve时，它只是一个带碰撞器的普通障碍物。导航过程中，代理会尽量避免与障碍物碰撞。但如果两者距离较近，还是会发生碰撞。因为障碍物躲避非常基础，并且是基于一个短半径来计算（模糊运算），所以当障碍物过多时会出现找不到路的情况。这个模式多用于动态障碍物，如汽车或游戏角色。</p>
<blockquote>
<p>When Carve is not enabled, the default behavior of the Nav Mesh Obstacle is similar to that of a Collider. Nav Mesh Agents try to avoid collisions with the Nav Mesh Obstacle, and when close, they collide with the Nav Mesh Obstacle. Obstacle avoidance behaviour is very basic, and has a short radius. As such, the Nav Mesh Agent might not be able to find its way around in an environment cluttered with Nav Mesh Obstacles. This mode is best used in cases where the obstacle is constantly moving (for example, a vehicle or player character).</p>
</blockquote>
<p>Carving模式（开启Carve）：Carve被勾选时，静止的障碍物所在的网格会出现一个空洞，表示不可通行，只有当这个障碍物正在移动时才会变成Obstructing模式。NavMesh会记录空洞的相关信息，并引导寻路实体绕开障碍物或者当路径被封锁时启动重新寻路。用烂车和木箱设置关卡障碍时切记要勾选镂空属性，当且仅当这些障碍物受到其他外力和固定游戏事件时，如爆炸，才能被移开。</p>
<blockquote>
<p>When Carve is enabled, the obstacle carves a hole in the NavMesh when stationary. When moving, the obstacle is an obstruction. When a hole is carved into the NavMesh, the pathfinder is able to navigate the Nav Mesh Agent around locations cluttered with obstacles, or find another route if the current path gets blocked by an obstacle. It’s good practice to turn on carving for Nav Mesh Obstacles that generally block navigation but can be moved by the player or other game events like explosions (for example, crates or barrels).</p>
</blockquote>
<p>两种障碍物的类型决定了计算的方式，Obstructing模式由Local负责处理，Carving模式由Global负责处理（代表着CPU开销更大）。</p>
<p>移动的障碍物应该尽量避免使用Carving模式，因为Carve产生的洞会影响NavMesh，同时Global的计算量也会增加，使CPU和内存开销变大。</p>
<hr>
<h4 id="3-Off-Mesh-Link"><a href="#3-Off-Mesh-Link" class="headerlink" title="3.Off Mesh Link"></a>3.Off Mesh Link</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/88655117.jpg" alt="@Off Mesh Link"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start</td>
<td>离网链接的（跳跃点）起始位置</td>
</tr>
<tr>
<td>End</td>
<td>离网链接的（跳跃点）终点位置</td>
</tr>
<tr>
<td>Cost Override</td>
<td>成本覆盖，如果值为正，则在计算处理路径请求时的路径成本时使用该值。值为负，则使用该区域的默认成本(Navigation面板中的Area中的Cost)</td>
</tr>
<tr>
<td>Bi Directional</td>
<td>勾选后可以双向移动，否则只能从Start到End。</td>
</tr>
<tr>
<td>Activated</td>
<td>勾选后角色寻路时将跳跃点也添加至计算范围，否则忽略。</td>
</tr>
<tr>
<td>Auto Upadate Positions</td>
<td>自动更新位置,若两端点位置有变化则自动此更新离网链接。</td>
</tr>
<tr>
<td>Navigation Area</td>
<td>跳跃点所属的区域。[2]</td>
</tr>
</tbody>
</table>
<p><em>注：offmeshlink可以使用任何带有Transform的游戏对象作为开始和结束标记。</em></p>
<hr>
<h4 id="4-Navigation面板（window栏-Navigation）"><a href="#4-Navigation面板（window栏-Navigation）" class="headerlink" title="4.Navigation面板（window栏-Navigation）"></a>4.Navigation面板（window栏-Navigation）</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/84206917.jpg" alt="@Navigation-Agents面板"></p>
<p>Agents面板用于代理和代理之间的躲避，该页的参数不参与Bake，只用于处理代理与代理，代理与障碍之间的躲避。<br>在使用章节有关于该面板如何使用的介绍。</p>
<p>关于此Tab，unity社区的问答：<a href="https://answers.unity.com/questions/1376465/what-is-the-difference-between-configuration-of-ag.html">https://answers.unity.com/questions/1376465/what-is-the-difference-between-configuration-of-ag.html</a></p>
<hr>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/16669861.jpg" alt="@Navigation-Areas面板"></p>
<p>Areas代表烘焙网格所在的图层， 有29种自定义类型和3种内置类型：Walkable，Not Walkable和Jump。<br>\1. Walkable是通用区域类型，可以在该区域上行走。<br>\2. Not Walkable是阻止导航的区域类型。<br>\3. Jump是分配给自动生成的离网链接的区域类型。<br>另外，每个NavMesh代理都有一个Area Mask，用于指定代理可以移动的区域。<br>Cost是寻路的代价（成本），比如角色可以选择两条路，一条是过河，一条是草地。这两种寻路方式可能消耗的成本不一样。或是一扇门，人类可以通过但是其他怪物不能通过。都需要通过控制cost和area来实现。具体使用看下面的寻路导航章节。</p>
<hr>
<p>Bake页面根据面板参数对当前场景进行烘焙地图，生成NavMesh，注意为了减少CPU和内存消耗，在烘焙设置中只能指定一种尺寸，如果需要生成多种NavMesh，<strong>参考下面章节。</strong><br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/38863987.jpg" alt="@Navigation-Bake面板"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Agent Radius</td>
<td>代理的中心与墙壁等障碍物可接近的距离半径。</td>
</tr>
<tr>
<td>Agent Height</td>
<td>代理的中心与墙壁等障碍物可接近的距离高度。</td>
</tr>
<tr>
<td>Max Slope</td>
<td>最大坡度，代理可以爬坡的最大高度。</td>
</tr>
<tr>
<td>Step Height</td>
<td>台阶高度，代理可以攀爬的最大台阶高度。</td>
</tr>
<tr>
<td><strong>Generated Off Mesh Links</strong></td>
<td></td>
</tr>
<tr>
<td>Drop Height</td>
<td>离网链接中最大的下落高度。[1]</td>
</tr>
<tr>
<td>Jump Distance</td>
<td>离网链接中最大的下落距离。[2]</td>
</tr>
</tbody>
</table>
<p>进阶设置具体在<strong>高级烘培设置</strong>章节看。</p>
<hr>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/21458525.jpg" alt="@Navigation-Object面板"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Navigation Static</td>
<td>导航静态,表示该游戏对象是否参与导航网格的烘焙。</td>
</tr>
<tr>
<td>OffMeshLink Generation</td>
<td>生成离网链接，选中该复选框，可以自动根据Drop Height（下落高度）和Jump Distance（跳跃距离）的参数设置生成离网链接</td>
</tr>
<tr>
<td>NavigationArea</td>
<td>导航区域设置。在默认情况下分为Walkable（行走区域），Not Walkable（<strong>不可行走层，该层即使在Area Mask中选择可走，实际运行也无法行走</strong>）和Jump（跳跃层）。（具体可以在Areas面板中进行设置）</td>
</tr>
</tbody>
</table>
<hr>
<p>###其他</p>
<p>####代理的半径</p>
<p>通过上面的内容可以注意到，代理的半径和高度可以在两个位置更改，一是Nav Mesh Agent，另一个是在Navigation面板中。</p>
<p>Navigation面板中设置表示代理如何闪避和碰撞静态的游戏物体，为了减少内存和CPU的开销，只能指定一种半径大小。</p>
<p>Nav Mesh Agent的属性值代表代理如何与动态障碍物以及其他之间的碰撞。</p>
<p>一般情况下两个半径设置大小相同。</p>
<hr>
<p>####高级烘培设置<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/55686986.jpg" alt="@高级烘培设置"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Advanced</strong></td>
<td></td>
</tr>
<tr>
<td>Manual Voxel Size</td>
<td>手动更改体素大小，通常不需要调整体素大小，有两种情况可能需要这样做：构建较小的代理半径或更准确的 NavMesh。</td>
</tr>
<tr>
<td>Voxel Size</td>
<td>体素大小</td>
</tr>
<tr>
<td>Min Region Area</td>
<td>最小区域设置，小于该值的NavMesh区域将被删除。</td>
</tr>
<tr>
<td>Height Mesh</td>
<td>高度网格</td>
</tr>
</tbody>
</table>
<p>[1]<strong>Min Region Area</strong>不能完全的删除所以小于该值的多边形，因为会有下面这种情况：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/19669556.jpg" alt="@删除前">删除前</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/85524153.jpg" alt="@删除后">删除后</p>
<p>可以看到，图中四个正方体上的多边形区域被删掉了，但是小于正方体上多边形面积的，位于正方体中间的区域却没有被删除，这是因为如果移除该区域则可能无法访问或连通周围的区域。</p>
<p>[2]<strong>Manual Voxel Size</strong>允许手动更改烘培的精准度，NavMesh是通过体素化场景内的物体生成的。 在生成NavMesh算法的开始，场景被栅格化为体素，然后提取可行走的表面，并将可行走的表面变成NavMesh。 <strong>voxel size</strong>表示生成的NavMesh的准确程度。</p>
<p><strong>voxel size</strong>的默认精度始终是代理半径的1/3，也就是和代理半径保持着3倍的关系。这是Unity官方在精确度和烘焙速度之间的折衷方案。<strong>将体素大小减半会使内存使用量增加4倍</strong>，<strong>构建场景需要4倍的时间。</strong></p>
<p>原文：</p>
<blockquote>
<p>The default accuracy is set so that there are 3 voxels per agent radius, that is, the whole agent width is 6 voxels. This is a good trade off between accuracy and bake speed. Halving the voxel size will increase the memory usage by 4x and it will take 4x longer to build the scene.</p>
</blockquote>
<p>由于在默认情况下voxel size和代理半径表示为3倍关系，但可能会出现一种情况：需要较小的代理半径，但是不需要voxel size的值也跟随半径变小，可以使用以下办法：</p>
<ol>
<li>将“代理半径”设置为实际代理半径。</li>
<li>打开手动体素大小，这将采用当前体素大小并“冻结”。</li>
<li>设置较小的Agent Radius，因为已经开启了手动修改体素大小，所以大小不会改变。</li>
</ol>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/./Image 0011544708028.png" alt="@提示voxel size和代理半径关系的文本，较好的倍数是2-8倍| center|"></p>
<p>官方文档：<br><a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AdvancedSettings.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AdvancedSettings.html</a></p>
<hr>
<h4 id="寻路代价"><a href="#寻路代价" class="headerlink" title="寻路代价*"></a>寻路代价*</h4><p>通过cost可以定义通过该区域的困难程度(代价)，，成本更低的地方在寻路过程中优先级更高，cost可以控制角色寻路时偏好的区域。例如走草地要比走水路要快一些，就可以通过设置cost来实现。具体例子可以看<strong>演示章节</strong>。</p>
<p>在进一步了解之前，首先先了解一下A<em> 寻路的工作原理：Unity使用A</em>算法来寻找导航的最短路径，其核心数据结构为图。算法从离寻路实体最近的网格进行遍历，接着不停地访问相邻网格节点，直到搜寻到终点所在的网格区域(起点到终点的网格连线就是导航路径（此时未带入估价函数，即非最短路径）)。</p>
<p>因为导航网格是由一系列多边形组成的，所以寻路实体需要计算通过每块网格或者说节点的寻路代价。最短路径就是各节点连线的最低寻路代价。</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/56907644.jpg" alt="@图中黄色的点就是节点"></p>
<p>在两个节点之间移动的花费取决于行进距离以及当前所属区域的成本，即距离<em> 成本。 这意味着，如果一个区域的成本是2，那么寻路实体通过该区域的距离相对于普通区域的距离要大两倍。 A </em> 算法要求所有成本必须不小于1。</p>
<p>有时候可能会感觉在某些地方，寻路实体好像不会直接走最短路径。究其原因在于网格结点的放置位置。在空旷的地方有一个非常小的障碍物，这就会导致产生一大一小的网格。在这种情况下，网格结点可以放置在网格的任何地方，所以在我们看来，寻路实体好像并没有走最短路径。</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/22999412.jpg" alt="@看起来黄线并没有规划出最短路径"></p>
<p>当某区域网格有多种寻路代价时，寻路网格一般优先使用寻路代价最低的那种。当然也有例外，不可行区域的寻路代价虽然为1，但优先使用该种区域，用于阻挡寻路实体移动**。</p>
<p>官网文档：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AreasAndCosts.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AreasAndCosts.html</a></p>
<p><em>注：图中的寻路路径绘图（黄线）的显示方法是在hierarchy面板点击寻路角色，在Scene场景勾选如上图几项即可。</em></p>
<hr>
<h4 id="自动生成离网链接"><a href="#自动生成离网链接" class="headerlink" title="自动生成离网链接"></a>自动生成离网链接</h4><p>有些时候我们需要自动生成离网格链接。链接的类型有两种：爬梯跳台式和跳跃跨栏式。</p>
<p><strong>跳台式</strong>一般运用于高低平台之间的转换（跳下某平台）<strong>跳跃跨栏式</strong>主要在跳跃过某个缺口。</p>
<p>具体流程：</p>
<ol>
<li><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/34063515.jpg" alt="@勾选Generate Off-Mesh Links属性"> </p>
</li>
<li><p>在Bake面板设置两个参数：</p>
</li>
</ol>
<p>   解释：<br>   <strong>Drop Height：</strong>跳台式链接需要设置下落的高度。高度为0时，无法跳落。<br>   <strong>Jump-Across：</strong>可以跳跃的距离。跳跃的距离为0时，无法眺落。（最小值=寻路实体半径+始终点距离，且最小值要大于代理半径的二倍。）</p>
<ol start="3">
<li>设置完成后点击Bake：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/48909730.jpg" alt="@Bake后的效果，黑色的点代表可跳跃的点"></li>
</ol>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/65051244.jpg" alt="@没有黑圈代表离网链接没有构建成功"></p>
<p><em>注：生成的分离网格链接只能从上往下移动，如果需要从下往上则需要使用手动分离网格链接。</em></p>
<p>官网链接：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-BuildingOffMeshLinksAutomatically.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-BuildingOffMeshLinksAutomatically.html</a></p>
<hr>
<h4 id="离网链接与动画系统"><a href="#离网链接与动画系统" class="headerlink" title="离网链接与动画系统"></a>离网链接与动画系统</h4><p>可以注意到，当演示中的胶囊体/Cube通过离网链接时都是一瞬间完成的，但在实际游戏中，人物的攀爬和跳跃都是有动作的，如果需要在通过离网链接点的时候有人物动作，需要把人物的Auto Traverse Off Mesh Link选项关掉，然后写对应的控制人物状态的脚本，具体可以看：<br><a href="https://blog.csdn.net/elyxiao/article/details/51281602">https://blog.csdn.net/elyxiao/article/details/51281602</a> ，在文章最后作者介绍了如何在通过离网链接点时执行动画。</p>
<hr>
<h4 id="Hight-mesh"><a href="#Hight-mesh" class="headerlink" title="Hight mesh"></a>Hight mesh</h4><p>由于NavMesh是可行走空间的近似值，因此会忽略一些细节。例如，人物在通过楼梯时并不会出现上下颠簸的感觉，如果需要增加NavMesh的真实度，需要将<strong>Navigation-Bake-Advanced settings</strong>下的<strong>Hight mesh</strong>选项打开，当然开启Hight mesh会增加CPU和内存的开销，并且烘焙时间会变长。</p>
<p>原文：</p>
<blockquote>
<p>While navigating, the NavMesh Agent is constrained on the surface of the NavMesh. Since the NavMesh is an approximation of the walkable space, some features are evened out when the NavMesh is being built. For example, stairs may appear as a slope in the NavMesh. If your game requires accurate placement of the agent, you should enable Height Mesh building when you bake the NavMesh. The setting can be found under the Advanced settings in Navigation window. Note that building Height Mesh will take up memory and processing at runtime, and it will take a little longer to bake the NavMesh.</p>
</blockquote>
<p>官方文档：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-HeightMesh.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-HeightMesh.html</a></p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/32907915.jpg" alt="@开启前"></p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/48197356.jpg" alt="@开启后"></p>
<hr>
<h4 id="对障碍物的补充"><a href="#对障碍物的补充" class="headerlink" title="对障碍物的补充"></a>对障碍物的补充</h4><p>1.一个物体不能同时开启NavMeshAget和NavMeshObstacle,但是可以在运行时实时修改其开关。同时开启会产生角色躲避自己的冲突。如果再同时的开启的基础上启用Carve，会出现更多的异常行为。</p>
<hr>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>//</p>
<hr>
<h4 id="high-level-NavMesh-building-components"><a href="#high-level-NavMesh-building-components" class="headerlink" title="high-level NavMesh building components"></a>high-level NavMesh building components</h4><p>//</p>
<p>官方文档：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/NavMesh-BuildingComponents.html">https://docs.unity3d.com/2017.4/Documentation/Manual/NavMesh-BuildingComponents.html</a></p>
<hr>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>下面的几个例子是我作为熟悉导航系统练习写的，想看标准的演示可以点击Windows-Navigation-Bake面板中的蓝色文本下载官方Demo。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/43707615.jpg" alt="@点击蓝色链接可跳转至下载Demo网页"></p>
<p>链接：<a href="https://github.com/Unity-Technologies/NavMeshComponents">https://github.com/Unity-Technologies/NavMeshComponents</a></p>
<h4 id="静态场景："><a href="#静态场景：" class="headerlink" title="静态场景："></a>静态场景：</h4><p><strong>（1）</strong>首先将场景内的障碍物包括地板设置为Static（如图中的四面墙，黄色的cube以及绿色的地板）：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/24937663.jpg" alt="img"></p>
<p>注意NAvigation Static要确定被勾选：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/50847199.jpg" alt="img"></p>
<p><strong>（2）</strong> 打开Navigation面板（window-Navigation），点击Bake：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/./Image 007.png" alt="@|center| 350x0"></p>
<p>点击Bake后场景会显示可通过的区域：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/67341465.jpg" alt="img"></p>
<p><strong>（3）</strong> 在需要寻路的物体(角色)上添加Nav Mesh Agent组件，并添加自定义的物体行走组件，通过调用NavMeshAgent中的SetDestination方法使物体寻路，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_agent.SetDestination(tar);</span><br></pre></td></tr></table></figure>
<p><strong>（4）</strong>效果如下（途中的路径红线显示要自己添加，具体角色的行走和绘图实现方式可以在Demo中找到对应脚本）：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/94816236.jpg" alt="img"></p>
<h4 id="动态场景："><a href="#动态场景：" class="headerlink" title="动态场景："></a>动态场景：</h4><p>NavMesh同时也支持动态规划路线，如果寻路过程中动态出现障碍可以重新规划路线，NavMesh对动态规划支持不好，相比插件的动态寻路，NavMesh差的很多。<br><strong>（1）</strong> 先按照静态场景的流程走一遍，注意活动的障碍物不要标记为Static：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/80234410.jpg" alt="img"></p>
<p><strong>（2）</strong> 在动态运动物体上添加 Nav Mesh Obstacle组件。</p>
<p><strong>（3）</strong>效果如下：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/52457988.jpg" alt="img"></p>
<p>如果发现角色寻路困难，会在动态障碍物前停滞，可以更改Agent Radius的值来修改障碍物的半径，通过调大障碍物的占地面积让角色行走更流畅，或修改代理的自身半径：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/97970624.jpg" alt="img"></p>
<h4 id="离网链接场景："><a href="#离网链接场景：" class="headerlink" title="离网链接场景："></a>离网链接场景：</h4><p>有的时候场景中会出现一些传送点，跳跃点，如果需要在寻路时将传送点也包括在寻路计算内，则需要添加Off-Mesh-Line组件。<br>1.准备两个cube，分别命名为Start和End。作为传送点：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/56354906.jpg" alt="@图中的两个白色的板子"><br>2.在Start的cube上添加Off-Mesh-Line组件，在Start和End属性添加对应的两个Cube（Start和End）：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/19088313.jpg" alt="img"><br>3.若添加成功则传送点上会出现黑色的线：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/61300703.jpg" alt="img"><br>4.可以看到现在代理在寻路时会将跳跃点计算在内：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/68085785.jpg" alt="img"></p>
<h4 id="区域寻路场景"><a href="#区域寻路场景" class="headerlink" title="区域寻路场景"></a>区域寻路场景</h4><p>有时可能会用不到Bake整个场景的地图，只生成局部的NavMesh就够了，比如RPG游戏中玩家在可见区域选路，其他地方被战争迷雾覆盖，无法自动前往。这时需要生成局部的NavMesh并实时刷新。<br>\1. 新建一个空物体，添加Local Nav Mesh Builder，Size为需要实时计算的NavMesh大小，并在Tracked位置填写需要使用局部网格的角色。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/72400628.jpg" alt="img"></p>
<ol>
<li>为场景内的障碍物，地形添加Nav Mesh Source Tag组件。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/42188782.jpg" alt="img"></li>
</ol>
<p>3.像其他场景一样为角色添加代理组件。</p>
<p>4.效果（不需要在Editor时Bake）：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/319203.jpg" alt="img"></p>
<h4 id="有寻路代价的场景"><a href="#有寻路代价的场景" class="headerlink" title="有寻路代价的场景"></a>有寻路代价的场景</h4><p>如果想让干预代理决定两条路该走哪条，比如走沼泽会扣血而草地不会，可以为行走区域添加<strong>代价</strong><br>1.添加路径需要的代价，默认是1，小于1的区域表示代价比标准低，大于1代表比标准代价高。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/66303692.jpg" alt="@添加water,grass,ice三个自定义代价的区域"><br>2.将行走区域修改为对应图层<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/20822682.jpg" alt="@选中的地板设置为Water区域"><br>3.对应区域设置好后，点击Bake，如图。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/44968356.jpg" alt="@三个颜色的区域代表了不同的代价区域"><br>4.现在代理寻路时会考虑代价花费，倾向于花费低的路线。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/83227170.jpg" alt="img"></p>
<hr>
<hr>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/游戏寻路/" rel="tag"># 游戏寻路</a>
          
            <a href="/tags/Untiy插件/" rel="tag"># Untiy插件</a>
          
            <a href="/tags/Unity/" rel="tag"># Unity</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/11/CandCSharpDll/CandCSharpDll/" rel="next" title="Unity下C#调用纯C动态链接库">
                <i class="fa fa-chevron-left"></i> Unity下C#调用纯C动态链接库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/" rel="prev" title="UnityiOSSDK接入">
                UnityiOSSDK接入 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>

 
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/myselelogin.png" alt="Sayi">
            
              <p class="site-author-name" itemprop="name">Sayi</p>
              <div class="site-description motion-element" itemprop="description">Just noob.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/qihr" title="GitHub &rarr; https://github.com/qihr" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:qhr.geek@gmail.com" title="E-Mail &rarr; mailto:qhr.geek@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity的导航系统"><span class="nav-text">Unity的导航系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工作原理"><span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NavMesh的生成"><span class="nav-text">NavMesh的生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NavMesh生成的多边形"><span class="nav-text">NavMesh生成的多边形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NavMesh-Agent如何找到路径"><span class="nav-text">NavMesh Agent如何找到路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#障碍躲避"><span class="nav-text">障碍躲避</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Moving-the-Agent"><span class="nav-text">Moving the Agent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Global-and-Local负责的工作"><span class="nav-text">Global and Local负责的工作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件介绍"><span class="nav-text">组件介绍*</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Nav-Mesh-Agent"><span class="nav-text">1.Nav Mesh Agent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Nav-Mesh-Obstacle"><span class="nav-text">2.Nav Mesh Obstacle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Off-Mesh-Link"><span class="nav-text">3.Off Mesh Link</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Navigation面板（window栏-Navigation）"><span class="nav-text">4.Navigation面板（window栏-Navigation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻路代价"><span class="nav-text">寻路代价*</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动生成离网链接"><span class="nav-text">自动生成离网链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#离网链接与动画系统"><span class="nav-text">离网链接与动画系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hight-mesh"><span class="nav-text">Hight mesh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对障碍物的补充"><span class="nav-text">对障碍物的补充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#效率"><span class="nav-text">效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#high-level-NavMesh-building-components"><span class="nav-text">high-level NavMesh building components</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用"><span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态场景："><span class="nav-text">静态场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态场景："><span class="nav-text">动态场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#离网链接场景："><span class="nav-text">离网链接场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区域寻路场景"><span class="nav-text">区域寻路场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有寻路代价的场景"><span class="nav-text">有寻路代价的场景</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sayi</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">124k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">1:53</span>
  
</div>










  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: '',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  

  

  

  

  

  

  

  

  

</body>
</html>
