<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unity插件：AStarPathfinding寻路系统（中）]]></title>
    <url>%2F2019%2F12%2F11%2FUnity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本为为AStarPathfinding寻路系统介绍中篇，主要讲解演示。 基础寻路网格生成1.1 Grid Graph（1）准备工作：场景中添加Plane，障碍物。为Plane添加一个Layer（我的命名是Ground）。为所有的障碍物添加一个Layer（Obs），注意障碍物要添加Box Collider组件。新建一个空物体，并添加Astar Path组件。 （2）准备完成后，在Astar Path中添加Grid Graph，并设置网格图的长宽以足够覆盖整个Plane。根据障碍物的可攀爬高度设置Max Cilb。将Collison Testing中的Obstacle Layer Mask设置为障碍物所在的图层（Obs）。将Height Tesing中的Mask设置为Plane所在的图层（Ground）。 设置完成后点击Scan，效果如图： （3） 为人物添加寻路功能：首先添加Seeker组件，然后添加AIPah（或者RichAI，适用于NavMesh）最后添加让物体执行寻路的代码： 12345678910111213141516171819c#using UnityEngine;using System.Collections;using Pathfinding;public class AstarAI : MonoBehaviour&#123;public Transform target;public void Start()&#123;//Get a reference to the Seeker component we added earlierSeeker seeker = GetComponent&lt;Seeker&gt;();//Start a new path to the targetPosition, return the result to the OnPathComplete functionseeker.StartPath(transform.position, target.position, OnPathComplete);&#125;public void OnPathComplete(Path p)&#123;Debug.Log(&quot;Yay, we got a path back. Did it have an error? &quot; + p.error);&#125;&#125; 运行后，会显示如图的绿色寻路路径，如果未显示，检查seeker脚本中的Draw Gizmos选项是否勾选。 将Shape属性改为Hexagonal可以将网格更改为六边形： 也可以修改为适用于ISO的寻路网格： 1.2 NavMesh Graph1.3 Point Graph（1）场景内添加添加物体和上面的图也一样，不过过多了一个如图的Way节点，用于当作路点使用。在Way中添加一些Cube充当路点。 （2）在A*组件中添加Point Graph。并将Root属性设置为Way。 （3）点击Scan即可。 1.4 Recast Graph（1）和1.1的Grid做一样的准备工作 （2）在AstarPath组件中添加RecastGraph。 （3）点击Snap Bounds按钮，组件会自动适配场景中的地形。 （4）点击Scan 生成NavMesh （5）寻路脚本的添加和1.1一样，不再介绍。 1.5 Layered Grid GraphLayered 图和Grid图的生成方式一样，但Layered图可以分辨出台阶和地面，如图： Layered图中可以明确的分出台阶和地面 Grid会将台阶下面的区域设定为不可走 一些常用场景1.1 RVO1.7 问题1.Grid和Lay图的图层问题]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity插件：AStarPathfinding寻路系统（下）]]></title>
    <url>%2F2019%2F12%2F11%2FUnity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为AStarPathfinding插件的进阶内容，如果需要简单的使用寻路功能可以看上和中。 AI漫游以及扩展系统暂时没有做介绍，感兴趣的可以去官网看。 Navmesh Cutting（付费功能）官方文档 Navmesh Cutting用于动态添加一个物体时，移除（切割）Navmesh或Recast图中被障碍物阻挡的部分。Navmesh Cutting很适用于动态添加物体/障碍物的场景。（通常情况下Navmesh/Recast只允许更改现有的节点参数，不允许添加新内容或更改节点的位置） 官方文档不知道为什么没有写如何使用Navmesh Cutting是如何使用的，下面给出我使用此功能的流程： 1.首先新建一个具有Recast图并能正确使用的场景。 2.添加一个空物体，命名为Helper，为Helper添加Tile Handler Helper组件。 （Tile Handler Helper组件干嘛用的） 3.添加一个障碍物，并为其添加NavMesh Cut组件，并按下图中所示调整参数： 4.运行游戏，拖动障碍物时NavMesh被遮挡的部分会不可用。 需要注意的是，切割的形状是XZ轴投影到Navmeshi平面的2D图形，不是3D，但2D图形通过拉伸也形成了高度，高度用于判断物体距离平面多高就需要切割的高度： 所以只有物体在navmeshcut组件中设置的图形与NavMesh的接触部分才会被切割，包括高度和半径。 Is dual功能到底干嘛的 在3.x中，navmesh切割只能与重铸图一起使用，但在4.x中，它们可以与重铸和导航网图一起使用。 切割的形状可以自定义，自定义形状时有一些需要注意的细节，具体自行查看官方文档。 Navmesh Cutting会定期检查切割的应用，但也可以通过代码立即更新： 123456789101112131415161718// Schedule pending updates to be done as soon as the pathfinding threads// are done with what they are currently doing.AstarPath.active.navmeshUpdates.ForceUpdate();// Block until the updates have finishedAstarPath.active.FlushGraphUpdates();也可以通过代码控制检查navmeshcut是否变化的时间:// Check every frame (the default)AstarPath.active.navmeshUpdates.updateInterval = 0;// Check every 0.1 secondsAstarPath.active.navmeshUpdates.updateInterval = 0.1f;// Never check for changesAstarPath.active.navmeshUpdates.updateInterval = -1;// You will have to schedule updates manually usingAstarPath.active.navmeshUpdates.ForceUpdate(); （代码都不好使） 也可以通过Update Interval来更改。（这个值的更改位置不对 版本不同？？ ） 因为navmesh切割可以很好地修改navmesh中的三角形，所以在更新图形时不可能保留标签和惩罚。对于在应用更新时保持完全相同的节点，将保留标签和惩罚。 如果您需要使用标记，唯一可靠的方法是保留它们是应用所有图形更新，每次完成导航网格剪切更新时都会设置它们。这当然相对较慢，但它至少会起作用。 RVO（付费）介绍概览到底躲的是谁 需不需要操作 AStarPathfinding使用了基于RVO的局部回避系统（Low level），RVO的性能良好，根据开发者的测试，i7处理器的电脑上可以以50-100FPS模拟五千个具有RVO系统的Agent。关于本章节，以及压力测试请看：https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/localavoidance.html RVO是路径规划中的Low level底层避障算法，用于躲避不可预估的障碍。具体看： RVO基于采样检测和gradient descent算法来找到最佳躲避方案。它非常适合于移动的类人代理。但不太适合不能快速变换速度的物体。 RVO系统分为两个部分，一是完全独立不依赖Unity的核心代码，唯一使用到的Unity类是Math。核心代码控制着所有使用ROV的Agent。 The RVO system is divided into two parts. First there is the core simulation code. It is completely independent of Unity specific objects such as GameObjects and MonoBehaviours. The only really Unity specific classes it uses are math classes which are easily interchangeable. This core handles all simulation of rvo (local avoidance) agents. 第二部分是Unity接口，大多数的类只是对应核心代码的包装类。例如RVOSimulator类只是Pathfinding.RVO.Simulator的包装类，为了更方便的集成使用，接口还包括一些帮助类。如会经常使用到的RVOController，似于Unity的Character Controller的类，支持Move等等功能，也可以更改如速度之类的属性。 The second part is the Unity interface. Many of those classes are just wrappers for the corresponding core classes. The RVOSimulator class is for example just a wrapper class for the Pathfinding.RVO.Simulator class. The Unity interface also contains helper classes for much easier local avoidance integration. One of those is the RVOController which you will probably use quite a lot. It is written to be similar to the Unity Character Controller, supporting functions such as Move and has properties such as velocity which you can easily access. Unity接口部分的所有脚本都假设场景中有且只有一个RVOSimulator，并会找到RVOSimulator获取核心代码部分。RVOSimulator可以被添加到任何游戏物体，通过一些简单的设置就可以正常工作。但注意，不要在场景内添加多个RVOSimulator，接口脚本通过FindObjectOfType 来找到RVOSimulator，FindObjectOfType无法精确控制将返回哪一个RVOSimulator。 All of the scripts in the Unity interface part share common assumptions on how the scene should be set up: There should always be one (1) RVOSimulator in the scene, other scripts will look for it and get the core simulator instance it is a wrapper for. You can simply add it to any GameObject, edit the few settings if you want and it will work. You should never have more than one, all scripts which look for it use FindObjectOfType and there is no easy way to control exactly which of the multiple RVOSimulators it will return, so keep it to one for simplicity’s sake. 集成插件的AI脚本中，AIPath, RichAI支持RVOController，在挂载AIPath或RichAI脚本的物体上添加RVOController即可使用。（下面的Demo中不也是添加即可使用吗） （3.x版本RVO在Rigidbody或CharacterController也被挂载的情况下不能很好地工作。因为RVO系统想要完全控制代理的移动。 在4.x中，可以将它与Rigidbody或CharacterController组件一起使用。需要注意的是，本地回避系统不使用碰撞系统，也不会试图避开碰撞体。） AILerp脚本设计用于沿路径插入并完全跟随它，因此它没有意义偏离路径，因此它不支持本地回避。（AIlerp是怎么工作的） 物理系统在拥挤情况下对Agent使用碰撞（或刚体）组件可能会使RVO的性能急剧下降，因为当拥挤时Agent可能会彼此重叠一部分。虽然Unity的物理系统会防止这种情况发生，但它并没有RVO系统做的好，还会产生错误的运动路线。 Often you want to have colliders on your agents, maybe to be able to hit them with bullets or something. However if you just add colliders (plus a rigidbody) to your agents you may see that the local avoidance quality goes down drastically in crowded scenarios. This is because when it is very crowded agents may overlap a tiny bit, the physics system will prevent that, but it will not do it in as nice a way as the local avoidance system, and this may lead to worse movement. 如果Agent上有碰撞器，作者建议的解决办法是禁用代理之间的物理碰撞，将所有的代理放到一个单独的图层中，在Unity的物理系统设置中将该图层自身的碰撞关闭。 保持代理在图中在局部躲避时，在拥挤的情况下会出现Agent将另一个Agent推出图外的情况。 如果使用RichAI，则会自动处理被推出的情况。因为RichAI的移动需要它。如果使用AIPath，可以通过启用constrainInsideGraph来避免。 还有一种办法是使用RVONavmesh 组件，组件会将图的边界转化为障碍物添加进RVO系统。RVONavmesh计算成本偏高，尤其是在图较大或者运行时更新图的时候，但它允许RVO系统更好地预测障碍，而不是当撞到时才找到墙壁。 如图所示，组件在图的边缘围一堵墙。但这样会增加一些性能开销（尤其是较大的图或者在运行期间更新图。） 使用方法：在场景中的任意物体添加RVONavmesh组件即可，可以通过RVOSimulator组件中的Draw Obstacles显示如图橙色的线。 障碍将障碍添加至本地躲避系统后，代理将不会通过并且会使用本地躲避系统躲开障碍。 在Component-Pathfinding-Localavoidance中可以找到用于添加障碍物的组件，如图： 也可以自己写碰撞器，看下章。 内置的碰撞体可以移动，并且可以适当的更新。但因为可以在周围移动并不代表移动的内置碰撞体可以将代理推开。事实上移动的内置碰撞体并不擅长这样。当碰撞体移动很慢时可以实现推开，但移动很快时会导致代理卡住。 内置的障碍物组件有一个属性很重要，Obstacle Mode，有两个值：Keep out会阻止代理进入障碍物，但如果处于某种原因留在了里面则会很容易出来。Keep in会将代理留在障碍物内部自由移动。 （需要一个例子 gif） 使用RVO组件首先根据官方Demo做一个简单的练习： 1.创建一个新场景，添加一个平面尽量大一点。然后添加一个空物体命名为Simulator，并为其添加RVOSimulator组件。 2.添加一个新的圆柱体，并为其添加RVOController组件，将RVOController组件中的高度参数设置为圆柱体的高度，RVOController的作用和Character Controller差不多。 3.编写一个脚本，让圆柱体动起来： 123456789101112131415161718192021222324252627using UnityEngine;using System.Collections;using Pathfinding.RVO;public class SimpleRVOAI : MonoBehaviour &#123;RVOController controller;// Use this for initializationvoid Awake () &#123;controller = GetComponent&lt;RVOController&gt;();&#125;// Update is called once per framepublic void Update () &#123;// Just some point far awayvar targetPoint = transform.position + transform.forward * 100;// Set the desired point to move towards using a desired speed of 10 and a max speed of 12controller.SetTarget(targetPoint, 10, 12);// Calculate how much to move during this frame// This information is based on movement commands from earlier frames// as local avoidance is calculated globally at regular intervals by the RVOSimulator componentvar delta = controller.CalculateMovementDelta(transform.position, Time.deltaTime);transform.position = transform.position + delta;&#125;&#125; 4.复制几个圆柱体并调整至相对，运行游戏可以看到圆柱体会尝试躲避其他圆柱体。 可以从代码看出来，RVOController本身不处理移动。因为一旦其他脚本也在控制移动，就会引起混乱。（在4.0之前RVOController是处理移动的） RVOSimulator实际上是 Pathfinding.RVO.Simulator的包装类。 rvo面板介绍 添加RVO障碍可以通过代码获取到RVOSimulator： Pathfinding.RVO.Simulator sim = (FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator).GetSimulator (); 通过以下代码可以添加一个障碍物到RVO系统 12345678910111213141516using UnityEngine;using System.Collections;public class SimpleRVOObstacle : MonoBehaviour &#123;void Start () &#123;//Get the simulator for this scenePathfinding.RVO.Simulator sim = (FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator).GetSimulator ();//Define the vertices of our obstacleVector3[] verts = new Vector3[] &#123;new Vector3(1,0,-1), new Vector3(1,0,1), new Vector3 (-1,0,1), new Vector3 (-1,0,-1)&#125;;//Add our obstacle to the simulation, we set the height to 2 unitssim.AddObstacle (verts, 2);&#125;&#125; 需要注意添加向量的方向不同会有不同的结果： System.Array.Reverse (verts); 顺时针是keep in，逆时针使keep out。 也可以把一条线作为障碍物添加至系统：sim.AddObstacle (firstPoint, secondPoint, height); Tag和GraphUpdateSceneGraphUpdateScene是一个功能很强的组件，可以划分自定义区域并更改惩罚值。 Tag是插件的新功能，可以控制每个代理的行走区域。例如场景中有闲逛的动物和人，那他们可以走的区域是不一样的（动物不会走入人住的房子），这时就需要使用Tag来实现。 划分自定义代价值区域的使用方法： 1.在场景中创建一个空物体命名为GUO（不是必须的），添加组件Graph Update Scene。 2.点击GUO，在场景中按住左Shift键，然后点击你想划分区域的地方，会出现一个点，再点击一下会将两个点连接起来。这样就可以创建出一块自定义的区域： 节点的位置信息可以在组件的Points属性里进行修改。 3.根据组件中的Penalty Delta来修改区域的代价值，不同的代价会让Agent在寻路时选择最优的路线，避开代价较大的区域。也可以设置为不可走区域。 4.如图所示，代理会尝试绕过代价高的区域 Tag的使用方法： Tag可以使两个Agent在同样的区域有不同的寻路结果. 0.新建一个场景，场景中像之前的流程一样，保持有地板，寻路目标，Agent，并可以正常寻路。 1.利用Graph Update Scene划分一片区域，并为区域添加一个Tag，命名为Grass（Tag的名称可以在A*组件的面板中修改。） 2.添加两个agent，并附加Seeker脚本。修改Seeker的Tag属性，一个Agent将tag的Traversable取消勾选，另一个保持勾选。 3.运行游戏，两个Agent会规划出不同的路径。 也可以对每个Agent的每个Tag设置不同的惩罚值，可以实现开头说的场景。 NavMesh下有问题 公共惩罚值和个人惩罚值的计算关系 能做的： 自定义区域的惩罚值 自定义区域为不可走 讲某区域更改为a可走b不可走 将某区域更改为a的惩罚值高，b的低 GraphUpdateScene是什么 实时更新图对于实时更新，不同场景有不同的需求，比如可能只更改了一部分，需要更新一部分地图。如果更改了整张地图则需要更新全部。还有可能需要加载/保存地图（具体介绍不在本章）等等。不同的需求需要不同的功能，下面的表列出了开发时会遇到的场景，以及对应的解决策略。 需求 解决办法 重新计算整张图 阅读重新计算整张图 精准的设置哪些节点可走，哪些不可以 阅读直接使用图数据或应用于回合制游戏章节 在某些物体移动或创建销毁时更新图 阅读重计算部分图或DynamicGridObstacle类或Navmesh Cutting章节 修改某单个节点的属性 阅读直接使用图数据或GraphUpdateScene 动态加载或卸载地图 阅读保存和加载地图 创建一小块图在角色周围 阅读ProceduralGridMover类 创建新节点并使用代码连接他们 See PointGraph.AddNode and Writing Graph Generators 使图的一部分成本变高 See Recalculating parts of graphs, Using direct access to graph data and GraphUpdateScene 阻止一些单位穿过某个节点，但是其他节点可以穿过 See Working with tags, Recalculating parts of graphs, GraphUpdateScene and Using direct access to graph data 移动物体的寻路（如一艘船） See the example scene called ‘Moving’ (pro version only). This is not that well documented at the moment. 添加一个障碍物，但首先确定障碍物没有困住或覆盖任何其他单位（TD游戏） See Check for blocking placements 需要更新的内容当需要更新图时，通常会需要做两件事情中的一件。 你可能希望使用与最初生成图时相同的设置重新计算图形，但如果为了更新一部分区域而重新计算了整个图似乎很浪费（AstarPath.Scan），比如，玩家可能只是TD游戏中放置了一座新塔。 或者只想要更改现有图的某些设置。例如，更改某些节点上的tag或代价。 可以对除了NavMesh之外的图重新计算一小部分，navmesh只有完全重新计算才有意义。使用脚本和GraphUpdateScene组件执行此操作，将名为“updatePhysics”的字段设置为true。 Grid 图会正常工作，只需指定边界，它就会为你完成所有操作。但是，考虑到侵蚀等问题，它可能会重新计算一个比指定边界略大的区域。 Recast 图只能全部重新计算。因此，使用较小的tile尺寸可以缩短重新计算的时间。但是如果太小，Recast图会退化为Grid图。如果使用多线程，则会将大部分重新计算放置到单独的线程中，以避免过多地影响FPS。 点图将重新计算通过边界的所有连接。但是，它不会寻找以GameObject形式新添加的新节点，为此你需要使用 AstarPath.Scan. 如想更改节点的属性，有一些东西可供你修改 你可以更改node的tag以实现不同单位行走不同区域，也可以修改节点的惩罚值 可以更改节点上的惩罚。这用于使某些节点比其他节点更难/更慢地遍历，以便代理在其他节点之前更喜欢某些路径。但是有一些限制。您不能指定负惩罚，因为使用的算法无法处理（如果可能，系统会慢得多）。然而，常见的技巧是设置非常大的初始惩罚（可以在图形设置中完成），然后从该高值减少惩罚。但请注意，由于必须搜索更多节点，因此这将使路径寻找更慢。所需的惩罚值非常高。没有真正的“惩罚单位”，但罚款1000大致相当于一个世界旅行单位。 You can change the penalty on the nodes. This is used to make some nodes harder/slower to traverse compared the other nodes so that an agent will prefer some paths before others. There are some limitations though. You cannot specify negative penalties since the algorithms used cannot handle that (and if they could, the system would be a lot slower). However a common trick is to set a very large initial penalty (which can be done in the graph settings) and then decrease the penalty from that high value. Note however that this will make pathfinding slower overall since it has to search more nodes. The penalty values that are required are quite high. There is no real “penalty unit” however a penalty of 1000 corresponds roughly to one world unit of travel. 也可以直接修改节点的可步行性。 因此，您可以使某些边界内的所有节点都可以步行或全部无法行走。 有关如何使用GraphUpdateScene组件的信息。 查看该课程的文档。 GraphUpdateScene组件设置几乎将1到1映射到GraphUpdateObject，在使用脚本更新图形时使用GraphUpdateObject。 因此，即使您只是使用脚本，我也建议您阅读该页面。 重新计算整张图12345678910// Recalculate all graphsAstarPath.active.Scan();// Recalculate only the first grid graphvar graphToScan = AstarPath.active.data.gridGraph;AstarPath.active.Scan(graphToScan);// Recalculate only the first and third graphsvar graphsToScan = new [] &#123; AstarPath.active.data.graphs[0], AstarPath.active.data.graphs[2] &#125;;AstarPath.active.Scan(graphsToScan); 协程加载 但不能保证良好的FPS，但至少可以显示加载屏幕 123456IEnumerator Start () &#123;foreach (Progress progress in AstarPath.active.ScanAsync()) &#123;Debug.Log(&quot;Scanning... &quot; + progress.description + &quot; - &quot; + (progress.progress*100).ToString(&quot;0&quot;) + &quot;%&quot;);yield return null;&#125;&#125; 看一下这俩 AstarPath.Scan AstarPath.ScanAsync 重新计算部分图可以使用GraphUpdateScene组件或使用脚本,调用AstarPath类中的方法完成部分图更新，脚本通过使用Bounds对象或Pathfinding.GraphUpdateObject（就是GraphUpdateScene组件，实际上是在后台就是这么运行的）。 Smaller graph updates can either be done using the GraphUpdateScene component which can be edited in the Unity inspector or using scripting which is done by calling a method in the AstarPath class with either a Bounds object or a Pathfinding.GraphUpdateObject (which is what the GraphUpdateScene component actually does in the background). 1234567891011Bounds bounds = GetComponent&lt;Collider&gt;().bounds;AstarPath.active.UpdateGraphs(bounds);// using Pathfinding; //At top of script// As an example, use the bounding box from the attached colliderBounds bounds = GetComponent&lt;Collider&gt;().bounds;var guo = new GraphUpdateObject(bounds);// Set some settingsguo.updatePhysics = true;AstarPath.active.UpdateGraphs(guo); 然后，该方法将任务放入队列中，以便在下一个路径计算之前执行。它必须放在一个队列中，因为如果它直接执行会干扰寻路，特别是多线程开启的情况下，会导致无法直接看到图形的更新，所以它将始终在下一次寻路计算开始之前更新。 The method will then put the task in a queue to be carried out before the next path calculation. It has to be put in a queue because if it carried out directly, it might interfere with pathfinding, especially if multithreading is on, and cause all kinds of errors. This means that you might not see an update of the graph directly, but it will always be updated before the next pathfinding calculation starts (almost always, see AstarPath.limitGraphUpdates ). Recast图也可以使用navmesh cutting伪更新，navmesh cutting可以使障碍物在Navmesh中切出一个洞，但无法添加更多的Navmesh平面。See Pathfinding.NavmeshCut，比重新计算整张图快的多，但是有更有限。 如果在Unity的Editor中编辑修改已知的图形，那么使用GraphUpdateScene组件是最方便简单的，使用组件你可以轻松更改特定区域的tag而无需任何代码。 但是，如果需要在游戏中动态执行，则使用代码更新图会更方便。 例如，在塔防游戏中新放置的建筑物的更新部分表操作。 使用脚本需要创建GraphUpdateObject并设置所需的参数，然后调用AstarPath.UpdateGraphs方法，将更新任务添加至队列中。 123456789// using Pathfinding; //At top of script// As an example, use the bounding box from the attached colliderBounds bounds = GetComponent&lt;Collider&gt;().bounds;var guo = new GraphUpdateObject(bounds);// Set some settingsguo.updatePhysics = true;AstarPath.active.UpdateGraphs(guo); bounds变量是UnityEngine.Bounds对象，它定义了一个轴对齐的框，用于更新图形，通常你会想围绕着新创建的对象更新图，通常情况下，更新部分图都是围绕新创建的对象的周围进行更新的，所以在示例中，Bounds取自新对象附加的collider 但是要确保该对象可以被图识别，对于Grid图应该确保对象的图层包含在碰撞检测图层（collision testing mask）或者高度检测图层（ height teting mask）中。 如果在使用网格图或者点图时，不需要重新计算所有节点的参数，可以将updatePhysics 设置为 false以避免不必要的计算 （我的理解是如果局部计算的话，需要将这个选项关闭以避免不必要的计算） 1guo.updatePhysics = false; For details about exactly what fields to set, take a look at the class documentation for the GraphUpdateObject . 直接使用图数据有时可能需要直接对图数据进行操作。 Accessing graph data for information about how to access graph data. Node properties and Pathfinding.GraphNode for information about what properties a node has. 下面是一个更改网格图中所有节点并使用perlin噪声来决定节点是否应该可以行走的示例： 123456789101112131415161718AstarPath.active.AddWorkItem(new AstarWorkItem(ctx =&gt; &#123;var gg = AstarPath.active.data.gridGraph;for (int z = 0; z &lt; gg.depth; z++) &#123;for (int x = 0; x &lt; gg.width; x++) &#123;var node = gg.GetNode(x, z);// This example uses perlin noise to generate the mapnode.Walkable = Mathf.PerlinNoise(x * 0.087f, z * 0.087f) &gt; 0.4f;&#125;&#125;// Recalculate all grid connections// This is required because we have updated the walkability of some nodesgg.GetNodes(node =&gt; gg.CalculateConnections((GridNodeBase)node));// Update the &apos;area&apos; information in the graph.// This is required because we have updated the connectivity of the graphctx.QueueFloodFill();&#125;)); 经过修改后的图： 只有在安全的情况下才能修改图表数据。路径查找可能随时在运行，因此必须先暂停路径寻找线程，然后更新数据。最简单的方法是使用AstarPath.AddWorkItem： 12345AstarPath.active.AddWorkItem(() =&gt; &#123;// Safe to update graphs herevar node = AstarPath.active.GetNearest(transform.position).node;node.position = (Int3)transform.position;&#125;); 更改图数据后要及时更新图。如果更改了任何节点的Walkable或连接，则需要更新Area的信息，系统通过Area来确定哪些节点可以到达哪些其他节点，而这些节点又用于快速确定路径是否可行。 12345AstarPath.active.AddWorkItem(new AstarWorkItem(ctx =&gt; &#123;var node = AstarPath.active.GetNearest(transform.position).node;node.Walkable = false;ctx.QueueFloodFill();&#125;)); QueueFloodFill()是根据性能进行批处理的，因此在连续更新的多个图更新时不需要多次调用QueueFloodFill()。如果需要Area的信息是最新的，则应该调用ctx.EnsureValidFloodFill方法。但是通常开发中不会用到。 The flood fill calls are batched for performance so that multiple graph updates which are executed directly after each other do not have to run the flood fill more than once. If your work item requires that the area information is up to date you should call the ctx.EnsureValidFloodFill method first. Usually this is not something that work items require however. 如果修改了walkability，需要重新计算节点之间的链接。对于Grid图来说非常重要，可以使用GridGraph.CalculateConnections方法。注意，这需要在你更改了walkability的节点以及与其相邻的节点上调用，因为他们可能必须更改其连接以添加或删除该节点作为连接。 AddWorkItem方法也可以以更高级的方式使用。例如，它允许您在必要时将计算分布在多个帧上： 1234567891011121314151617AstarPath.active.AddWorkItem(new AstarWorkItem( () =&gt; &#123; // Called once, right before the // first call to the method below&#125;, force =&gt; &#123; // Called every frame until complete. // Signal that the work item is // complete by returning true. // The &quot;force&quot; parameter will // be true if the work item is // required to complete immediately. // In that case this method should // block and return true when done. return true;&#125; )); debug记得写一下 工作原理当使用GraphUpdateObject进行实时更新时， 所有可以更新的内置的图都会循环调用自身的UpdateArea 方法。 图将每一个需要被更新或受影响的节点发送给Pathfinding.GraphUpdateObject.Apply ， Apply方法会更改惩罚值，walkablity或者其他指定的参数，图也可以使用特定的更新逻辑，如GridGraph(see GridGraph specific details)。你不需要明白这些更新方法的不同，这些方法的具体细节的了解适合想使用源码的人。 When updating is carried out using a GraphUpdateObject, all graphs will be looped over and those which can be updated (all built in ones) will have their UpdateArea function called (i.e be updated).Each node is updated by the graphs calling Pathfinding.GraphUpdateObject.Apply sending each affected node to it, the Apply function will then change penalty, walkability or other parameters specified. Graphs can also use custom updating logic, such as the GridGraph (see GridGraph specific details). You do not have to understand all different function calls to be able to use it, those are mostly for people who want to mess around with the source code. Gird图的特殊细节updatePhysics是更新Gird图时非常重要的属性，如果设置为true，所有被影响的节点都会重新计算他们的高度，然后检查自身是否可走。当更新Grid图时，最好保持为true。 当更新Grid图时，GraphUpdateObject的Apply方法会被更新范围内的所有节点调用，节点会检查updatePhysics变量，如果updatePhysics设置为true（默认值是true），则更新区域会根据Collision Testing设置的直径扩张，并且在其中的每个节点都会做碰撞检测，如果是false，则只有更新区域内的节点会调用Apply方法，并不会做其他事情。 The updatePhysics variable matters a lot when updating grid graphs. If it is set to true, all nodes affected will have their height recalculated and then checked if they are still walkable. You usually want to leave this to true when updating a grid graph. When updating a GridGraph, the GraphUpdateObject’s Apply function (which changed walkability, tags and penalties) will be called for each node inside the bounds, it will check the updatePhysics variable, if it is true (which is the default value), the area will be expanded by the diameter of the specified in the Collision Testing settings and every node inside the area will be checked for collisions. If it is false, however, only the Apply function will be called for the nodes inside the area (not expanded) and nothing else will be done. 基于Navmesh的图基于navmesh的图（Navmesh和RecastGraph）只支持更新已存在的节点的惩罚，walkablity等以更新整个图，GraphUpdateObjects 不能添加新的节点（更新整个图除外），GraphUpdateObject 会更新所有交叉接触的节点/多边形，或者在GUO范围内的所有节点。对于recast也可以通过Nacmesh cut快速更新图。 Navmesh based graphs (NavMeshGraph and RecastGraph) only have support for updating penalty, walkability and similar on already existing nodes or for recast graphs, to completely recalculate whole tiles. New nodes cannot be created using GraphUpdateObjects (unless recalculating whole tiles). The GraphUpdateObject will affect all nodes/triangles which intersect or are contained by the GUO’s bounds.For recast graphs you can also use navmesh cutting to update the graph in a fast way. 点图（PointGraphs）点图的更新会调用边界内的所有节点的Apply方法，GraphUpdateObject.updatePhysics如果设置为true，它还会重新计算经过更新区域的所有链接点。 Graph Update ObjectThe GraphUpdateObject contains some basic variables on how to update each node. See documentation for the Pathfinding.GraphUpdateObject for more info. 从GraphUpdateObject继承GraphUpdateObject可以被继承，覆写某些方法。下面是一个例子，执行父类Apply方法的同时移动节点： 123456789101112using UnityEngine;using Pathfinding;public class MyGUO : GraphUpdateObject &#123;public Vector3 offset = Vector3.up;public override void Apply (GraphNode node) &#123;// Keep the base functionalitybase.Apply(node);// The position of a node is an Int3, so we need to cast the offsetnode.position += (Int3)offset;&#125;&#125; 也可以这样： 1234567public void Start () &#123; MyGUO guo = new MyGUO(); guo.offset = Vector3.up*2; guo.bounds = new Bounds(Vector3.zero, Vector3.one*10); AstarPath.active.UpdateGraphs(guo);&#125; 检查是否阻塞（塔防）在塔防游戏中很重要的一点是，玩家放置的塔没有使出兵点和目标点直接堵塞，插件为此提供了对应的API。 Pathfinding.GraphUpdateUtilities.UpdateGraphsNoBlock方法会检查给定的graph update object是否会引起两个或更多的点引起堵塞，然而该方法会比常规更新图速度要慢，所以你可能不会经常使用它。 举个例子，当玩家再塔防游戏中放置一个防御塔的时候，你可以初始化防御塔，然后调用UpdateGraphsNoBlock方法检查新添加的防御塔是否会阻挡路径，如果是则立即移除防御塔并提示玩家选择的位置不符合规则。你也可以传递节点列表给UpdateGraphsNoBlock方法，这样不仅可以确定初始点和目标点之间没有堵塞，并且在单位行走时可以放置防御塔的情况下，所有单位都能到达目标。 The Pathfinding.GraphUpdateUtilities.UpdateGraphsNoBlock method can be used to first check if a given graph update object will cause the path between two or more points to become blocked. This is however slower than a normal graph update so you probably don’t want to use it too often. For example when a player in a tower defence game places a tower, you could instantiate it, then call the UpdateGraphsNoBlock method to check if the newly placed tower will block the path. If it did then remove the tower immediately and notify the player that the choosen position was not valid. You can pass a list of nodes to the UpdateGraphsNoBlock method so you could for example make sure that not only is the path from the start to the goal not blocked, but also that all units can still reach the goal (if it is possible to place towers when enemies are walking around). 12345678910111213var guo = new GraphUpdateObject(tower.GetComponent&lt;Collider&gt;().bounds);var spawnPointNode = AstarPath.active.GetNearest(spawnPoint.position).node;var goalNode = AstarPath.active.GetNearest(goalPoint.position).node;if (GraphUpdateUtilities.UpdateGraphsNoBlock(guo, spawnPointNode, goalNode, false)) &#123; // Valid tower position // Since the last parameter (which is called &quot;alwaysRevert&quot;) in the method call was false // The graph is now updated and the game can just continue&#125; else &#123; // Invalid tower position. It blocks the path between the spawn point and the goal // The effect on the graph has been reverted Destroy(tower);&#125; 保存和加载图表 图的设置通过Unity的序列化来保存，但图没有通过序列化保存和加载，而是被保存至一个字节数组中，通过数组完成了保存和加载。 可以A* inspector面板中可以看到Save&amp;Load选项。 [需要一张图片] 图的计算缓存通常你希望游戏启动时重新计算图，但有的时候，尤其是使用RecastGraph或者在移动设备上开发，游戏开始时的延迟会非常烦。 打开Save&amp;Load面板，点击Generate Cache来创建缓存。它将会询问你是否保存之前重新扫描图。现在游戏启动时会加载缓存读取图的节点信息和其他参数，不需要另外的计算时间。 [需要一张图片] 将图保存至文件并读取您可能还希望将图表保存到稍后可以加载的文件中。您甚至可以在运行时从服务器加载它。 如果想保存你的图，点击Save to file 按钮，你可以只保存配置参数或者保存配置参数和节点数据。如果只保存设置配置参数，则在图被加载后，你需要重新计算他在任何角色使用图进行导航之前。你可以使用以下代码重新计算所有的图： 1AstarPath.active.Scan(); 如果要再次加载图形，只需按“从文件加载”按钮并找到该文件。请注意，这将替换您当前的图表。 问题：只保存设置，还如何加载图形？？保存的设置是什么？？？ 使用代码进行保存和加载如果需要实时加载或保存图，则需要在代码里进行操作。 SerializeGraphs()方法会将图的参数序列化为数组，默认情况下包含节点信息（假设序列化之前保存过图形）。 1byte[] bytes = AstarPath.active.data.SerializeGraphs(); 可以近一步配置 12345var settings = new Pathfinding.Serialization.SerializeSettings();// Only save settingssettings.nodes = false;byte[] bytes = AstarPath.active.data.SerializeGraphs(settings); 加载保存的数据： 1AstarPath.active.data.DeserializeGraphs(bytes); 如果只加载了设置，你可能需要调用Scan方法在加载设置后： 12AstarPath.active.data.DeserializeGraphs(bytes);AstarPath.active.Scan(); 如果不是替换当前图，可以使用附加的方式加载图： Instead of replacing the currently loaded graphs, you can additively load graphs using 1AstarPath.active.data.DeserializeGraphsAdditive(bytes); 使用以下方法卸载图： 123var data = AstarPath.active.data;var myGraph = data.gridGraph;data.RemoveGraph(myGraph); Including Data in a TextAsset图表数据可以被包含在TextAsset中，当你将数据保存为文件，把文件重命名为入“myGraph.bytes”，然后将它放入你的Unity工程中，这样会告诉Unity将文件视作二进制文件。如果使用.txt的后缀会使出现问题，因为Unity会尝试用text读取文件。一些操作系统会隐藏扩展名，所以如果Unity无法识别.bytes请检查文件后缀是否真的是bytes。zip（或者其他）后缀名可能会被隐藏。然后，您可以通过在变量访问.bytes字段来加载text asse的图形，访问.bytes文件。 1Graph data can be included in textassets for easier inclusion in the build. When you have saved the data to a file, rename that file to something like &quot;myGraph.bytes&quot; and place it in your Unity Project. This will tell Unity to handle it as binary information. With an extension like .txt the data would get corrupted because Unity would try to read it as text. Some operating systems like to hide the extension, so if Unity doesn&apos;t seem to recognize the file with the .bytes extension make sure it really has a .bytes extension, the .zip (or other) extension might just be hidden. Then you can load the graph from a text asset by referencing it in a variable, and accessing the .bytes field. 数据类型所有的参数设置都会被序列化为JSON，可以很好的保持向前或向后兼容。下面提到的所有文件都会被压缩进单独的zip文件，缩小尺寸，使数据更容易处理。这也意味着你可以打开zip文件进行手动处理。 【需要一章图片】 meta meta.json文件会在所有的序列化中出现，A meta.json file is present in all serializations. This file contains information which is not connected to a specific graph, or is needed to load the other graphs. Version number for the system Number of graphs which are saved GUID values for each graph, to identify them Type of each graph 例如： 123456789101112131415&#123; &quot;version&quot;: &quot;3.0.9.5&quot;, &quot;graphs&quot;: 1, &quot;guids&quot;: [ &quot;0d83c93fc4928934-8362a8662ec4fb9d&quot; ], &quot;typeNames&quot;: [ &quot;Pathfinding.GridGraph&quot; ]&#125; Graph Settings每个图的配置参数会被保存为”graph#.json”，#代表图的编号。下面是一个grid图的参数序列化的例子（删除了一些参数以保持代码不会很长）： 12345678910111213141516171819202122232425262728293031323334&#123; &quot;aspectRatio&quot;:1, &quot;rotation&quot;:&#123; &quot;x&quot;:0, &quot;y&quot;:0, &quot;z&quot;:0 &#125;, &quot;center&quot;:&#123; &quot;x&quot;:0, &quot;y&quot;:-0.1, &quot;z&quot;:0 &#125;, &quot;unclampedSize&quot;:&#123; &quot;x&quot;:100, &quot;y&quot;:100 &#125;, &quot;nodeSize&quot;:1, &quot;maxClimb&quot;:0.4, &quot;maxClimbAxis&quot;:1, &quot;maxSlope&quot;:90, &quot;erodeIterations&quot;:0, &quot;autoLinkGrids&quot;:false, &quot;autoLinkDistLimit&quot;:10, &quot;neighbours&quot;:&quot;Eight&quot;, &quot;cutCorners&quot;:true, &quot;penaltyPositionOffset&quot;:0, &quot;penaltyPosition&quot;:false, &quot;penaltyPositionFactor&quot;:1, &quot;penaltyAngle&quot;:false, &quot;penaltyAngleFactor&quot;:100, &quot;open&quot;:true, &quot;infoScreenOpen&quot;:false ...&#125; 节点信息使用json来保存会占用很多空间，所以被替代为使用二进制文件写入。每个图类型都有自己的序列化保存节点代码。这由每个图上的SerializeExtraInfo和DeserializeExtraInfo方法处理。 多种Agent类型 不同尺寸的Agent通常有不同的寻路结果，最简单的方法是创建多个图，每一个图对应一种Agent。如果拥有很多代理，您可能希望将它们分组为具有大量图形将增加内存使用量并且扫描将花费更长时间。 编辑器寻路GraphUpdateScene 组件Accessing graph data应用于回合制游戏优化]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity插件：AStarPathfinding寻路系统（上）]]></title>
    <url>%2F2019%2F12%2F11%2FUnity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为AStarPathfinding插件的进阶内容，如果需要简单的使用寻路功能可以看上和中。 AI漫游以及扩展系统暂时没有做介绍，感兴趣的可以去官网看。 本篇为AStarPathfinding寻路系统的上部分，主要介绍插件的组件以及工作原理，和一个简单的Demo。 前言除阅读热身章节外，需要了解寻路的基础知识才能阅读以下内容： 游戏寻路基本原理 寻路常用的几种图介绍 Unity的寻路系统 如果只是想了解该插件的基础功能，可以直接跳至热身章节阅读。 以下的讲解内容，一部分是翻译自文档，翻译的部分会给出原文参考。英语好的同学可以直接看官方文档，文档包括寻路常用的几种图的介绍和优劣对比，以及一套寻路系统的工作原理是怎样的，写的非常详细，官网地址 此外官方还有一个入门的视频，需要梯子看。 介绍APathfinding是比较主流的Unity寻路插件，分付费（100刀）和免费版。支持五种图：Grid Graph，Navmesh Graph，Point Graph，Recast Graph（付费），Layered Grid Graph（付费）。同时支持自动生成Navmesh（付费），自带RVO避障系统（付费）。目前Unity寻路插件用的比较多的就是该插件，功能齐全，可调节估价公式等等等，总之是一款非常强大的插件。 准备，简单的Demo下面的Demo是一个简单的寻路，将准备好的插件包导入新建项目中然后完成下面的操作： （1）准备工作：场景中添加Plane（一块地板），障碍物。为Plane添加一个Layer（我的命名是Ground）。添加几个障碍物，为所有的障碍物添加Layer（Obs），注意障碍物要添加Box Collider组件*。新建一个空物体，并为空物体添加Astar Path组件。添加一个游戏人物命名为hero，一个球体命名为target用于表示hero要去的目标。场景内现在应该有：地板，障碍物，游戏人物，以及target，挂载了Astar Path的空物体。 （2）生成导航网格：准备完成后，在Astar Path中添加Grid Graph，并设置网格图的长宽以足够覆盖整个Plane。将Collison Testing中的Obstacle Layer Mask设置为障碍物所在的图层（Obs）。将Height Tesing中的Mask设置为Plane所在的图层（Ground）。 设置完成后点击Scan，效果如图： (3)让hero可以寻路：添加Seeker，Character Controler组件。新建一个名为MineAstarAI的脚本，并填入以下代码： 1234567891011121314151617181920212223using Pathfinding;public void Start () &#123;// Get the seeker component attached to this GameObjectvar seeker = GetComponent&lt;Seeker&gt;();// Start a new path request from the current position to a position 10 units forward.// When the path has been calculated, it will be returned to the function OnPathComplete unless it was canceled by another path requestseeker.StartPath (transform.position, transform.position+transform.forward*10, OnPathComplete);// Note that the path is NOT calculated at this stage// It has just been queued for calculation&#125;public void OnPathComplete (Path p) &#123;// We got our path backif (p.error) &#123;// Nooo, a valid path couldn&apos;t be found&#125; else &#123;// Yay, now we can get a Vector3 representation of the path// from p.vectorPath&#125;&#125; 然后在Target Position拖入Target。 （4）运行，Scene窗口会显示寻路的路径： 若没显示路径（绿线），检查seeker脚本中的Draw Gizmos选项是否勾选。 组件介绍概览 主要组件有这几种，它们负责运作整套寻路系统。 Astarpath.cs：插件的核心脚本，是寻路系统的核心，所有对寻路的调整都要修改该组件才能完成。 Seeker.cs：：负责寻路调用，但不是必须。 AIPath，RichAI，AILerp：AI移动脚本，可以用这三个完成寻路移动或自己写一个。 修饰脚本 SimpleSmoothModifier等等：对已生成的路径进行修饰，平滑，简化路径。 1.Astarpath组件Astarpath组件添加在object上以后会显示如下面板： 组件面板 Scan 按钮用于扫描更新图，在游戏启动时完成（除非缓存启动，更多关于另一部分的启动），并且一些图在有改动时会自动执行扫描，不会导致任何延迟。 The Scan button is for updating the graphs, this is also done on startup (unless the startup is cached, more about that in another part) and some graphs will do it automatically when changing the graph settings and the scanning won’t cause any lag. 比较重要的是Graphs，Settings。About是官网导航，版本检查问题反馈等等，就不做介绍了，重点介绍一下Graphs和Settings，Save和Optimization。 Settings面板 属性 功能 Thread Count[1] 寻路使用的线程数，None表示协程运行，Automatic自动根据配置调整线程。此功能为付费功能（WebGL 上无法使用此功能） Max Nearest Node Distance 可搜索的临近点最大距离，如果请求不可到达点的路径，则会返回该点在该值范围内的最近节点。 Heuristic[2] 使用哪种估价公式 Heuristic Scale[3] 启发式规模 Advanced Heuristic Optimization[4] 启发式优化（不知道怎么用） Batch Graph Updates[5] 批处理更新图 Prioritize Graphs[5] 图的优先级 Full Get Nearest Node Search[6] 对所有图执行完整GetNearest搜索 Scan on Awake 在执行Awake时生成图 Path Logging Log产生的消息数量（None/Normal/Heavy/InGame（和Heavy一样多，但在游戏中使用UI输出log）/OnlyErrors） Graph Coloring 根据不同的属性对图进行可视化（G/H/F/Penalty/Areas） Show Search Tree 如果勾选将会将节点的父节点可视化。（此功能目前还不完整） Show Unwalkable Nodes 显示不可走的节点 Smooth Transitions[7] 在打开和关闭时动画下拉菜单 [1]Thread Count：推荐使用Automatic，因为不同用户间配置的不同，会导致性能的浪费或导致游戏无法以正常帧数运行。Automatic会检查当前机器的配置来确定线程数，稳定运行。另外需要的注意，如果场景中只有一个（或很少）需要寻路的角色（代理），应该只使用一个线程。因为多线程计算路径适用于计算不同路径以提升吞吐量，但是多线程并不会使单个路径的计算速度变快。 [2]不同的估价公式： 估价公式的作用请看寻路原理文档以及网上查阅资料。 [3]Heuristic Scale：如果使用小于1的值，则寻路处理时会搜索更多节点（更慢）。 如果使用0，则路径查找算法将简化为dijkstra算法。 相当于将Heuristic选项设置为None。 如果使用大于1的值，则路径查找通常会更快，但因为搜索了更少的节点，所以路径可能不再是最佳路径（即最短路径）。 [4]Heuristic Optimization： [5]Batch Graph Updates：图形更新将批处理并执行较少（由graphUpdateBatchingInterval指定更新）。 [6]Prioritize Graphs：图表将根据他们在检查员中的顺序进行优先排序。 将选择具有比优先级图限制更近的节点的第一个图，而不是搜索所有图。 [7]Smooth Transitions： SaveAndLoad面板 此面板用于读取和保存图的信息。通过读取缓存数据避免在游戏中进行大量的图生成计算。 Optimization面板 禁用或使用面板中的某些功能来提升性能。 2.图点击Graphs后会提示选择其中一种图来进行下一步的操作，这里拿Grid来做讲解，这几种图是干吗的在前言的文章有介绍。 组件面板 点击i按钮进行编辑 下面是这五种图的属性介绍。 [su_accordion][su_spoiler title=”Grid和Layered Grid Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””] Grid和Layered Grid差别不大，合在一起说 Layered Grid是插件的付费功能，和Grid图的区别是它支持重叠区域的网格图。它在某些方面有点受限，它只支持4个邻居而不是8，并且比网格图使用更多的内存。但是当你需要一个重叠区域的网格图时它很有用。 属性 功能 Shape[1] 生成图的形状 2D 勾选后将适用于2D Width 调整生成的图宽度 Depth 调整生成的图长度 Node size 节点大小 Center 确定中心点 Rotation 图的角度 —————————— Connections 存储的邻接点数量4/8 Cut Corners[2] 是否剪切边角 Max Climb 最大攀爬高度 Max Slope 最大攀爬角度 Erosion iterations[3] 侵蚀范围 —————————— Use 2D physics 使用2D物理系统检测碰撞 Colloder type 碰撞体类型 Dimaeter Height/Length Offset Obstacle Layer Mask 障碍物所在图层 —————————— Ray length[4] 检测射线高度 Mask 地板所在图层 Thick Raycast[5] Advanced Unwalkable when no ground Use Jump point Search[6] 使用跳跃点搜索 [1]Shape:Grid Graph有很多种，如网格图等等 [2]Cut Corners: [3]Erosion iterations： 通过调整Erosion iterations实现侵蚀的效果，根据值的不同侵蚀的程度也不同： 分别为值是0，1，2时的效果 过多的侵蚀迭代次数会降低运行时（Graph UpdateObject）中的图形更新速度。 [4]Ray length： [5]Thick Raycast： [6]Use Jump point Search： [/su_spoiler] [/su_accordion] [su_accordion][su_spoiler title=”Navmesh Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””] 属性 功能 Source Mesh 生成的navmesh资源 Offset 偏移量 Rotation 旋转角度 Scale 缩放 Nearest Node queries in XZ space[1] 仅在XZ空间中执行最近的节点搜索。 Recalulate Normals[2] 确定如何计算法线 Initial Penalty[3] 节点默认代价 [1]Nearest Node queries in XZ space [2]Recalulate Normals [3]Initial Penalty [/su_spoiler] [/su_accordion] [su_accordion][su_spoiler title=”Point Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””] 属性 功能 Root 指定的根节点 Recursive 是否遍历根节点下的全部节点 Tag 指定路点的Tag Max Distance 两路点最大距离，0无限大 Max Distance()[1] 两路点最大距离，分轴计算 Raycast 使用raycast来检查连接 Use 2D Physics 使用2D物理系统 Thick Raycast Mask 用于射线检测的图层 Optimize For Sparse Graph[2] 优化稀疏图 Initial Penty 默认惩罚值 [1]Max Distance()：与Max Distance不同，该属性可以分不同的方向来控制最大距离。 [2]Optimize For Sparse Graph： [/su_spoiler] [/su_accordion] [su_accordion][su_spoiler title=”Recast Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””] 属性 功能 Cell Size 多边形大小 Use Tiles 是否使用Tiles Tile Size Tile大小 Min Region Size 最小区域大小 Walkable Height 可行走高度 Walkable Climb 可攀爬高度 Character Radius 角色半径 Max Slope 最大攀爬角度 Max Border Edge Lenght[1] 最大细分边缘长度 Max Edge Error Rasterize Terrain Rasteruze Tress Collider Deta Terrain Sample Rasterize meshes Rasterize Collider Center 中心点位置 Size 尺寸大小 Rotation 角度 LayerMask TagMask Relevant Graph s Nearest node Initial Penalty [/su_spoiler] [/su_accordion] 3.Seeker组件Seeker附加在请求寻路的GameObject上，通过调用Seeker.StartPath（）来请求寻路。同时Seeker还可以使用Modifiers组件使路径变得更加圆滑，简单。（需要注意的是Seeker会自动调用Modifiers） 使用方法： 12345678910111213public void Start () &#123;// Get a reference to the Seeker component we added earlierSeeker seeker = GetComponent&lt;Seeker&gt;();// Start to calculate a new path to the targetPosition object, return the result to the OnPathComplete method.// Path requests are asynchronous, so when the OnPathComplete method is called depends on how long it// takes to calculate the path. Usually it is called the next frame.seeker.StartPath(transform.position, targetPosition.position, OnPathComplete);&#125;public void OnPathComplete (Path p) &#123;Debug.Log(&quot;Yay, we got a path back. Did it have an error? &quot; + p.error);&#125; 可以不填写回调参数： 12345// Set the path callback, this should be done onceseeker.pathCallback += OnPathComplete;// Now we can skip the callback function parameterseeker.StartPath (transform.position, transform.position+transform.forward*10); 注意第三个参数是委托，记得销毁时候： 123public void OnDisable () &#123;seeker.pathCallback -= OnPathComplete;&#125; Seeker组件旨在处理游戏中单个角色的寻路请求。所以，它一次只处理一个路径请求，如果正在计算路径时再次调用StartPath，它会记录一条日志，指出先前的路径计算已中止。 注意Seeker一次只能进行一次寻路调用，如果在前一个路径完成之前请求新路径，则前一个路径请求将被取消。并且StartPath调用之后并不会立即计算路径。StartPath调用仅目标点放入队列中。这样做是因为当许多单位同时请求计算路径时，可以在几帧上展开寻路计算以避免FPS下降。如果已启用多线程，还可以在其他线程计算路径。如果需要立即计算路径。可以使用Pathfinding.Path.BlockUntilCalculated方法。 原文： A common mistake is to assume that the path is already calculated right after the StartPath call. This is however incorrect. The StartPath call will only put the path in a queue. This is done because when many units are calculating their paths at the same time, it is desriable to spread out the path calculations over several frames to avoid FPS drops. We can also calculate the paths in other threads if multithreading has been enabled. There are of course cases where you need to calculate the path immediately. Then you can use the Pathfinding.Path.BlockUntilCalculatedmethod. Seeker并不是必须要挂载的，但是用它寻路会更简单。 属性 功能 Draw Gizmos 显示寻路路线 Detailed Gizmos 显示被简化，平滑前的路径 Start End Modifier[1] 用于调整路径的起点和终点位置。 Start Point Snapping 起点的位置 End Point Snapping 终点的位置 Add Points 添加 Traversable Graphs [1]Start End Modifier: 4.AIPath，RichAI，AILerp组件插件提供了三个用于寻路移动脚本AIPath，RichAI，AILerp，这三个插件是可选的，可以不使用这些插件，用自己写的完成路径查找、移动功能。但这三个脚本功能齐全，拿来直接用也是没有问题的。要注意的是它们适用的场景各不相同，下面是官方的简介。 AIPath： 适用于所有图的全能移动脚本。 可以响应物理系统，并可以生成圆滑的路径。 支持本地躲避系统。 支持3D，2D。 RichAI： 专为navmesh / recast图设计，不适用于任何其他图类型。 在navmesh下寻路能力比AIPath好，更好的处理路径，并且路径更加圆滑。 更好的支持off-mesh，与AIPath相比。 支持本地躲避系统。 支持3D（XZ平面中的移动），但不支持2D。 注意RichAi不支持大部分的modifiers，除 funnel modifier外。 The RichAI script is specially written for movement on navmesh graphs. It enforces that the agent stays on the navmesh at all times. As opposed to other movement scripts in this project, it does not have support for path modifiers. This is because it does not follow a list of waypoints, instead it follows a list of nodes. This has the advantage that the character can be pushed around by some amount and it will still move correctly without a path recalculation. （richiai不按照路点查询，在哪写了其他脚本按照路点查询） 这样的好处是什么关于RichAi的设置那段没看懂 AILerp： 线性插值的沿路径移动，不支持物理系统。 完全遵循路径，无任何偏差。 由于以上两点，AILerp完全不支持本地躲避系统。 到目前为止最快的移动脚本，因为移动本身更简单。如果在游戏中需要物理模拟，应当使用其他脚本。 支持3D，2D游戏中的移动。 [su_accordion][su_spoiler title=”原文” open=”no” style=”default” icon=”plus” anchor=”” class=””] AIPath Good all-around movement script which works on all graph types. Follows paths smoothly and responds to physics. Works well with local avoidance. Supports movement in 3D games as well as 2D games. RichAI Designed specifically for navmesh/recast graphs and does not work with any other graph types. Better than the AIPath script at following paths on navmesh based graphs, it can handle getting pushed of its path better and usually follows the path more smoothly. Has better support for off-mesh compared to AIPath. Works well with local avoidance. Supports movement in 3D games (movement in the XZ plane), but not 2D. AILerp Uses linear interpolation to move along the path (which is why ‘lerp’, which stands for linear interpolation, is in the name), does not use physics in any way. Follows the path exactly, without any deviations whatsoever. Due to the above points it does not make sense to use it with local avoidance, and thus it does not support it. By far the fastest of the movement scripts, because the movement in itself is much simpler, but keep in mind that if you need any kind of physical realism in the game, you should usually use one of the other movement scripts. Supports movement in 3D games as well as 2D games. [/su_spoiler] [/su_accordion] 总之，如果使用的是navmesh：使用RichAI脚本，否则使用AIPath或AILerp，具体取决于游戏所需的移动方式，具体在游戏中的表现看下面的演示章节。 脚本中会用到的一些属性： destination：需要移动到的目标点。 reachedDestination：如果已到达目标的，则值为ture Velocity：代理的速度 desiredVelocity：代理期望的移动速度*。 原文： destination: Position in the world that this agent should move to. reachedDestination: True if the ai has reached the #destination. velocity: Actual velocity that the agent is moving with. desiredVelocity: Velocity that this agent wants to move with. 5.Modifiers组件Modifiers是一些小组件，如SimpleSmoothModifier，RaycastModifier，FunnelModifier，和Seeker挂在同一个GameObject上。在Seeker返回路径给调用者之前，对路径自动（需手动修改或调用）进行圆滑或简化处理。 例如，下图中，Raycast Modifier删除了路径中不必要的节点，使路径更短。SimpleSmoothModifier使路径更圆滑，看起来更自然。 下面是几种最常见的Modifier的比较： 关于这些Modifier的具体功能，看下面章节。 需要注意，Modifiers通常不考虑世界几何图形或图形，因此小心使用太多平滑，可能会导致路径穿过不可行走的区域。圆滑路径一定要注意将参数调大，不然会卡死，如图： 只有Seeker可以调用Modifieer吗 使用使用Modifiers组件Modifiers组件一共有以下几种： SimpleSmoothModifier RaycastModifier FunnelModifier RadiusModifier StartEndModifier AlternativePath 重点介绍一下SimpleSmoothModifier，FunnelModifier，Raycast Modifier。 SimpleSmoothModifierSimpleSmooth的功能是平滑路径，可以通过细分路径并使定点靠近彼此来实现平滑（Simple模式），也可以使用贝塞尔曲线（Bezier 模式）来实现。下图是开启SimpleSmooth前后的对比。注意，因为在平滑时不考虑几何世界，所以平滑路径会稍微削减拐点。 The simple smooth modifier is a modifier to smooth the path. It can do that either by just subdividing it and moving the vertices closer to each other or use splines, namely the Bezier curve.Below are two images showing a path with the smooth modifier turned off first and then on. Note that the smoothed path cuts the corners a bit, this can be a problem with the smooth modifier since it does not take world geometry into account when smoothing. SimpleSmooth的类型有如下几种： 1.SimpleSmooth通过细分路径，使顶点互相靠近实现平滑。 Uniform Length 是否将所有线划分为相等长度的线段。 Max Segment Length 分割线段最大长度 Iterations 平滑处理迭代次数 Strength 每次平滑处理的强度，0.5最佳 Uniform Length会将路径裁剪成每段相等线段，线段的最大长度取决于Max Segment Length，Max Segment Length越大路径越简单，同时也容易穿过不可走区域。我描述的可能不太清晰，看下面的例子或者自己尝试调节下参数很容易明白这两个属性的意义。 未开启SimpleSmooth 开启SimpleSmooth，但Uniform Length未开启。 开启Uniform Length Max Segment Length = 20 Max Segment Length = 100 2.Bezier通过贝塞尔曲线实现平滑，注意贝塞尔曲线处理过的路径总会通过所有的顶点（看下面的图就明白什么意思了），所以注意不要拐弯拐的太过。 Subdvisions 细分次数，设置为0时和未处理没什么区别 Bezier Tangent Length 贝塞尔曲线“切线”的长度系数。 Bezier Tangent Length值要注意，如图： Bezier Tangent Length = 0 Bezier Tangent Length = 0.5 Bezier Tangent Length =3（挺好看的） Bezier Tangent Length =10，曲线的曲率已经大的看不到了。 关于贝塞尔曲线，自行查阅资料。 3.OffSet通过向外偏移路径，减少拐点角度来实现平滑，注意offset的值过大会非常乱。 Iterations 平滑处理迭代次数 offset 偏移量 offset = 2，可以看到该模式下致力于减少拐角处的角度实现平滑。 4.Curved Non Uniform这个没什么好说的，平滑处理时曲线曲率是不相等的。 Factor：弧度系数 FunnelModifierFunnelModifier使用漏斗算法，快速准确的对路径进行简化。但在Grid的中优化的效果可能不尽人意，因为它只简化了路径队列中节点内的路径。在RaycastModifier中效果会好一些。 Unwrap：开启后将在XY以及更复杂的空间支持简化路径。 splitAtEveryPortal：每当通过一个节点就插入一个节点。 Grid图中简化效果 NavMesh下简化效果 官方文档：https://www.arongranberg.com/astar/docs/funnelmodifier.html Raycast ModifierRaycast Modifier将尝试使用光线检测（linecasting）从路径中删除尽可能多的节点。可以使用图的内置光线检测，也可以用Unity的Physics.Raycast完成光线检测。该组件主要应用于grid graphs 和 layered grid graphs。point graphs也可以使用Raycast Modifier，但point graphs并没有内置的光线检测系统，所以需要使用Unity的Physics.Raycast实现光线检测。 navmesh/recast图最好使用FunnelModifier。 在grid图中，Raycast Modifier和FunnelModifier可以同时使用。但混合使用可能不会简化出最优的路径，甚至可能带来不好的结果。当两者都被使用时，通常路径会紧密的贴在图的边界，而错失了简化路径的机会，并且混合使用时FunnelModifier会先运行简化路径，然后将简化结果传给Raycast Modifier进一步优化。 Raycast Modifier简化路径有几个级别，最高质量的计算速度明显慢于最低质量（大约十倍），下面是不同级别的区别： Low：使用一次贪心算法 Medium：使用贪心算法迭代两次 High：使用动态规划迭代一次 Highest：使用动态规划迭代三次 手动编写寻路虽然可以使用插件自带的组件来完成寻路移动，但是手写可以理解插件的工作原理。 上面的热身已经写过一个简单的寻路调用了，下面把它强化一下：（备注没写） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using UnityEngine;// Note this line, if it is left out, the script won&apos;t know that the class &apos;Path&apos; exists and it will throw compiler errors// This line should always be present at the top of scripts which use pathfindingusing Pathfinding;public class AstarAI : MonoBehaviour &#123;public Transform targetPosition;private Seeker seeker;private CharacterController controller;public Path path;public float speed = 2;public float nextWaypointDistance = 3;private int currentWaypoint = 0;public bool reachedEndOfPath;public void Start () &#123;seeker = GetComponent&lt;Seeker&gt;();// If you are writing a 2D game you can remove this line// and use the alternative way to move sugggested further below.controller = GetComponent&lt;CharacterController&gt;();// Start a new path to the targetPosition, call the the OnPathComplete function// when the path has been calculated (which may take a few frames depending on the complexity)seeker.StartPath(transform.position, targetPosition.position, OnPathComplete);&#125;public void OnPathComplete (Path p) &#123;Debug.Log(&quot;A path was calculated. Did it fail with an error? &quot; + p.error);if (!p.error) &#123;path = p;// Reset the waypoint counter so that we start to move towards the first point in the pathcurrentWaypoint = 0;&#125;&#125;public void Update () &#123;if (path == null) &#123;// We have no path to follow yet, so don&apos;t do anythingreturn;&#125;// Check in a loop if we are close enough to the current waypoint to switch to the next one.// We do this in a loop because many waypoints might be close to each other and we may reach// several of them in the same frame.reachedEndOfPath = false;// The distance to the next waypoint in the pathfloat distanceToWaypoint;while (true) &#123;// If you want maximum performance you can check the squared distance instead to get rid of a// square root calculation. But that is outside the scope of this tutorial.distanceToWaypoint = Vector3.Distance(transform.position, path.vectorPath[currentWaypoint]);if (distanceToWaypoint &lt; nextWaypointDistance) &#123;// Check if there is another waypoint or if we have reached the end of the pathif (currentWaypoint + 1 &lt; path.vectorPath.Count) &#123;currentWaypoint++;&#125; else &#123;// Set a status variable to indicate that the agent has reached the end of the path.// You can use this to trigger some special code if your game requires that.reachedEndOfPath = true;break;&#125;&#125; else &#123;break;&#125;&#125;// Slow down smoothly upon approaching the end of the path// This value will smoothly go from 1 to 0 as the agent approaches the last waypoint in the path.var speedFactor = reachedEndOfPath ? Mathf.Sqrt(distanceToWaypoint/nextWaypointDistance) : 1f;// Direction to the next waypoint// Normalize it so that it has a length of 1 world unitVector3 dir = (path.vectorPath[currentWaypoint] - transform.position).normalized;// Multiply the direction by our desired speed to get a velocityVector3 velocity = dir * speed * speedFactor;// Move the agent using the CharacterController component// Note that SimpleMove takes a velocity in meters/second, so we should not multiply by Time.deltaTimecontroller.SimpleMove(velocity);// If you are writing a 2D game you may want to remove the CharacterController and instead use e.g transform.Translate// transform.position += velocity * Time.deltaTime;&#125;&#125; 使用节点查找靠近位置的节点有时需要查找离目标点最近的点，使用方法： 12345// 找到距离GameObject最近的点GraphNode node = AstarPath.active.GetNearest(transform.position).node;if (node.Walkable) &#123;// 该点可走&#125; 或者只想获得离目标节点最近的可行走节点（Walkable），需要用到NNConstraint类，作为限定条件： 1GraphNode node = AstarPath.active.GetNearest(transform.position, NNConstraint.Default).node; NNConstraint是用于设置返回节点的条件的类，NNConstraint.Default是寻路的条件，也就是说该条件下计算出的节点都是Walkable。 如果想获得在更多限定条件下，距离目标节点最近的点。可以自行设置限定条件： 1234567891011121314var constraint = NNConstraint.None;// Constrain the search to walkable nodes onlyconstraint.constrainWalkability = true;constraint.walkable = true;// Constrain the search to only nodes with tag 3 or tag 5// The &apos;tags&apos; field is a bitmaskconstraint.constrainTags = true;constraint.tags = (1 &lt;&lt; 3) | (1 &lt;&lt; 5);var info = AstarPath.active.GetNearest(transform.position, constraint);var node = info.node;var closestPoint = info.position; 需要注意的是，搜寻最近节点的距离受制与Max Nearest Node Distance属性（在A* Inspector -&gt; Settings -&gt; Max Nearest Node Distance可以设置）。也就是说如果最近的点距离目标节点的距离超过 Max Nearest Node Distance，GetNearest方法会返回Null值。 GetNearest方法返回了一个NNInfo对象，NNInfo中包括两个属性，一是GraphNode类型的，距离最近的节点信息node。二是Vector3类型的，node的位置信息position。在Grid图中每个节点都被视为正方形，所以position就是正方形。在navmesh中，position就是最近的三角形的中心点（因为NavMesh的节点是每个三角形的中心点）。 所以同样的地图，Grid和NavMesh查找最近的点会有一些不同： 在NavMesh中，红色方块是距离白色小球最近的位置。 在Grid中，最近的节点位置就是最近的方块位置。 节点连接12345GraphNode node = ...;// Draw a line to all nodes that this node is connected tonode.GetConnections(otherNode =&gt; &#123;Debug.DrawLine((Vector3)node.position, (Vector3)otherNode.position);&#125;); GraphNode node = …;什么意思 GetConnections需要一个委托，通过委托来取得与节点相连的点。 节点的属性node.postion是int类型的，不能直接使用（一千倍），可以转换后使用： 123GraphNode node = ...;Vector3 v3position = (Vector3)node.position;node.position = (Int3)v3position; node还包含一些比较有用的信息，如tag，walkable。 123bool walkable = node.Walkable;uint tag = node.Tag;uint penalty = node.Penalty; 获取一个节点所在表面的随机点： Vector3 randomPoint = node.RandomPointOnSurface();（获取某位置的三角形） 可达性通过Scene场景不同颜色的区域可以判断哪些区域是连通的，可以到达，如图： 绿色和蓝色是两个区域且不连通 寻路系统通过计算图的连通分量来预先计算哪些节点可从哪些节点到达。不连通的两个区域（节点）会被标记为不同的颜色。每个节点的Area字段都设置为其连接组件的索引。如果2个节点具有相同的区域，则意味着它们之间存在有效路径。您也可以使用PathUtilities.IsPathPossible方法进行检查。计算这些区域或连接组件的过程被称为“洪水填充”。 通过代码判断两点之间的可达性： 12345var node1 = AstarPath.active.GetNearest(somePoint1);var node2 = AstarPath.active.GetNearest(somePoint2);if (PathUtilities.IsPathPossible(node1, node2)) &#123;// There is a valid path between the nodes&#125; 路径查找前面以及介绍过了，Seeker并不是立即执行寻路计算的，若想立即计算，需要调用Pathfinding.Path.BlockUntilCalculated方法，代码如下： 1234// 立即计算路径 Path p = seeker.StartPath (transform.position, transform.position + Vector3.forward * 10);p.BlockUntilCalculated(); 也可以使用协程等待路径计算： 1234567IEnumerator Start () &#123;var path = seeker.StartPath (transform.position, transform.position+transform.forward*10, OnPathComplete);// Wait... (may take some time depending on how complex the path is)// The rest of the game will continue to run while waitingyield return StartCoroutine (path.WaitForPath());// The path is calculated now&#125; 也可以创建自己的路径对象，而不是使用seeker的方法，并能够在计算路径对象之前更改其设置。代码： 1234567891011121314// Create a new path object, the last parameter is a callback function// but it will be used internally by the seeker, so we will set it to null here// Paths are created using the static Construct call because then it can use// pooled paths instead of creating a new path object all the time// which is a nice way to avoid frequent GC spikes.var p = ABPath.Construct (transform.position, transform.position+transform.forward*10, null);// By default, a search for the closest walkable nodes to the start and end nodes will be carried out// but for example in a turn based game, you might not want it to search for the closest walkable node, but return an error if the target point// was at an unwalkable node. Setting the NNConstraint to None will disable the nearest walkable node searchp.nnConstraint = NNConstraint.None;// Start the path by sending it to the Seekerseeker.StartPath (p, OnPathComplete); 多目标路径直接使用AstarPath类如果需要对路径进行更多控制，可以直接调用AstarPath组件。AstarPath组件的主要功能是AstarPath.StartPath。如果要同时计算大量路径。搜索者适用于一次只有一个活动路径的代理，如果您尝试同时请求多个路径，它将只计算最后一个路径并取消其余路径。 注：使用AstarPath.StartPath计算的路径不会进行后处理。但是，您可以在计算路径后使用附加到特定搜索器的修改器对其进行后处理，从而调用Seeker.PostProcess。 123456789101112// There must be an AstarPath instance in the sceneif (AstarPath.active == null) return;// We can calculate multiple paths asynchronouslyfor (int i = 0; i &lt; 10; i++) &#123;// As there is not Seeker to keep track of the callbacks, we now need to specify the callback every time againvar p = ABPath.Construct(transform.position, transform.position+transform.forward*i*10, OnPathComplete);// Start the path by calling the AstarPath component directly// AstarPath.active is the active AstarPath instance in the sceneAstarPath.StartPath (p);&#125; NavMesh生成生成NavMesh有两种方法，一是通过一些软件手动生成（Blender 等等），二是使用 Recast Graph自动生成（付费）。 手动生成就不做介绍了，可以看文档：https://arongranberg.com/astar/docs/createnavmesh.html 关于NavMesh的生成原理： Recast Graph是付费版才有的图，功能强大，可以自动识别到地板以及障碍信息，使用Recast Graph生成Navmesh分为如下几步： 1.在Astar面板点击创建Recast Graph 2.点击Snap Bounds To Scene按钮 Snap Bounds To Scene会自动识别场景中的轮廓，如图： 白色的边框就是被识别出的轮廓 3.调整参数 Recast Graph生成NavMesh时，面板上的Width和Depth是无法直接修改的。必须要通过控制Cell（每个体素的大小）的大小来调节Width和Depth。 可以按图中设置为0.1 同时还有一个很关键的属性，tiles。recast graph使用tiles将图划分成一个个正方形区域。tile值的大小没有最佳，一般维持在 64至256。将Use tiles选项设置为Dont Use Tiles可以禁止使用tiles划分地图，但是Tiles有几个好处： 可以并行扫描不同的图块，使扫描更快。 可以实时更新recast graph中的各个tiles，比更新整个图更快。 navmesh切割以逐个图块为基础进行操作，并且更新图形的较小部分更快。 可以分解非常大的多边形，从而降低寻路选择次优路径的风险（连接）。 原文： It makes it possible to scan the different tiles in parallel which can make the scan a lot faster. You can update individual tiles in a recast graph during runtime, which is faster than updating the whole graph. navmesh cutting operates on a tile by tile basis and updating a smaller part of the graph is faster. It breaks up very large polygons which reduces the risk of very suboptimal paths (more about this in Using navmeshes). 不适用Tiles 使用Tiles 4.将代理物体从NavMesh中分离： 5.设置好参数后，点击扫描。注意点击Show Outline’ 和 ‘Show Surface’选项以便观察生成的NavMesh。 细节 recast graph的分辨率（width/depth）会很明显的影响navmesh，如图： （有一个不可走的） 注意：（光栅化）分辨率对图的生成时间有很大影响，对运行时的性能没有直接影响（在游戏中完整更新一次图除外），但会微弱的影响性能，因为高分辨率意味着地图也会有更多的细节。 原文： Rasterization resolution has a great effect on the time it takes to generate a recast graph, but it has no direct impact on the runtime performance of it (except of course, full graph updates). Indirectly it can affect it slightly since a large resolution can add more detail to the graph. 一张很大的NavMesh扫描的时间会很长，可以使用缓存来节省性能，连接：。 工作原理]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnityiOSSDK接入]]></title>
    <url>%2F2019%2F12%2F11%2FUnityIosSDK%E6%8E%A5%E5%85%A5%2F</url>
    <content type="text"><![CDATA[iOS的SDK接入流程 一 导出Xcode工程1.1修改cs文件配置plist修改 IOSPostprocessBuild.cs ，目的是在此提前配置好接下来导出的Xcode工程Custom iOS Target Properties的一些设置，如果不在此填配置参数则需要在Xcode中设置。 文件目录： 1D:\workspace\cq1_g\branch_release\client\cq1_g\Assets\Editor\Game （1）在ModifyProj方法中添加此SDK需要接入的额外.framework库，有一些通用的库已经在方法中配置好了，但如果需要对特定SDK添加额外的framework库。其中“YXM”为自定义的宏名称，添加格式下： 1234567891011121314public static void ModifyProj(string pathToBuildProject, XcodeBuilderItem xcodeBuilderItem) &#123; //通用的framework库 .... switch (scriptDefine) &#123; case "YXM": // 游戏猫平台 UnityEngine.Debug.Log ("游戏猫平台 modify：" + scriptDefine); // 添加登录SDK framework _pbxProj.AddFrameworkToProject(_targetGuid, "SystemConfiguration.framework", true); _pbxProj.AddFrameworkToProject (_targetGuid, "JavaScriptCore.framework", true); break; ... &#125; （2）在SetPlist方法中填写SDK需要的Xcode设置： 12345678910111213141516171819202122232425static void SetPlist(string pathToBuildProject, XcodeBuilderItem xcodeBuilderItem) &#123; //通用的plist设置 ... switch (scriptDefine) &#123; case "DACHEN_B2_IOS": //平台名 UnityEngine.Debug.Log ("755sy (大臣B2)plist：" + scriptDefine); _rootDic.SetString("NSCameraUsageDescription", "需要使用您的相机照相"); _rootDic.SetString("CFBundleDevelopmentRegion", "zh_CN"); PlistElementArray LSApplicationQueriesSchemesB2 = _rootDic.CreateArray ("LSApplicationQueriesSchemes"); LSApplicationQueriesSchemesB2.AddString ("weixin"); LSApplicationQueriesSchemesB2.AddString ("alipay"); LSApplicationQueriesSchemesB2.AddString ("openedvv"); LSApplicationQueriesSchemesB2.AddString ("alipayqr"); LSApplicationQueriesSchemesB2.AddString ("wechat"); PlistElementArray dachenB2URLTypes = _rootDic.CreateArray ("CFBundleURLTypes"); PlistElementDict dcb2item0_1 = dachenB2URLTypes.AddDict (); PlistElementArray dcb2urlSchemes = dcb2item0_1.CreateArray ("CFBundleURLSchemes"); dcb2urlSchemes.AddString ("miaolevv5228"); break;.... &#125; 1.2修改iOS配置表打开D:\workspace\cq1_g\branch_release\tool\客户端打包\iOS打包配置表，对准备接入SDK的包进行一些设置： 一些需要配置的字段介绍： 名称 作用 包名 包名由SDK方提供，如ios.zhbdsb.com，如未提供按命名规则自行填写。 名称 由SDK方提供 xcode工程名称 自行按照命名规则填写，游戏名_平台 _渠道名(ltzj_ios_ly) 宏 在1.1章配置的特定frame库和plist时设置的宏。 拷贝文件 需要拷贝到Xcode工程的文件，一般需要UnityAppController.mm 目标系统版本 iOS设备的系统版本 产品名称 渠道方名称拼音缩写 Version Bundle Platid(必须和渠道表一致) 1.3修改打包列表打开D:\workspace\cq1_g\branch_release\tool\客户端打包\打包列表，修改为1.2表中的包名： 1.4修改资源打开D:\workspace\cq1_g\branch_release\client\cq1_g\BuildSetting\Package文件夹，复制一份接过iOSSDK的包文件夹。修改文件夹中的内容为SDK中提供的文件、图标。 （1）将XcodeFiles\SDK中的内容替换为渠道方提供的.framework.bundle。 （2）在Resource文件夹下放入加载图片、闪屏 （3）在Icon文件夹下放入游戏图标，命名是固定的，注意修改。 （4）在Plugins/IOS文件夹下放入如下四个文件，这两组文件接SDK时会用到： 1.5导出Xcode工程点击BuildProject导出Xcode工程文件。 二 接入SDK2.1修改项目配置（1）勾选Automatically manage signing，自动管理证书。准备打包ipa时再调整为提供的证书。 （2）检查Custom iOS Target Properties中的配置是否和SDK文档中对应，1.1章节配置的plist会显示在此： （3）如果提示内购报错，将内购关闭（下图的in-APP Purchase）： （4）检查framework是否添加至工程。 2.2根据文档接入SDK（1）UnityAppDelegate中接入初始化，apple id，横竖屏等参数。 （2）在ViewController中接入支付、登陆、上传角色信息等接口。充值和上传角色需要传入的数组（param）会在Lua脚本中配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160....#import &lt;NiuNiuGame/NiuNiuGameHeader.h&gt;...// ************************** 添加事件 ************************** //- (void) addEvent&#123; //捕获登录消息 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(loginNotificationResult:) name:NSdkGameLoginNotification object:nil]; //捕获注销消息 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(LogoutNotificationResult:) name:NSdkGAMELogoutNotification object:nil]; //充值回调 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(PayNotificationResult:) name:NSdkGAMEMaiNotification object:nil];&#125;...// ************************** 登录 ************************** //- (void) loginAction:(NSString*)param&#123; if ([[NiuNiuGame sharedInstance] isLogined]) &#123; return; &#125; if(![[NiuNiuGame sharedInstance] isShowLoginView])&#123; [[NiuNiuGame sharedInstance] login]; &#125;&#125;# pragma mark - 捕获登录消息//捕获登录消息- (void)loginNotificationResult:(NSNotification *) notif&#123; if ([[NiuNiuGame sharedInstance] isLogined]) &#123; [[NiuNiuGame sharedInstance]showLogo]; // 登录成功后的操作 NSDictionary *userinfo = [notif userInfo]; // 获取用户usertoken NSString *usertoken = [userinfo objectForKey:@"usertoken"]; // 获取用户id NSString *userid = [userinfo objectForKey:@"userid"]; // appid NSString *appid = @"1116"; NSLog(@"登录成功"); NSString *info =[NSString stringWithFormat:@"app_id=%@&amp;user_id=%@&amp;token=%@",appid,userid,usertoken]; NSLog(@"--LoginInfo--%@", info); UnitySendMessage("SDKBack", "LoginBack", info.UTF8String); &#125;&#125;// ************************ 切换账号 ************************ //- (void) changeAccountAction:(NSString*)param&#123; [[NiuNiuGame sharedInstance] logout];&#125;# pragma mark - 捕获登出消息- (void)LogoutNotificationResult:(NSNotification *) notif &#123; NSLog(@"注销成功"); UnitySendMessage("SDKBack", "LoginBack", "Logout");&#125;// ************************ 支付 ************************** ////param数组在lua中配置- (void) rechargeAction:(NSString *)param&#123; NSArray *array = [param componentsSeparatedByString:@"|"]; NSLog(@"---recharge ：%@",[self descriptionWithLocale:array]); if ([[NiuNiuGame sharedInstance] isLogined]) &#123; [[NiuNiuGame sharedInstance] doSDKMaiWithSpxxId: array[0] //牛牛的后台商品ID Spxxjg:[array[1] intValue] //单份价格 Multiple:[array[2] intValue] //购买份数 ExtraData:array[5] //额外参数 SpxxDdh:array[4] //[self getOrderid] //厂商的订单号 APItemId:array[0] ];// 苹果的内购ID （iOS包不走内购的话就先填成商品ID） &#125;&#125;# pragma mark - 捕获付款消息//捕获付款消息- (void)PayNotificationResult:(NSNotification *) notif&#123; NSDictionary *payinfo = [notif userInfo]; NSString * result = [payinfo objectForKey:@"result"]; // 获取支付结果描述 NSString *desc = [payinfo objectForKey:@"desc"]; if([result isEqualToString:@"success"])&#123; NSLog(@"支付成功"); // 获取厂商订单号 NSString *cporderid = [payinfo objectForKey:@"cporderid"]; // 获取SDK订单号 NSString *sdkorderid = [payinfo objectForKey:@"sdkorderid"]; NSString * logresult = [NSString stringWithFormat:@"%@%@%@%@%@%@", @"-捕获付款信息成功回调-\n--------------------------\n", desc, @"\n厂商订单号：\n", cporderid, @"\nSDK 订单号\n", sdkorderid]; NSLog(@"%@", logresult); UnitySendMessage("SDKBack", "RechargeBack","Success"); &#125;else &#123; NSString * logresult2 = [NSString stringWithFormat:@"%@%@%@%@", @"-捕获付款信息失败回调-\n--------------------------\n", @"购买失败 【", desc, @"】"]; NSLog(@"%@", logresult2); UnitySendMessage("SDKBack", "RechargeBack","Failed"); &#125;&#125;//******************** 提交用户角色信息 ********************* ////param数组在lua中配置- (void) userDataAction:(NSString *)param&#123; NSArray *array = [param componentsSeparatedByString:@"|"]; NSLog(@"---userdata ：%@",[self descriptionWithLocale:array]); //进入游戏 if([array[0] intValue] == 1)&#123; NSLog(@"登陆上传角色信息"); [[NiuNiuGame sharedInstance]setServId:array[1] //区服ID ServName:array[2] //区服名称 RoleId:array[3] //角色ID RoleName:array[4] //角色名称 RoleGrade:[array[5] intValue]]; //等级 int 型 &#125;//升级 else if([array[0] intValue] == 2) &#123; NSLog(@"升级上传角色信息"); [[NiuNiuGame sharedInstance] setRoleId:array[1] //角色ID RoleGrade:[array[2] intValue]]; //最新等级 &#125;&#125;...@end 三 Lua中配置SDk3.1配置渠道信息表在项目下的渠道信息表中配置包的参数，和1.2章节中的iOS配置表保持一致。 3.2添加对应SDK的Lua脚本在D:\workspace\cq1_g\branch_release\client\cq1_g\Assets\_GameData\Lua\Game\Game\SDK文件夹下按命名规则（渠道名+平台+SDK 一律大写）新建脚本。 在2.2中的方法中使用的param数组，要从lua中组织好数据传过去才能使用： .mm充值方法传入入的数组： 12345678function LYLYHDIOSSDK:OnRecharge() self.rechargeParam = "" .. self.rechargeCfg.ID self.rechargeParam = self.rechargeParam .. "|" .. self.rechargeCfg.NeedCNY * 100 self.rechargeParam = self.rechargeParam .. "|" .. "1" self.rechargeParam = self.rechargeParam .. "|" .. "1460762673" self.rechargeParam = self.rechargeParam .. "|" .. self.rechargeOrderID self.rechargeParam = self.rechargeParam .. "|" .. encodeBase64(self.rechargeCustomInfo)end 角色信息上传，1为登陆上传角色信息，2为升级上传角色信息。HanleEnterGame和HandleLevelUp方法为升级和登陆时需要进行的一些操作： 12345678910111213141516171819202122232425262728function LYLYHDIOSSDK:HanleEnterGame() self.sendDataType = "EnterGame" self:SendUserData()endfunction LYLYHDIOSSDK:HandleLevelUp() self.sendDataType = "LevelUp" self:SendUserData()endfunction LYLYHDIOSSDK:OnUserData() if self.sendDataType == "EnterGame" then local serverName = GameModels.login.selectServerName if serverName == "" then serverName = "无" end self.userdataParam = "" .. "1" self.userdataParam = self.userdataParam .. "|" .. GameModels.login.serverTag self.userdataParam = self.userdataParam .. "|" .. serverName self.userdataParam = self.userdataParam .. "|" .. GameModels.role.myRole:Get_roleID() self.userdataParam = self.userdataParam .. "|" .. GameModels.role.myRole:Get_name() self.userdataParam = self.userdataParam .. "|" .. GameModels.role.myRole:Get_level() else self.userdataParam = "" .. "2" self.userdataParam = self.userdataParam .. "|" .. GameModels.role.myRole:Get_roleID() self.userdataParam = self.userdataParam .. "|" .. GameModels.role.myRole:Get_level() endend 如果需要调用其它方法，可以在BaseSDK.lua中查找并在SDK脚本中重写。 3.3添加新引入的SDK平台 （PlatformSDK.lua）找到SDK目录下的PlatformSDK.lua，添加如下代码，导入3.2写的SDK脚本： 12345...require "Game/SDK/Platform/LYLYHDIOSSDK"...PlatformSDK[116] = LYLYHDIOSSDK.new()... 四 出包4.1准备热更包（1）使用cmd mstsc远程连接打包用的电脑，修改版本号文件夹（测试稳定后更为正式版本号）。 （2）打开生成热更包工具，生成热更文件。全部生成（lua，数据表，UI）约需要一个小时。 4.2 热更测试通知运维上传热更包，对接入SDK的功能模块进行测试。在测试支付时可向渠道方询问是否有账号可以用来进行支付的测试。或者配置一个临时的商品数据进行调试。 4.3出包（1）测试无误后将SDK提供证书安装好。再次运行游戏测试。安装SDK提供的证书（双击打开添加至钥匙串，密码由渠道方提供），然后在Xcode中打出ipa包： 点击Distribute App： 根据需求选择对应的包： 选择ipa包运行的设备： 配置证书： （2）检查ipa包是否正常，确认无误后交付给渠道方。 五 常见错误出现其他错误及时补充。 5.1未引入库引发的错误5.1.1 Undefined symbol：_OBJC_ClASS_ __$_SKMutablePayment/SKProductsRequest/SKPaymentQueue 解决办法：缺少StoreKit.framework（内购需要），添加至项目即可。]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Unity</tag>
        <tag>iOS</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用手册]]></title>
    <url>%2F2019%2F12%2F11%2FGit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.连接GitHub 配置信息 12git config --global user.name "你的GitHub用户名"git config --global user.email "你的GitHub注册邮箱" 生成密钥文件 1ssh-keygen -t rsa -C "你的GitHub注册邮箱" 后面提示连按三个回车即可。 找到C:\Users\Sayi1.ssh文件夹中的id_rsa.pub，复制全部内容。 打开GitHub-Settings-SSH And GPGkeys ，选择New SSH Key，粘贴.pub的内容。 检测GitHub公钥设置是否成功，输入： 1ssh git@github.com 出现 Hi ! “你的github名字”即设置成功。 之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 2.配置环境1.检测Node.is和Npm是否安装成功： 12node -vnpm -v 如果Bash上显示了Node和npm的版本号即安装成功 2.安装Hexo 1npm install -g hexo-cli 完成上步后，输入： 1hexo init blog 检测网站是否可以运行： 12345hexo new test_my_sitehexo ghexo s 完成后，在浏览器中输入：localhost:4000可以看到已经有一个简陋的网站了。 在bash中输入hexo可以看有哪些常用指令： 1234567891011121314npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 3.网站推送找到网站目录，打开_config.yml。_config.yml是网站的配置文件。themes目录下也有一个同名文件，那个是主题配置文件。 打开文件，找到最后的deploy，修改为： 1234deploy: type: git repository: git@github.com:qihr/qihr.github.io.git branch: master 修改这是为了给hexo d配置对应参数，此时生成的静态页面会推送至master分支。]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC入门笔记]]></title>
    <url>%2F2019%2F12%2F11%2FObjectC%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[OC学习笔记 属性12@property(copy) NSString *name;@property(readonly) int age; copy和readonly等等 动态类型转发函数和方法]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>ObjectC-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity NavMesh和寻路插件使用]]></title>
    <url>%2F2019%2F12%2F11%2FUnity%20NavMesh%E5%92%8C%E5%AF%BB%E8%B7%AF%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[该文档主要是介绍Unity的导航系统和寻路插件使用，不同场景下寻路的工作流程，以及工作原理，没有涉及太多API讲解以及如何与其他组件的集成开发。 目录下包含一个简单的演示Demo，里面包括我作为练习写的几个Scene以及官方提供的实例，需要使用寻路导航系统的场景非常多，这些场景中彼此又具有较大的差异，如寻路时动态躲避障碍物，追逐某移动中的角色寻路，Demo中没有包含实际游戏中的全部情况，想了解更多可以去下载官网Demo，或看一些更专业的教程，下载地址和教程以及我学习时查询的资料的链接会在附录中给出。 文档若出现错误，请及时指正。 前言备注 2018.12.10 Unity的NavMesh应用于简单的静态动态场景的使用方法介绍，以及A*插件的部分使用方法介绍。2018.12.14 Unity的NavMesh的工作原理概述，navgation系统中各个组件面板介绍。2018.12.18 介绍Unity的NavMesh中的实时局部Bake场景，自动离网链接场景的简单使用。2018.12.19 增加寻路代价实现demo Unity的导航系统Unity的导航系统主要有四个部分：NavMesh，NavMesh Agent，Off-Mesh Link，NavMesh Obstacle。 NavMesh（ Navigation Mesh的缩写）导航网格，是一种数据结构，并将游戏中物体结构关系转化为带有信息的网格，通过网格进行计算自动寻路的路径。NavMesh数据可以通过烘焙(Bake)产生。 NavMesh Agent导航网格代理，简称代理。是Unity导航系统的核心组件，用来存放代理周游NavMesh的路径信息的平台。角色导航避障的移动是通过代理(NavMesh Agent)实现的，也就是说除非使用其他的寻路算法，否则想让某一个物体具有寻路导航的功能，就必须要为他配置一个代理。该组件一般添加在需要寻路的角色上。 Off-Mesh Link离网链接，该组件主要用于连接两个不连通的跳跃点，如跳过沟渠或者开门等场景。该组件一般添加在跳跃点上。 NavMesh Obstacle导航网格障碍，该组件主要用于移动障碍。代理可以自动躲避添加了该组件的障碍物（动态和静态）。该组件一般添加在静止或移动的障碍物上。 导航系统的基本流程大概流程，比如一个RPG游戏的某个副本场景： 为障碍物添加NavMesh Obstacle，根据实际情况对NavMesh Obstacle组件进行设置； 为传送点，跳跃点添加Off-Mesh Link； 烘焙副本场景，生成Navmesh； 为角色添加NavMesh Agent并指定参数； 角色寻路，代理根据生成好的NavMesh以及地图中的障碍物信息进行计算最佳路径。 工作原理 NavMesh的生成我的理解（翻译）： 导航系统需要一种数据结构来存储游戏场景中的可行走区域。，可行走区域的定义是场景中代理可以站立和移动的区域。 同时，在Unity中，代理被视为圆柱体，并以圆柱的体积参数来参与计算。 可行走区域通过场景中测试代理可以站立的位置自动生成可供代理移动的，由多个多边形组成的平面（下图蓝色部分），平面置于游戏的地板（或几何体平面）之上，同时平面存储了有哪些多边形彼此相邻的信息，该表面称为导航网格（简称NavMesh）。NavMesh是可行走区域的近似值。 官方手册的原文： The navigation system needs its own data to represent the walkable areas in a game scene. The walkable areas define the places in the scene where the agent can stand and move. In Unity the agents are described as cylinders. The walkable area is built automatically from the geometry in the scene by testing the locations where the agent can stand. Then the locations are connected to a surface laying on top of the scene geometry. This surface is called the navigation mesh (NavMesh for short).we store information about which polygons are neighbours to each other. This allows us to reason about the whole walkable area. Another thing to keep in mind is that the NavMesh is an approximation of the walkable surface.This can be seen for example in the stairs which are represented as a flat surface, while the source surface has steps 生成的蓝色NavMesh平面 在烘焙（Bake）后，会在场景同级目录生成一个文件夹： 文件夹 原文链接： NavMesh生成的多边形NavMesh生成的是凸多边形，凸多边形中任意两点可以以直线相连。 原文： The NavMesh stores this surface as convex polygons. Convex polygons are a useful representation, since we know that there are no obstructions between any two points inside a polygon. In addition to the polygon boundaries, AB两点无法通过直线相连 原文链接: NavMesh Agent如何找到路径要查找场景中两个位置之间的路径，首先需要将起始位置和目标位置映射到附近的多边形上。 然后从起始位置开始搜索，访问所有临近多边形，直到到达目标位置。 根据被访问过的多边形，可以得到一个从起始位置到目标位置的多边形序列。，该序列被称为corridor。Unity寻找路径使用的算法是A *。 原文 To find path between two locations in the scene, we first need to map the start and destination locations to their nearest polygons. Then we start searching from the start location, visiting all the neighbours until we reach the destination polygon. Tracing the visited polygons allows us to find the sequence of polygons which will lead from the start to the destination. A common algorithm to find the path is A* (pronounced “A star”), which is what Unity uses. The sequence of polygons which describe the path from the start to the destination polygon is called a corridor. The agent will reach the destination by always steering towards the next visible corner of the corridor. 关于为什么序列中储存的是多边形序列而不是路线线段： If you have a simple game where only one agent moves in the scene, it is fine to find all the corners of the corridor in one swoop and animate the character to move along the line segments connecting the corners. 如果使用线段作为corridor，当场景内有多个角色在寻路时，角色之间要在互相避让彼此的同时并寻路，这样就会造成寻路路径和计算出的造成偏差。尝试使用由线段组成的路径来纠正这种偏差很快变得非常困难且容易出错。 障碍躲避躲避障碍是基于下一个区域的位置，并计算出到达目的地所需的期望方向和速度来完成转向。个人理解即角色遇到障碍时只考虑并计算，如何到达避开障碍物拐点需要的速度和方向。 原文： The steering logic takes the position of the next corner and based on that figures out a desired direction and speed (or velocity) needed to reach the destination. Using the desired velocity to move the agent can lead to collision with other agents. 避障时选择了新的速度，这个速度由期望的方向和防止之后与其他寻路实体以及导航网格边缘碰撞来权衡的。 Unity目前使用RVO算法来预测和防止角色与障碍物碰撞。 Moving the Agent在转向和避障之后，会得出最终的速度。在Unity里，寻路实体使用一个动力学的模型来模拟，通过计算加速度来使移动更自然和平滑。 Global and Local负责的工作 Global 的工作是在场景世界中寻找corridor。 在场景世界各地寻找计算corridor很耗费性能。 Local 的工作是通过线性存储的多边形导航关系路线corridor，来计算如何到达下一个拐点同时避开其他正在移动的物体。 打个比方，从家到公司，Globel负责计算这段路的行进路线，比如坐先公交-地铁-最后步行，但途中我如何刷卡进地铁，怎么过马路就是Local的工作了。Global负责宏观的路线规划，Local负责微观的细节处理。 原文： Global navigation is used to find the corridor across the world. Finding a path across the world is a costly operation requiring quite a lot of processing power and memory. The linear list of polygons describing the path is a flexible data structure for steering, and it can be locally adjusted as the agent’s position moves. Local navigation tries to figure out how to efficiently move towards the next corner without colliding with other agents or moving objects. 组件介绍* 1.Nav Mesh Agent 属性 功能 Agent Type 代理类型，可以选择不同的代理类型 Base Offset 基本偏移，物体实际的锚点和代理锚点的偏移量。[1] Steering speed 速度，前往目的地的最大移动速度。 Angular Speed 角速度，最大的转角速度，角度/秒 Acceleration 加速度，最大加速度 Stopping Distance 停止距离，代理距离目的地小于该值时停止。[2] Auto Braking 制动距离，当物体和目的地小于制动距离时，开始减速。[2] Obstacle Avoidance Radius 代理半径，该半径参数只用于寻路时使用，使用时最好比实际值大一些。[3] Height 代理高度 Quality 避障精度，如果场景内存在大量的代理，可以通过降低精度来节省CPU消耗[4] Priority 躲避优先级，当代理表现为逃避时，优先级低的代理将会被忽略。该值的范围从0到99:最重要=0，最不重要=99，默认=50。[5] Path Finding Auto Traverse Off MeshLink 自动生成离网链接，如果使用动画或某种特定方式穿过离网链接点，则应关闭此功能。[6] Auto Repath 当前路径变成无效时该代理是否尝试获取新路径 Area Mask 代理在查找路径时会考虑的区域类型 [1] [4]又名躲避精度。通过降低该值的方式可降低CPU开销，但如果寻路物体的躲避精度为none时，虽然寻路实体依然会绕开障碍物，但寻路实体之间不会发生碰撞（寻路实体会粘合在一起） 2.Nav Mesh Obstacle 属性 功能 Shape 物体形状,盒子/胶囊体 Center 障碍的中心点，在对象的自身空间测量。 Size 障碍的大小，在对象的自身空间测量。 Carve 挖洞，是否打开在导航网格挖洞的模式。[1] Move Threshold 移动距离阈值，物体移动距离超过阈值后将更新导航网格，导航网格将障碍物运动状态视为移动。 Time To Stationary 时间阈值，超过该值，刷新导航网格 Carve Only Stationary 勾选后，障碍物只在静止时挖洞 [1] 关于Carve: 障碍物有两种，一种是开启了Carve，一种是未开启，代理会根据障碍物的类型做出不同的反应： Obstructing模式（关闭Carve）:障碍物没有开启Carve时，它只是一个带碰撞器的普通障碍物。导航过程中，代理会尽量避免与障碍物碰撞。但如果两者距离较近，还是会发生碰撞。因为障碍物躲避非常基础，并且是基于一个短半径来计算（模糊运算），所以当障碍物过多时会出现找不到路的情况。这个模式多用于动态障碍物，如汽车或游戏角色。 When Carve is not enabled, the default behavior of the Nav Mesh Obstacle is similar to that of a Collider. Nav Mesh Agents try to avoid collisions with the Nav Mesh Obstacle, and when close, they collide with the Nav Mesh Obstacle. Obstacle avoidance behaviour is very basic, and has a short radius. As such, the Nav Mesh Agent might not be able to find its way around in an environment cluttered with Nav Mesh Obstacles. This mode is best used in cases where the obstacle is constantly moving (for example, a vehicle or player character). Carving模式（开启Carve）：Carve被勾选时，静止的障碍物所在的网格会出现一个空洞，表示不可通行，只有当这个障碍物正在移动时才会变成Obstructing模式。NavMesh会记录空洞的相关信息，并引导寻路实体绕开障碍物或者当路径被封锁时启动重新寻路。用烂车和木箱设置关卡障碍时切记要勾选镂空属性，当且仅当这些障碍物受到其他外力和固定游戏事件时，如爆炸，才能被移开。 When Carve is enabled, the obstacle carves a hole in the NavMesh when stationary. When moving, the obstacle is an obstruction. When a hole is carved into the NavMesh, the pathfinder is able to navigate the Nav Mesh Agent around locations cluttered with obstacles, or find another route if the current path gets blocked by an obstacle. It’s good practice to turn on carving for Nav Mesh Obstacles that generally block navigation but can be moved by the player or other game events like explosions (for example, crates or barrels). 两种障碍物的类型决定了计算的方式，Obstructing模式由Local负责处理，Carving模式由Global负责处理（代表着CPU开销更大）。 移动的障碍物应该尽量避免使用Carving模式，因为Carve产生的洞会影响NavMesh，同时Global的计算量也会增加，使CPU和内存开销变大。 3.Off Mesh Link 属性 功能 Start 离网链接的（跳跃点）起始位置 End 离网链接的（跳跃点）终点位置 Cost Override 成本覆盖，如果值为正，则在计算处理路径请求时的路径成本时使用该值。值为负，则使用该区域的默认成本(Navigation面板中的Area中的Cost) Bi Directional 勾选后可以双向移动，否则只能从Start到End。 Activated 勾选后角色寻路时将跳跃点也添加至计算范围，否则忽略。 Auto Upadate Positions 自动更新位置,若两端点位置有变化则自动此更新离网链接。 Navigation Area 跳跃点所属的区域。[2] 注：offmeshlink可以使用任何带有Transform的游戏对象作为开始和结束标记。 4.Navigation面板（window栏-Navigation） Agents面板用于代理和代理之间的躲避，该页的参数不参与Bake，只用于处理代理与代理，代理与障碍之间的躲避。在使用章节有关于该面板如何使用的介绍。 关于此Tab，unity社区的问答：https://answers.unity.com/questions/1376465/what-is-the-difference-between-configuration-of-ag.html Areas代表烘焙网格所在的图层， 有29种自定义类型和3种内置类型：Walkable，Not Walkable和Jump。\1. Walkable是通用区域类型，可以在该区域上行走。\2. Not Walkable是阻止导航的区域类型。\3. Jump是分配给自动生成的离网链接的区域类型。另外，每个NavMesh代理都有一个Area Mask，用于指定代理可以移动的区域。Cost是寻路的代价（成本），比如角色可以选择两条路，一条是过河，一条是草地。这两种寻路方式可能消耗的成本不一样。或是一扇门，人类可以通过但是其他怪物不能通过。都需要通过控制cost和area来实现。具体使用看下面的寻路导航章节。 Bake页面根据面板参数对当前场景进行烘焙地图，生成NavMesh，注意为了减少CPU和内存消耗，在烘焙设置中只能指定一种尺寸，如果需要生成多种NavMesh，参考下面章节。 属性 功能 Agent Radius 代理的中心与墙壁等障碍物可接近的距离半径。 Agent Height 代理的中心与墙壁等障碍物可接近的距离高度。 Max Slope 最大坡度，代理可以爬坡的最大高度。 Step Height 台阶高度，代理可以攀爬的最大台阶高度。 Generated Off Mesh Links Drop Height 离网链接中最大的下落高度。[1] Jump Distance 离网链接中最大的下落距离。[2] 进阶设置具体在高级烘培设置章节看。 属性 功能 Navigation Static 导航静态,表示该游戏对象是否参与导航网格的烘焙。 OffMeshLink Generation 生成离网链接，选中该复选框，可以自动根据Drop Height（下落高度）和Jump Distance（跳跃距离）的参数设置生成离网链接 NavigationArea 导航区域设置。在默认情况下分为Walkable（行走区域），Not Walkable（不可行走层，该层即使在Area Mask中选择可走，实际运行也无法行走）和Jump（跳跃层）。（具体可以在Areas面板中进行设置） ###其他 ####代理的半径 通过上面的内容可以注意到，代理的半径和高度可以在两个位置更改，一是Nav Mesh Agent，另一个是在Navigation面板中。 Navigation面板中设置表示代理如何闪避和碰撞静态的游戏物体，为了减少内存和CPU的开销，只能指定一种半径大小。 Nav Mesh Agent的属性值代表代理如何与动态障碍物以及其他之间的碰撞。 一般情况下两个半径设置大小相同。 ####高级烘培设置 属性 功能 Advanced Manual Voxel Size 手动更改体素大小，通常不需要调整体素大小，有两种情况可能需要这样做：构建较小的代理半径或更准确的 NavMesh。 Voxel Size 体素大小 Min Region Area 最小区域设置，小于该值的NavMesh区域将被删除。 Height Mesh 高度网格 [1]Min Region Area不能完全的删除所以小于该值的多边形，因为会有下面这种情况： 删除前 删除后 可以看到，图中四个正方体上的多边形区域被删掉了，但是小于正方体上多边形面积的，位于正方体中间的区域却没有被删除，这是因为如果移除该区域则可能无法访问或连通周围的区域。 [2]Manual Voxel Size允许手动更改烘培的精准度，NavMesh是通过体素化场景内的物体生成的。 在生成NavMesh算法的开始，场景被栅格化为体素，然后提取可行走的表面，并将可行走的表面变成NavMesh。 voxel size表示生成的NavMesh的准确程度。 voxel size的默认精度始终是代理半径的1/3，也就是和代理半径保持着3倍的关系。这是Unity官方在精确度和烘焙速度之间的折衷方案。将体素大小减半会使内存使用量增加4倍，构建场景需要4倍的时间。 原文： The default accuracy is set so that there are 3 voxels per agent radius, that is, the whole agent width is 6 voxels. This is a good trade off between accuracy and bake speed. Halving the voxel size will increase the memory usage by 4x and it will take 4x longer to build the scene. 由于在默认情况下voxel size和代理半径表示为3倍关系，但可能会出现一种情况：需要较小的代理半径，但是不需要voxel size的值也跟随半径变小，可以使用以下办法： 将“代理半径”设置为实际代理半径。 打开手动体素大小，这将采用当前体素大小并“冻结”。 设置较小的Agent Radius，因为已经开启了手动修改体素大小，所以大小不会改变。 官方文档：https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AdvancedSettings.html 寻路代价*通过cost可以定义通过该区域的困难程度(代价)，，成本更低的地方在寻路过程中优先级更高，cost可以控制角色寻路时偏好的区域。例如走草地要比走水路要快一些，就可以通过设置cost来实现。具体例子可以看演示章节。 在进一步了解之前，首先先了解一下A 寻路的工作原理：Unity使用A算法来寻找导航的最短路径，其核心数据结构为图。算法从离寻路实体最近的网格进行遍历，接着不停地访问相邻网格节点，直到搜寻到终点所在的网格区域(起点到终点的网格连线就是导航路径（此时未带入估价函数，即非最短路径）)。 因为导航网格是由一系列多边形组成的，所以寻路实体需要计算通过每块网格或者说节点的寻路代价。最短路径就是各节点连线的最低寻路代价。 在两个节点之间移动的花费取决于行进距离以及当前所属区域的成本，即距离 成本。 这意味着，如果一个区域的成本是2，那么寻路实体通过该区域的距离相对于普通区域的距离要大两倍。 A 算法要求所有成本必须不小于1。 有时候可能会感觉在某些地方，寻路实体好像不会直接走最短路径。究其原因在于网格结点的放置位置。在空旷的地方有一个非常小的障碍物，这就会导致产生一大一小的网格。在这种情况下，网格结点可以放置在网格的任何地方，所以在我们看来，寻路实体好像并没有走最短路径。 当某区域网格有多种寻路代价时，寻路网格一般优先使用寻路代价最低的那种。当然也有例外，不可行区域的寻路代价虽然为1，但优先使用该种区域，用于阻挡寻路实体移动**。 官网文档：https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AreasAndCosts.html 注：图中的寻路路径绘图（黄线）的显示方法是在hierarchy面板点击寻路角色，在Scene场景勾选如上图几项即可。 自动生成离网链接有些时候我们需要自动生成离网格链接。链接的类型有两种：爬梯跳台式和跳跃跨栏式。 跳台式一般运用于高低平台之间的转换（跳下某平台）跳跃跨栏式主要在跳跃过某个缺口。 具体流程： 在Bake面板设置两个参数： 解释： Drop Height：跳台式链接需要设置下落的高度。高度为0时，无法跳落。 Jump-Across：可以跳跃的距离。跳跃的距离为0时，无法眺落。（最小值=寻路实体半径+始终点距离，且最小值要大于代理半径的二倍。） 设置完成后点击Bake： 注：生成的分离网格链接只能从上往下移动，如果需要从下往上则需要使用手动分离网格链接。 官网链接：https://docs.unity3d.com/2017.4/Documentation/Manual/nav-BuildingOffMeshLinksAutomatically.html 离网链接与动画系统可以注意到，当演示中的胶囊体/Cube通过离网链接时都是一瞬间完成的，但在实际游戏中，人物的攀爬和跳跃都是有动作的，如果需要在通过离网链接点的时候有人物动作，需要把人物的Auto Traverse Off Mesh Link选项关掉，然后写对应的控制人物状态的脚本，具体可以看：https://blog.csdn.net/elyxiao/article/details/51281602 ，在文章最后作者介绍了如何在通过离网链接点时执行动画。 Hight mesh由于NavMesh是可行走空间的近似值，因此会忽略一些细节。例如，人物在通过楼梯时并不会出现上下颠簸的感觉，如果需要增加NavMesh的真实度，需要将Navigation-Bake-Advanced settings下的Hight mesh选项打开，当然开启Hight mesh会增加CPU和内存的开销，并且烘焙时间会变长。 原文： While navigating, the NavMesh Agent is constrained on the surface of the NavMesh. Since the NavMesh is an approximation of the walkable space, some features are evened out when the NavMesh is being built. For example, stairs may appear as a slope in the NavMesh. If your game requires accurate placement of the agent, you should enable Height Mesh building when you bake the NavMesh. The setting can be found under the Advanced settings in Navigation window. Note that building Height Mesh will take up memory and processing at runtime, and it will take a little longer to bake the NavMesh. 官方文档：https://docs.unity3d.com/2017.4/Documentation/Manual/nav-HeightMesh.html 对障碍物的补充1.一个物体不能同时开启NavMeshAget和NavMeshObstacle,但是可以在运行时实时修改其开关。同时开启会产生角色躲避自己的冲突。如果再同时的开启的基础上启用Carve，会出现更多的异常行为。 效率// high-level NavMesh building components// 官方文档：https://docs.unity3d.com/2017.4/Documentation/Manual/NavMesh-BuildingComponents.html 使用下面的几个例子是我作为熟悉导航系统练习写的，想看标准的演示可以点击Windows-Navigation-Bake面板中的蓝色文本下载官方Demo。 链接：https://github.com/Unity-Technologies/NavMeshComponents 静态场景：（1）首先将场景内的障碍物包括地板设置为Static（如图中的四面墙，黄色的cube以及绿色的地板）： 注意NAvigation Static要确定被勾选： （2） 打开Navigation面板（window-Navigation），点击Bake： 点击Bake后场景会显示可通过的区域： （3） 在需要寻路的物体(角色)上添加Nav Mesh Agent组件，并添加自定义的物体行走组件，通过调用NavMeshAgent中的SetDestination方法使物体寻路，例如: 1_agent.SetDestination(tar); （4）效果如下（途中的路径红线显示要自己添加，具体角色的行走和绘图实现方式可以在Demo中找到对应脚本）： 动态场景：NavMesh同时也支持动态规划路线，如果寻路过程中动态出现障碍可以重新规划路线，NavMesh对动态规划支持不好，相比插件的动态寻路，NavMesh差的很多。（1） 先按照静态场景的流程走一遍，注意活动的障碍物不要标记为Static： （2） 在动态运动物体上添加 Nav Mesh Obstacle组件。 （3）效果如下： 如果发现角色寻路困难，会在动态障碍物前停滞，可以更改Agent Radius的值来修改障碍物的半径，通过调大障碍物的占地面积让角色行走更流畅，或修改代理的自身半径： 离网链接场景：有的时候场景中会出现一些传送点，跳跃点，如果需要在寻路时将传送点也包括在寻路计算内，则需要添加Off-Mesh-Line组件。1.准备两个cube，分别命名为Start和End。作为传送点：2.在Start的cube上添加Off-Mesh-Line组件，在Start和End属性添加对应的两个Cube（Start和End）：3.若添加成功则传送点上会出现黑色的线：4.可以看到现在代理在寻路时会将跳跃点计算在内： 区域寻路场景有时可能会用不到Bake整个场景的地图，只生成局部的NavMesh就够了，比如RPG游戏中玩家在可见区域选路，其他地方被战争迷雾覆盖，无法自动前往。这时需要生成局部的NavMesh并实时刷新。\1. 新建一个空物体，添加Local Nav Mesh Builder，Size为需要实时计算的NavMesh大小，并在Tracked位置填写需要使用局部网格的角色。 为场景内的障碍物，地形添加Nav Mesh Source Tag组件。 3.像其他场景一样为角色添加代理组件。 4.效果（不需要在Editor时Bake）： 有寻路代价的场景如果想让干预代理决定两条路该走哪条，比如走沼泽会扣血而草地不会，可以为行走区域添加代价1.添加路径需要的代价，默认是1，小于1的区域表示代价比标准低，大于1代表比标准代价高。2.将行走区域修改为对应图层3.对应区域设置好后，点击Bake，如图。4.现在代理寻路时会考虑代价花费，倾向于花费低的路线。]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuaInterface简介]]></title>
    <url>%2F2019%2F12%2F11%2FC%E5%92%8CLua%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[LuaInterface https://www.cnblogs.com/sifenkesi/p/3901831.html 一 介绍二 使用1.C#中调用Lua下载LuaInterface。下载地址 里面有两个文件：lua51.dll，LuaInterface.dll 新建c#控制台，添加引用（引用右键-添加引用）： c#： 12345678910111213141516171819202122232425262728293031323334353637383940using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using LuaInterface;namespace LuajinterfaceTest&#123; class Program &#123; static void Main(string[] args) &#123; // 新建一个Lua解释器，每一个Lua实例都相互独立 Lua lua = new Lua(); // Lua的索引操作[]可以创建、访问、修改global域，括号里面是变量名 // 创建global域num和str lua["num"] = 2; lua["str"] = "a string"; // 创建空table lua.NewTable("tab"); // 执行lua脚本，着两个方法都会返回object[]记录脚本的执行结果 lua.DoString("num = 100; print(\"i am a lua string\")"); object[] retVals = lua.DoString("return num,str"); // 访问global域num和str double num = (double)lua["num"]; string str = (string)lua["str"]; lua.DoFile("E:\\Personal\\Test_Personal\\LuainterfaceTest\\LuajinterfaceTest\\LuajinterfaceTest\\testLuaInterface.lua"); Console.WriteLine("num = &#123;0&#125;", num); Console.WriteLine("str = &#123;0&#125;", str); Console.WriteLine("width = &#123;0&#125;", lua["width"]); Console.WriteLine("height = &#123;0&#125;", lua["height"]); Console.ReadLine(); &#125; &#125;&#125; Lua： 123local width = 99999local height = 888888print("fuck") dofile使用相对路径？？ 1.1 LuaInterface与CLR类型对应 LuaInterface CSharp nil null string System.String number System.Double boolean System.Boolean table LuaInterface.LuaTable function LuaInterface.LuaFunction 其他类型传给lua会被视为是userdata。lua将userdata传给c#时还会是原来的数据结构。 *LuaTable和LuaUserData都有索引操作[]，用来访问或修改域值，索引可以为string或number。 LuaFunction和LuaUserData都有call方法用来执行函数，可以传入任意多个参数并返回多个值。* 1.2 使用Luainterface的一些问题（1）异常：混合模式程序集是针对“v2.0.50727”版的运行时生成的，在没有配置其他信息的情况下，无法在 4.0 运行时中加载该程序集。 解决办法： 在App.config文件中添加如下配置节： 123&lt;startup useLegacyV2RuntimeActivationPolicy="true"&gt; &lt;supportedRuntime version="v4.0"/&gt;&lt;/startup&gt; 2.Lua中调用C第一种是纯lua中进行测试： 2.1 获取类，访问构造函数在c#工程中测试： luanet.load_assembly函数：加载CLR程序集（程序集的名字在工程右键属性可以看到）； luanet.import_type函数：加载程序集中的类； luanet.get_constructor_bysig函数：手动匹配某个构造函数 Lua代码： 12345678910111213-- 加载自定义类型，先加载程序集，在加载类型luanet.load_assembly("LuajinterfaceTest")TestClass = luanet.import_type("LuajinterfaceTest.TestClass2")obj1 = TestClass(2, 3) -- 匹配public TestClass2(int n1, int n2)obj1:PrintSomthing()obj2 = TestClass("x") -- 匹配public TestClass2(string str)obj3 = TestClass(3) -- 匹public TestClass2(string str)TestClass_cons2 = luanet.get_constructor_bysig(TestClass, 'System.Int32')obj3 = TestClass_cons2(3) -- 匹配public TestClass2(int n) 注意先执行构造函数再进行方法调用 2.2 访问对象的字段和方法123456-- 加载自定义类型，先加载程序集，在加载类型luanet.load_assembly(&quot;LuajinterfaceTest&quot;)TestClass = luanet.import_type(&quot;LuajinterfaceTest.TestClass2&quot;)obj1 = TestClass(2, 3) -- 匹配public TestClass2(int n1, int n2)obj1:PrintSomthing() 访问对象的字段和table一样：button.Text… button[“Text”] 访问对象就是obj1:PrintSomthing() 2.3 重载方法的匹配luanet.get_method_bysig 12 setMethod=luanet.get_method_bysig(obj,&apos;setValue&apos;,&apos;System.String&apos;)&quot; setMethod(&apos;str&apos;) Luainterface匹配重载方法（包括构造函数）的规律是自动匹配第一个能够匹配的方法（构造函数） LuaInterface匹配第一个能够匹配的构造函数，在这个过程中，numerical string（数字字符串）会自动匹配number，而number可以自动匹配string，所以TestClass(3)匹配到了参数为string的构造函数。 out和ref参数的方法，参数和方法返回值同时返回。out参数不需要传入。 12345-- calling int obj::OutMethod1(int,out int,out int) retVal,out1,out2 = obj:OutMethod1(inVal) -- calling void obj::OutMethod2(int,out int) retVal,out1 = obj:OutMethod2(inVal) -- retVal ser´a nil -- calling int obj::RefMethod(int,ref int) 2.4 接口两个接口： IFoo.method()和IBar.method()，这种情况下obj[“IFoo.method”] 2.7事件，委托12345function handle_mouseup(sender,args) print(sender:ToString() .. ’ MouseUp!’) button.MouseUp:Remove(handler)endhandler = button.MouseUp:Add(handle_mouseup) add（）会将lua方法转换为CLR委托，并会返回这个委托。 2.6 扩展interface的方法太难了 等会再看吧 差一个c#调lua方法 lua报错输出 Lua中button.Text… button[“Text”]的区别 vscode控制台中文乱码https://blog.csdn.net/xjk2017/article/details/81388493 CLR 构造方法]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity下C#调用纯C动态链接库]]></title>
    <url>%2F2019%2F12%2F11%2FCandCSharpDll%2F</url>
    <content type="text"><![CDATA[链接库可以解决在项目中需要调用其他语言代码（如C/C++）的需求。库中保存了其他程序需要调用的方法。 注：C++下导出链接库和使用方法和C有区别 一 概述1.1 动态与静态链接库链接库分动态链接库（Dynamic-link library，简写DLL）以及静态链接库（Statically-linked library）。 区别动态链接库：在程序编译时，动态库中的函数代码不复制到可执行文件中，待程序需要调用库中函数时再进行加载。 静态链接库：程序编译时使用到的静态库会被打包到可执行文件中。 优势： 动态库只有在需要时才会加载，所以比静态库要节省内存，可扩展性强，同时减少了开发中的耦合度。 而静态库由于存在于执行文件中，所以代码的装载，执行速度要比动态库快。 劣势： 动态库的版本一旦出现异常，冲突，会引发DLL HELL问题。并且，动态库虽然节省内存，但调用方法的开销大，需要多次的间接访问才能调用到方法。 静态库生成的可执行文件体积较大，且代码无法共享。 1.2 不同系统下的链接库格式Windows：.dll（动态库），.lib（静态库） Linux（以及基于Linux的Android）：.so(动态库，share object)，.a（静态库） Mac：.a、.framework（静态库），.tbd，.dylib，.framework（动态库） 注：在Mac（iOS）系统下包含动态库的应用程序无法在Apple Store通过审核上架。详情：IOS静态库和动态库 1.3 P/Invoke P/Invoke又名平台调用，是.NET CLR提供的，为了使开发者从托管代码(如题主的C#)调用动态连接库中的非托管代码（通常是C）而提供的一种服务。 在受控代码与非受控代码进行交互时会产生一个事务（transition） ，这通常发生在使用平台调用服务（Platform Invocation Services），即P/Invoke 简单来说，就是P/Invoke为C#提供了调用其他语言代码的服务。 1.4 MinGW和Cygwin在生成Android使用的链接库时，需要使用Linux的编译工具，若想在Windows环境下使用Linux的编译工具（gcc/g++），则需要一个平台进行转换，也就是MinGW或Cygwin。 MinGW（ Minimalistic GNU for Windows），可被视为是Windows版本下的GCC，把代码中的LInux方式调用替换为对应的Windows调用方式。其中Msys子项目提供了一些模拟Linux的Shell和基础工具。 Cygwin 是在Windows平台上运行的unix模拟环境，Cygwin更像一个平台，模拟了Linux的接口，提供了运行在它上面的程序使用。 MinGW生成的程序，究其本质调用的是Kernel.32导出的标准Windows系统API，在windows下Mingw的编译性能会高一些，编译速度也会快一些。 Cygwin更像一个平台，它相对完整地模拟了LInux，提供了一个接近2M的Cygwin1.dll的文件作为目标库，来模拟Linux系统的接口，但是相对来说编译的速度就要慢一些。如果想要在Windows上开发可以运行在LInux上的程序，应该选用Cygwin。 资料:https://www.cnblogs.com/zoe-mine/p/7056369.html MinGW和Cygwin的安装请自行查看资料 二 Windows下的链接库调用2.0 准备环境VS2015，Dependency Walker（用于查看DLL中是否有写好的方法） 2.1 DLL项目2.1.1建立DLL项目 如果没有Win32，则需要下载模板 2.1.2文件介绍新建项目完成后，会有如下几个文件： （1）stdafx.h：用于包含标准系统包含的头文件，用户需要的其他标准头文件也写在这里。 （2）stdafx.cpp：和stdafx.h对应，用于对stdafx.h进行预编译处理所谓头文件预编译，把一个工程(Project)中使用的一些MFC标准头文件预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间,编译结果文件是projectname.pch,stdafx.cpp可以在C++项目中加快编译速度。如果不使用MFC可以将其删除。 （3） targetver.h：定义dll最高可以使用的windows版本 （4） dllmain.cpp：dll的程序入口点。 | DLL_PROCESS_ATTACH | 进程被调用，DLL被连接到当前进程并被初始化 || —————— | ——————————————- || DLL_THREAD_ATTACH | 当前进程创建一个新线程，DLL在新线程内被调用 || DLL_PROCESS_DETACH | 调用DLL的进程被终止，DLL被卸载 || DLL_THREAD_DETACH | 调用DLL的线程被终止，DLL被卸载 | 2.1.3 将DLL项目修改为C此时项目需要做一些操作，才能修改为纯C的DLL库。 （1）.将预编译头修改为：创建(/YC) （2）.修改为：编译为C代码（/TC） （3）.删除stdafx.cpp，将其他cpp文件后缀修改为.c。修改完如图（Ccallback，CFunction，Cstruct是我写好的.c，可忽略）： 2.1.4 编写C代码（1）编写方法，命名为CFunction.c 1234567891011121314151617181920212223242526272829303132333435// CFunction.cpp : 定义 DLL 应用程序的导出函数。//#include "stdafx.h"__declspec(dllexport) int NoArgReturnSth()&#123; printf("NoArgReturnSth()调用:\n"); return 99999;&#125;__declspec(dllexport) int Sum(int a , int b)&#123; printf("Sum(int a , int b)调用:\n"); return a + b;&#125;__declspec(dllexport) int SetNumZero(int* a)&#123; printf("int SetNumZero(int *a)调用：\n"); printf("int SetNumZero(int *a)调用,int a的内存位置：%d\n",a); *a = 0; return 1;&#125; __declspec(dllexport) int sendMessage(char* msg)&#123; printf("int sendMessage(char* msg)调用：\n"); int i = 0; for(;*(msg + i) != NULL;i++ ) &#123; *(msg + i) = *(msg + i) - 32; &#125; return 1;&#125; （2）编写方法，命名为CStruct.c 123456789101112131415161718192021#include "stdafx.h"typedef struct&#123; int osVersion; int majorVersion; int minorVersion; int buildNum; int platFormId; char szVersion[128];&#125;OSINFO;//（传递结构体指针）__declspec(dllexport) int SetVersionPtr(OSINFO *info)&#123; char * str = "Hello DLL"; info-&gt;osVersion = 100; printf("测试内容%d\n", info-&gt;majorVersion); strcpy(info-&gt;szVersion, str); return 1;&#125; （3）编写方法，命名为Ccallback.c 12345678910111213141516171819202122#include "stdafx.h"typedef int(*pfCallBack)(int a, char b[]);pfCallBack CallBackfun = NULL;char ch[100];__declspec(dllexport) void SetCB(int(*pfCallBack)(int a, char b[]))&#123; CallBackfun = pfCallBack;&#125; __declspec(dllexport) void callTheCB()&#123; int a = 4; memset(ch, '\0', 100); strcpy(ch, "aabbcc"); CallBackfun(a, ch);&#125; 注：printf方法需要在stdafx.h文件中添加#include “stdio.h”。 2.1.5 导出DLL（1）编译，编译成功后在项目的Debug目录下会有如下几个文件，（我的项目名字叫CFunctionw，所以生成的叫CFunction）： （2）检查DLL是否存在需调用的方法，下载Dependency Walker，安装后打开CFunction.dll： 可以看到有写好的方法，至此，DLL编写完成。 2.2 C#调用DLL库（简单的控制台Demo） （1）新建一个C#控制台项目。 （2）在Main方法中调用DLL： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Runtime.InteropServices;namespace ConsoleApplication1&#123; [StructLayout(LayoutKind.Sequential)] public struct OSINFO &#123; public int osVersion; public int majorVersion; public int minorVersion; public int buildNum; public int platFormId; [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)] public string szVersion; &#125; class Program &#123; //定义一个委托，其返回类型和形参与方法体的返回类型形参一致 //一定要加上这句，要不然C#中的回调函数只要被调用一次，程序就异常退出了 [UnmanagedFunctionPointer(CallingConvention.Cdecl)] public delegate int callBackHandler(int a, [MarshalAs(UnmanagedType.LPStr)]StringBuilder b); internal static void Main(string[] args) &#123; int a = 1; int b = 2; Console.WriteLine("------------------------------"); Console.WriteLine("DLL func execute:&#123;0&#125;", NoArgReturnSth()); Console.WriteLine("------------------------------"); Console.WriteLine("DLL func execute:&#123;0&#125;", SUM(a,b)); Console.WriteLine("------------------------------"); Console.WriteLine("修改前的a:&#123;0&#125;", a); Console.WriteLine("DLL func execute:&#123;0&#125;", SetNumZero(ref a)); Console.WriteLine("修改后的a:&#123;0&#125;", a); Console.WriteLine("------------------------------"); StringBuilder buf = new StringBuilder(2048); buf.Append("helloworld"); Console.WriteLine("传入字符串:&#123;0&#125;", buf); sendMessage(buf); Console.WriteLine("传出字符串:&#123;0&#125;", buf.ToString()); Console.WriteLine("------------------------------"); initStruct(); Console.WriteLine("------------------------------"); callBackHandler fun = new callBackHandler(localFun); SetCB(fun); callTheCB(); Console.WriteLine("------------------------------"); Console.Read(); &#125; //普通无参方法 [DllImport("CFunction.dll")] private static extern int NoArgReturnSth(); //有参int方法 [DllImport("CFunction.dll", EntryPoint = "Sum", CallingConvention = CallingConvention.Cdecl)] public static extern int SUM(int a, int b); //传入int指针方法 [DllImport("CFunction.dll", EntryPoint = "SetNumZero", CallingConvention = CallingConvention.Cdecl)] public static extern int SetNumZero(ref int a); //传入字符串指针方法 [DllImport("CFunction.dll", CallingConvention = CallingConvention.Cdecl)] public static extern int sendMessage(StringBuilder msg); //传入结构体方法 [DllImport("CFunction.dll", EntryPoint = "SetVersionPtr", CallingConvention = CallingConvention.Cdecl)] public static extern int SetVersionPtr(ref OSINFO info); //结构体初始化，并调用DLL方法。 public static void initStruct() &#123; IntPtr pv = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(OSINFO))); for (int i = 0; i &lt; 5; i++) &#123; Marshal.WriteInt32(pv, i * Marshal.SizeOf(typeof(Int32)), ((Int32)(i + 1))); &#125; OSINFO entries = (OSINFO)Marshal.PtrToStructure(pv, typeof(OSINFO)); entries.majorVersion = 999; if (SetVersionPtr(ref entries) == 1) &#123; Console.WriteLine("--osVersion:&#123;0&#125;", entries.osVersion); Console.WriteLine("--Major:&#123;0&#125;", entries.majorVersion); Console.WriteLine("--Minor:&#123;0&#125;", entries.minorVersion); Console.WriteLine("--BuildNum:&#123;0&#125;", entries.buildNum); Console.WriteLine("--szVersion:&#123;0&#125;", entries.szVersion); &#125; Marshal.FreeHGlobal(pv); &#125; //传入委托方法 [DllImport("CFunction.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void SetCB(callBackHandler fun1); //回调方法 [DllImport("CFunction.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void callTheCB(); //本地委托方法 public static int localFun(int a, [MarshalAs(UnmanagedType.LPStr)] StringBuilder b) &#123; Console.WriteLine("回调:&#123;0&#125;", b.ToString()); return 0; &#125; &#125;&#125; CallingConvention = CallingConvention.Cdecl 首先引入System.Runtime.InteropServices，然后导入DLL，格式为： 12[DllImport("dllname.dll"),EntryPoint = "functionname",CallingConvention = CallingConvention.Cdecl,]private static extern int functionname2(); [DllImport(“CFunction.dll”)]用于导入DLL。EntryPoint 、CallingConvention 是两个较常用的属性，EntryPoint 用于指定DLL中的方法名，如果DLL和C#中声明的方法名相同，则该属性可忽略。CallingConvention用于指定由哪一方负责处理堆栈，值Cdecl为调用方清理堆栈。 如果不使用CallingConvention，会提示：“C#调用C++DLL文件 报错调用导致堆栈不对称。原因可能是托管的 PInvoke 签名与非托管的目标签名不匹配”的错误。 1[UnmanagedFunctionPointer(CallingConvention.Cdecl)] UnmanagedFunctionPointe表示动态使用未托管的dll函数指针 CallingConvention.Cdecl：C调用约定（即用cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。_cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀，是MFC缺省调用约定；CallingConvention.StdDecl：stdcall调用约定相当于16位动态库中经常使用的PASCAL调用约定。在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为stdcall。除了pascal外，fortran和syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。_stdcall是Pascal程序的缺省调用方式，通常用于Win32Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上”@”和参数的字节数； 还有一些其他的属性，详情看：平台调用P-INVOKE(一)–(基础篇) 注意C#和DLL中的方法的返回值，参数个数、类型、顺序必须一致。方法名可以不一致。 （3）运行代码，控制台会输出对应方法及其返回值： 注：将DLL和用于调试的控制的控制台项目放入同一解决方案内，修改DLL的生成路径可以简化调试过程，避免每次生成DLL在拷贝到Debug目录中。 2.3在Unity下使用DLL （1）将DLL编译为64位，不然在Unity中会有关于32/64位的问题。为了测试方便，统一调整为64位。 （2）新建Unity项目，在Assets目录下新建Plugins文件夹，在Plugins文件夹下建立x86，x86_64文件夹。如图（忽略Android）： 之所以新建x86，x86_64文件夹是为了区分32/64位的DLL，直接拖到Plugins也可以。Plugins文件夹中若存在这两个文件夹，则dll必须放到两个文件夹中，否则会出现找不到dll的情况。（我的2017.4.16f1不存在这种情况。） （3）修改DLL的属性，将属性修改为和图片一致 （4）编写C#脚本： 123456789101112131415using System.Collections.Generic;using UnityEngine;using System.Runtime.InteropServices;public class NewBehaviourScript : MonoBehaviour &#123; [DllImport("CFunction")] private static extern int NoArgReturnSth(); int i = NoArgReturnSth(); void OnGUI() &#123; GUI.Button(new Rect(1, 1, 200, 100), i.ToString()); &#125;&#125; csharpcsharp随便拖到一个GameObject上，运行： 异常信息此报错只针对Windows，后面会有其他平台的异常信息。 （1）DllNotFoundException: 64位运行32位的DLL会报这个错。 （2）Failed to load ‘Assets/Plugins/xxx.dll’, expected x64 architecture, but was x86 architecture. You must recompile your plugin for x64 architecture.：DLL文件没有选择对应的CPU （3）EntryPointNotFoundException：EntryPoint没写的情况下就是C#方法名字和DLL名字对不上，写了就是EntryPoint没写对。 三 Android下的链接库调用下面介绍三种我用的，在windows下生成.so的方法。 3.1 通过NDK生成.so文件3.1.1 准备环境（1）配置好NDK，SDK，JDK以及环境变量。 （2）新建一个文件夹，将写好的.c，.h放入。新建Android.mk，Application.mk文件。 注：.c文件和.h文件的写法与DLL中稍有不同。 文件介绍： https://developer.android.com/ndk/guides/android_mk Android.mk：Android提供的一种makefile文件，用于引导生成.so。 Application.mk：androidNDK构建系统使用的一个可选构建文件，用于描述native模块。 3.1.2 配置文件（3）配置Android.mk： 1234567891011121314151617181920212223#指向一个编译脚本，由编译系统提供include $(CLEAR_VARS)#这个不太清楚 应该是处理器类型LOCAL_ARM_MODE := arm#当前文件路径LOCAL_PATH := $(NDK_PROJECT_PATH)#库名称LOCAL_MODULE := libnative# 表示用于 C 编译器的选项，Werror将所有的警告当成错误进行处理LOCAL_CFLAGS := -Werror#指定编译的源文件名称,LOCAL_SRC_FILES := NativeCode.c CFunction.c#允许打印LogLOCAL_LDLIBS := -llog#告诉编译器生成.soinclude $(BUILD_SHARED_LIBRARY) （4）配置Application.mk 1234567891011#优化选项 可选release/debugAPP_OPTIM := release#选择需要支持的cpuAPP_ABI := armeabi#支持的最低Android平台APP_PLATFORM := android-16#指定执行脚本APP_BUILD_SCRIPT := Android.mk 注：如果提示APP_PLATFORM版本过低，对应调高即可。 3.1.3 编译（5）打开命令行，cd到文件目录编译。 编译指令：ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk 编译后目录内会产生两个文件夹libs和obj，在libs的armeabi-v7a文件夹下会有我们编译好的libnative.so。 3.2 通过Cmake生成.so文件 3.2.1 准备环境我是通过装Android Studio来安装的以下配置，但实际上编译用不到AS。 （1）在Android Studio安装好LLDB，CMake，NDK。（NDK如果之前装过可以自行配置），LLDB，CMake也可以在官网下载单独安装。 （2）打开settings查看SDK和NDK的所在位置： 打开位置，我的是C:\Users\usename\AppData\Local\Android\Sdk，然后找到如下文件夹： 配置cmake和ninja的环境变量： 验证是否配置成功： 如图就是配置成功了。 （3）查看android.toolchain.cmake文件：在ndk所在的文件夹下，build-cmake-android.toolchain.cmake。该文件很重要，如果cmake目录下没有此文件，就去https://developer.android.com/ndk/guides/cmake.html下载。 （4）准备代码：随便找个地方新建一个文件夹，新建build，include，src文件夹，将.c放入src，.h放入include： （5）新建CMakeLists.txt，并输入如下内容： 12345678cmake_minimum_required(VERSION 3.6)file(GLOB native_srcs "$&#123;CMAKE_SOURCE_DIR&#125;/src/*.c")include_directories($&#123;CMAKE_SOURCE_DIR&#125;/include)#STATIC表示编译结果为静态库.a,如果想为动态库.so,可改为SHAREDadd_library(Add SHARED $&#123;native_srcs&#125;) target_link_libraries(Add) （6）在build文件夹下新建批处理文件build.bat，内容如下： 12345678set toolchain=C:/Users/wenmai/AppData/Local/Android/Sdk/ndk-bundle/build/cmake/android.toolchain.cmakeset android_ndk=C:/Users/wenmai/AppData/Local/Android/Sdk/ndk-bundleset build_type=Releaseset gernerator="Ninja"if not exist %1 md %1cd %1cmake ../.. -DCMAKE_TOOLCHAIN_FILE=%toolchain% -DANDROID_NDK=%android_ndk% -DCMAKE_BUILD_TYPE=%build_type% -DANDROID_ABI="%1" -DCMAKE_GENERATOR=%gernerator%ninja cmake ../..的意思是使用cmake交叉编译当前工程，并将-DCMAKE_GENERATOR指向了ninja.exe。%1运行.bat要传的参数,需要传Android ABI名称，如：arm64-v8a,armeabi armeabi-v7a mips,mips64,x86,x86_64。 （7）打开命令行，cd到build目录，输入：build.bat armeabi-v7a： 可以在 armeabi-v7a目录下看到生成了libAdd.so文件。 如果出现如下图所示的错误，可以先仔细检查配置文件是否写对，并且build.bat传入的参数是否正确： 3.3 使用Android Studio生成.so注：Android Studio在最近的版本中弃用了使用gcc编译器，改为使用Clang代替。 下面利用AS和NDK来生成so，Cmake也可以使用此方法，文字不再做介绍。 3.3.1 准备环境 （1）安装好Android Studio，确保可以正常运行。 （2） 界面位置：File-Settings-System Settings-Android-SDKTools 在AS中下载这些东西似乎需要翻墙，没有验证过。 文件介绍： CMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果您只计划使用 ndk-build，则不需要此组件。 LLDB：一种调试程序，Android Studio 使用它来调试原生代码。 3.3.2 项目配置（1）先新建一个项目，（我的叫FuckSO）。然后切换工程目录为Project，（默认是Android），然后打开Project Structure-SDK Location，确认ndk已经配置好。 （2）在gradle.properties中添加一句：android.useDeprecatedNdk=true。为了向后兼容 （3）在build.gradle文件下添加ndk，CMake节点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 28 defaultConfig &#123; applicationId &apos;com.example.hellojni&apos; minSdkVersion 23 targetSdkVersion 28 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; externalNativeBuild &#123; cmake &#123; version &apos;3.10.2&apos; path &quot;src/main/cpp/CMakeLists.txt&quot; &#125; &#125; flavorDimensions &apos;cpuArch&apos; productFlavors &#123; arm7 &#123; dimension &apos;cpuArch&apos; ndk &#123; abiFilter &apos;armeabi-v7a&apos; &#125; &#125; arm8 &#123; dimension &apos;cpuArch&apos; ndk &#123; abiFilters &apos;arm64-v8a&apos; &#125; &#125; x86 &#123; dimension &apos;cpuArch&apos; ndk &#123; abiFilter &apos;x86&apos; &#125; &#125; x86_64 &#123; dimension &apos;cpuArch&apos; ndk &#123; abiFilter &apos;x86_64&apos; &#125; &#125; universal &#123; dimension &apos;cpuArch&apos; // include all default ABIs. with NDK-r16, it is: // armeabi-v7a, arm64-v8a, x86, x86_64 &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:28.0.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.3&apos;&#125; （4）（如果不需要在Android Studio中调试此步骤可以跳过）在java目录下新建一个类，CCodeHelper。在静态代码中加载.c文件，并定义一个方法用于链接.c中的方法。 （5）在项目文件夹-app-src-main下新建cpp文件夹，并新建.c文件： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;jni.h&gt;#include &lt;string.h&gt;int Java_com_example_fuckso_CCodeHelper_magicMethod()&#123;#if defined(__arm__) #if defined(__ARM_ARCH_7A__) #if defined(__ARM_NEON__) #if defined(__ARM_PCS_VFP) #define ABI &quot;armeabi-v7a/NEON (hard-float)&quot; #else #define ABI &quot;armeabi-v7a/NEON&quot; #endif #else #if defined(__ARM_PCS_VFP) #define ABI &quot;armeabi-v7a (hard-float)&quot; #else #define ABI &quot;armeabi-v7a&quot; #endif #endif #else #define ABI &quot;armeabi&quot; #endif#elif defined(__i386__)#define ABI &quot;x86&quot;#elif defined(__x86_64__)#define ABI &quot;x86_64&quot;#elif defined(__mips64) /* mips64el-* toolchain defines __mips__ too */#define ABI &quot;mips64&quot;#elif defined(__mips__)#define ABI &quot;mips&quot;#elif defined(__aarch64__)#define ABI &quot;arm64-v8a&quot;#else#define ABI &quot;unknown&quot;#endif return 999999999;&#125; 注意方法的名字Java_com_example_fuckso_CCodeHelper_magicMethod，该方法与CCodeHelper中的方法对应。但多了Java_com_example_fuckso_CCodeHelper_，这是在Android项目中定义C/C++库方法的规则，规则为：“包名_类名_方法名”，在java类中直接使用方法名来进行调用。 但把so拿给unity使用时，必须要使用全名也就是Java_com_example_fuckso_CCodeHelper_magicMethod才能调用。 （如果不需要在Android Studio中调试，方法名随便写就可以。） （6）再和build.gradle同级别目录新建CMakeLists.txt，写入如下内容： 1234567891011121314cmake_minimum_required(VERSION 3.4.1)add_library( CNativeFunction SHARED app/src/main/cpp/CNativeFunction.c)find_library( log-lib log)target_link_libraries( CNativeFunction $&#123;log-lib&#125; ) （7）ctrl+F9 编译。编译成功后，会在FuckSO\app\build\intermediates\cmake\debug\obj下对应的cpu类型下找到.so文件。 3.3 Unity调用.so使用nm -D libNativeCode.so 来查看so中是否包含了写好的方法： 将.so拖入Assets-Plugins-Android文件夹。在属性面板修改库的相关设置： 然后新建C#脚本： 123456789101112131415161718using UnityEngine;using System.Collections;using System.Runtime.InteropServices;public class CallNativeCode : MonoBehaviour &#123; [DllImport(&quot;native&quot;)] private static extern int NoArgReturnSth(); int i = NoArgReturnSth(); void OnGUI () &#123; float x = 3; float y = 10; //GUI.Label (new Rect (15, 125, 450, 100), &quot;adding &quot; + x + &quot; and &quot; + y + &quot; in native code equals &quot; + add(x,y)); GUI.Label(new Rect(15, 225, 450, 100), i.ToString()); &#125;&#125; 拖拽到任意物体，这是Unity会报错：DllNotFoundException: native，此时不用理会，因为.so文件无论如何也无法在windows环境下调用。所以需要打包成apk在模拟器上运行，发布设置按图片中的对应即可： 安装APK运行，这时可以看到c#从.so调用了方法并返回了一个值： 需要注意的几点： [DllImport(“filename”)]，filename不要写lib前缀以及.so后缀，如例子中生成的.so叫libnative.so，DllImport引入时只需写native。（强制规定） 如果在模拟器中依然出现DllNotFoundException异常，会有几种情况： 1.发布APK时对应的.so库位数不一致；2.DllImport没有找到.so库；3.找到了.so库但是没有找到对应的方法。 Win32Exception提示apksigner.bat找不到，我的SDK最高API是26，但是26的文件夹下没有apksigner.bat。临时的解决办法是删除26版本。（把文件夹删除） CommandInvokationFailure: Gradle build failed。解决办法：Unity编辑器 File-&gt;Build Setting-&gt;Android-&gt;Build System选择Internal 四 多平台适应 打包出Android在模拟器运行太麻烦，可以通过配置多平台的链接库实现平台自适应。首先准备好各平台的链接库，然后在 File-&gt;Build Settings-Switch Platform进行平台转换。 适配代码如下： 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;using System.Runtime.InteropServices;public class NewBehaviourScript : MonoBehaviour &#123;#if UNITY_STANDALONE_WIN const string fcuk = &quot;CFunction&quot;;#else const string fcuk = &quot;native&quot;;#endif [DllImport(fcuk)] private static extern int NoArgReturnSth(); void OnGUI() &#123; int i = NoArgReturnSth(); GUI.Button(new Rect(1, 1, 200, 100), i.ToString()); &#125;&#125; 五 备注文档中没有写关于如何生成静态库的方法，但其实和生成动态库是一样的只是参数不同。 生成Android可以使用的.so文件的方法不止文中写的这些，但需要注意的是有些方法生产的so库只能在Linux下使用，如利用VisualGDB和Linux虚拟机交叉编译生成的.so库（使用Visual Studio创建Linux库），以及在windows环境下利用gcc编译出obj再转化为.so库的方法。 C++的链接库生成，和语法以及一些细微的差别在文中没有介绍。 .dll和.so的方法参数以及传参各有不同，具体区别下篇文档再做说明。可以先看看： C#调用C/C++ DLL 参数传递和回调函数的总结 C#调用C/C++动态库 封送结构体，结构体数组 文中部分资料摘自： 微软官方资料：创建和使用你自己动态链接库 （c + +） C语言中文网： C中函数指针简介及其用法 阿里云社区：C#调用C/C++ DLL 参数传递和回调函数的总结 C#调用C/C++动态库 封送结构体，结构体数组 C#调用C函数(DLL)传递参数问题 平台调用P-INVOKE(一)–(基础篇) CallingConvention理解 ［科普小短文］在C#中调用C语言函数 Visual C++ 2010 Express Tips: 用 C 和 C++ 创建动态链接库 动态库和静态库的区别 VS2017编写纯C库以及使用C#调用C库方法 VS2015_动态链接库学习 用VS2010将C程序做成动态链接库dll VS2015设置DLL和LIB的输出目录 Android中IDE、ADT、SDK、JDK、NDK的含义解释 ABI： abiFilters 详解 介绍linux/windows OS下静态库（.a、.lib）和动态库（.so、.dll）的 link &amp; load]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>Unity</tag>
        <tag>C</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp笔记]]></title>
    <url>%2F2019%2F12%2F11%2FCSharp%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[iOS的SDK接入流程 基础笔记 一 .net框架1.2 .net框架构成 CLR：Common Language Runtime 公共语言运行库 BCL：Base Class Library 基础类库 （或者称为框架类库 Framework Class Library ， FCL） 自己写程序时可以调用BCL 1.3编译成CIL 使用编程语言写好的文件需要使用编译器生成程序集文件，程序集文件只能是可执行的，或者是DLL。并且程序集中的不是本机代码，而是CIL（Common Intermediate Language）公共中间语言的中间语言。 和CIL有关的还有IL和MSIL 不过已经很少用到了 1.4编译成本机代码并执行CIL被调用运行时才会被编译成本机代码。 （先检查程序集的安全特性） JIT: Just-in-Time 实施编译器 程序集中的可执行代码只有在需要时才会有JIT编译，编译后被缓存起来以备后面的程序执行。不被调用的代码将不会被编译。并且被调用的代码只编译一次。 CIL被JIT编译为本机代码后，在运行时会被CLR管理，执行GC检查数组边界参数类型异常管理的任务。 托管代码managed code：.net编写的代码成为托管代码。 非托管代码 unmanaged code：不在CLR控制之下的代码，如Win32，C/C++ DLL。 Ngen工具可以将程序集转换成当前处理器的本机代码。Ngen处理过的代码可以面去运行时的JIT编译过程。 CLRCLR是核心组件， 可以看到，非托管代码CLR不提供服务。 CLICLI （Common Language Infrastructure,公共语言基础结构）一组数据结构 系统标准 CLI的重要组成部分是： 1.CTS（COmmon Type System 公共类型系统）定义了托管代码中一定会使用的类型特征。.net兼容的编程语言的类型通常会映射到CTS中已定义的类型。 CTS最重要的特征是，所有类型都继承公共的基类 object 使用CTS可以确保系统类型和用户定义类型能被任何.net兼容的语言所使用 2.CLS（COmmon Language Soecification公共语言规范）详细说明了.net兼任语言的规则和行为，包括参数传递，类结构，数据类型。 c#的演化可以单独说一下 二csc HelloWord.cs 命令行启动csc C#编译器对文件进行编译。 1.有的没的标识符： 关键字： 上下关键字是仅在特定语言结构中充当关键字的标识符。上下文关键字可以在代码的其他部分被用做标识符。 块： 大括号包围的多条语句和序列，在语法上相当于一条语句 用途： 语法上只需要一条语句，但执行的动作无法用一条简单语句表达。 有一些特定的程序结构只能使用块，哪些结构？？ 块后面不跟分号 WriteLine {0} {1} 这叫替换值 1Console.WriteLine("aaaa &#123;0&#125; and &#123;1&#125;",3,6); 也可以： 1Console.WriteLine("aaaa &#123;0&#125; and &#123;1&#125;",3,6); 不要试图引用替换值长度列以外位置的值，比如{2} 格式化数字字符串 这{1：C}叫格式说明符或者对齐说明符 格式说明符如： 1Console.WriteLine(&quot;aaaa &#123;0:C&#125;&quot;,3); 对齐说明符如： 1Console.WriteLine(&quot;aaaa &#123;0,10&#125;&quot;,3); 负数表示左对齐 1Console.WriteLine(&quot;aaaa &#123;0:F4&#125;&quot;,3.123); 像这种就表示显示四位小数点。 格式说明符可以去查表 文档注释 123///&lt;summary&gt;///这是说明///&lt;/summary&gt; 文档注释包含XML文本，可以生成程序文档，25章会讲。 三c是一组函数和数据类型，c++是一组函数和类，但是c#的程序是一组类型声明。 C#程序或DLL源代码是一组类型声明 Main方法当然也是必须的。 命名空间是一种把相关的类型声明分组并命名的办法。 1234567891011121314namespace Game&#123; DeclarationOfTypeA DeclarationOfTypeB class C &#123; static void Main() &#123; &#125; &#125;&#125; 三个类型被声明在Game命名空间中。命名空间会在21章讲。 类就是一个模板，它本身并不是数据结构，但他说明了由模板构造的对象的特征。 BCL或者其他库也会提供一些类。 类里面的叫数据成员和函数成员。 预定义类型和C/C++不一样，c#数字不具有布尔意义。 16中预定义类型： c#的类型名称就是.net类型的别名。.net类型可以在c#中使用（不推荐）。 用户定义的类型： 预定义类型可以直接用，如int。用户定义类型必须先声明后实例化。 堆和栈栈是内存数组， 堆是一块内存区域，GC会自动清除堆对象。 类型决定了对象的存储位置。 类型有两种：值类型和引用类型。值类型存放在栈里。 引用类型需要两端内存，一个存实际的数据，在堆中。另一个存引用，指向堆的存放位置，可能在堆中也可能在栈中。 对于一个引用类型，其实例数据部分始终存放在堆里 无论值还是引用 int var ， float var1这种是不可以的 stirng是引用类型 dynamic关键字的类型在运行时才会被解析。 四字段是数据成员 方法是函数成员 c#和c++不同，不能再类型的外部声明全局变量。所有的字段都属于类型。也没有全局方法（在类型的外部)。 不带修饰符默认私有成员 五方法体也是个块 var关键字不是特定类型变量的符号，只是语法速记。表示可以从右侧推断出类型。 var只能用于本地变量，不能用于字段，只能在变量声明中包括初始化时使用，一点推断出类型则是固定不可更改的。 和js的var不一样。 本地变量的生存周期只在块里，直到声明他的那个块的尾部结束。 c#和c++不一样 不允许在第一个有效范围内声明另一个同名本地变量。 const 关键字不是修饰符，是核心声明的一部分必须放在类型前面。 const必须在声明时初始化，且后面不能改变。 const 必须有初始化语句。 const也可以是null引用，但不能是某个对象的引用，因为对象的引用实在运行时决定的。 return； 这种只能用在void方法。 实参可以隐式转换为形参 几种参数类别 值参数是把实参的值复制给形参。所以会复制引用，对于值类型会复制值。实参同时必须是变量，在用作实参前必须被赋值。如果是引用需要复制引用或者null 值参数系统在栈上为形参分配内存。 12345void MyMethod（ref int val）｛...｝int y = 10；MyMethod（ref y）； 引用参数，声明和调用都使用ref修饰符。实参同时必须是变量，在用作实参前必须被赋值。如果是引用需要复制引用或者null 必须是变量的意思是 xxx(ref 3+4)这种是不可以的。 引用参数不会在栈上分配内存，实际上，形参的参数名作为了实参变量的别名。指向相同的内存位置。 所以改了形参，实参也会变。 引用类型作为值参数和引用参数 无论是值参数还是引用参数，都可以在方法内部修改它的成员。但实质上还是有区别的： 1.作为值参数传递：如果在方法内创建一个新对象并赋值给形参，实参和形参的关联会切断。 方法调用结束后，新对象也就不在了。 2.作为引用参数传递，如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。 输出参数 输出参数用于方法体内把数据传出到调用代码。 必须在声明和调用中都使用out修饰符。 实参同时也必须是变了，不能是其他类型的表达式，因为方法需要内存位置保存返回值。 12345void Method(out int val)&#123;&#125;int y = 10;Method(out y) 和引用参数相似，形参担当实参的别名，实参和形参是同一块内存。所以对形参的更改会改变实参。 输出参数有几个要求： 在方法中，输出参数在能够被读取前必须被赋值。这意味着参数的初始值是无关的，并且没必要在方法调用之前为实参赋值。 在方法返回前，内部贯穿的任何可能路径都必须为所有输出参数进行一次赋值。 此外，因为在方法内读取输出变量之前必须对其写入，所以不可能使用输出参数把数据传入方法。如果在赋值之前试图读取他，编译器会有错误信息。 参数数组 允许零个或多个实参对应一个特殊的形参，有几个要求： 1.参数列表中只能有一个参数数组。并且是最后一个 2.参数数组表示的所有参数必须有相同的类型。 声明参数数组必须做的事： 1.数据类型前使用params修饰符。 2.放一个方括号 1void ListInts(params int[] invals) 参数数组是一个数组，数组是引用类型，所以所有数据都保存在堆中。 可以通过两种方式给参数数组传参： 1234ListInts（10,20,30）；int[] intarray = &#123;1,2,3&#125;;ListInts（intarray）; params修饰符不需要再调用时使用。 如果对应的形参数组没有实参，编译器会创建一个有零个元素的数组使用。 当数组在堆中被创建时，实参的值是被复制到数组中，像值参数。 如果数组是值类型，则值被复制，实参不受方法内部影响。 如果数组是应用类，那引用被复制，实参可能会收到方法内部影响。 数组作为实参 数组作为实参传递，便一起会使用实参数组而不是创建新的 重载 重载必须有和其他方法不一样的签名 签名包括：方法名称，参数数目，参数数据类型和顺序，参数修饰符。 返回类型不是签名的一部分，形参的名称也不是签名的一部分。 命名参数 之前用的都叫位置参数。 named parameter只要指定参数的名字，就可以任意顺序在方法调用中列出实参。 1Method（c:2,a:4,B:3）; 可以同时使用位置参数和命名参数，但位置参数必须先列出来。 可选参数 optional parameter 表明某个参数是可选的，需要在方法声明时为参数提供默认值。 不是所有的参数类型都可以作为可选参数： 只有值类型的默认值可以在编译时确定，才可以将值类型作为可选参数 只有默认值是null的时候引用类型才可以作为可选参数使用 所有必填参数必须在可选参数声明之前声明。如果有params参数必须在所有可选参数之后声明。 1｛intx,decimal y ...int op = 19,double op2 = 32; ... params int[] intVals｝ 省略参数必须在最后开始，也就是说不能前面省略，后面不省略。 如果需要随意省略可选参数，必须使用命名参数的特性来实现，使用可选参数的名字来消除歧义。 栈帧 调用方法时内存从栈的顶部开始分配，保存和方法关联的数据项。这块内存叫栈帧stack frame 栈帧包括如下内容： 返回地址，方法退出时继续执行的位置。 方法的值参数，或者参数数组。 和方法调用相关的其他数据管理项。 递归的调用会产生很多不同的独立栈帧。 （递归为什么会产生不同的独立栈帧？？） 六类成员类型有9种 声明类成员的方式： [][] [特性] [修饰符] 核心声明 顺序必须是这个。多个特性和多个修饰符内部可以顺序随意，但整体上必须是这个顺序。 静态字段被类的所有实例共享，所有实例都访问内存同一位置。 static和const是不一样的 如果静态字段有初始化语句，那会在使用任何静态成员之前初始化该字段。但是不会在程序执行开始就初始化。 静态方法不能访问实例成员，但是能访问其他静态成员。 静态的成员当然也是在堆上。 成员常量不能被声明为静态的。 成员常量和本地常量差不多。同时成员常量的值必须是编译时可计算的。 和静态量不同，常量没有自己的存储位置，而是在编译时被编译器替换，类似于c和c++的define。 属性 它是命名的类成员 它不为数据存储分配内存 和字段不同，它执行代码 set 和 get访问器有预定义的语法和语义。set有一个隐式的值参数value，返回类型是void。get没有参数，且get所有路径必须包含一条return语句，返回和属性相同的类型。 属性上不允许有除了get和set以外的其他方法。 访问器不能显示调用。 属性可以是只读或者只写的。 属性和公共字段 属性是函数性成员，不是数据成员允许处理输入输出。公共字段不行。 属性可以只读或者只写，字段不行。 编译后的变量和编译后的属性语义不同。 自动实现属性（有什么意义？） 允许只声明属性而不声明后备字段。编译器会创建隐藏的后备字段，并自动挂接到get和set访问器上。 eg： 1234public int MyValue&#123;set; get;&#125; 自动属性使开发者在倾向于声明一个公有字段的地方很容易的插入一个属性 （插入一个问题 1-6章什么时候讲了修饰符 private protect public这些东西了） 静态属性：不能访问实例成员，只能被实例成员访问。不管有没有实例都是存在的。外部访问使用类名。 实例构造函数 构造函数声明为public可以从类的外部创建实例 构造函数没有返回值 构造函数可以被重载 如果用户声明了任何构造方法，则编译器不会提供默认的构造方法。 构造方法可以声明为static， 用于初始化类级别的项，静态字段这种。 类中只能有一个静态构造函数，而且不能带参数 静态构造函数不能有任何访问修饰符。 静态构造函数和静态方法一样，不能访问实例成员，因此不能使用this访问器 不能从程序中显示调用静态构造方法，系统会自动调用它： 引用任何静态成员之前，创建类的任何实例之前。 对象初始化有两种 new xxx() new xxx(){在此初始化设置公有字段的值} 大括号里就是初始化 第二种也叫对象初始化语句 扩展了对象创建的语法 需要注意，初始化发生在构造方法执行之后，因此构造方法中设置的值可能会在之后对象初始化中重置为相同或不相同的值。 析构函数 destructor 析构函数具体在后面讲 执行类的实例被销毁之前需要的清理或释放非托管资源的行为。 非托管资源是指通过win32api获得的文件句柄 如果坚持使用。net类就不用编写析构方法 readonly修饰符 字段可以用readonly修饰符声明 作为类似const 一旦值被设定就不能改变。 但有一些却别： const字段只能在声明语句中初始化，readonly可以在 声明语句和任何构造函数中初始化。如果readonly的字段是static的则需要在静态构造函数中初始化。 const字段的值必须在编译的时候决定，但readonly可以在运行时决定。也就是说可以在不同的构造方法中设置不同的值。 const的行为是静态的，readonly是实例字段，也可以说静态字段，在内存中有存储位置 this关键字 在类中使用，对当前实例的引用。只能被用在 实例构造函数、实例方法、属性和索引器的实例访问器 不能再静态方法中使用this this的目的是区分累的成员和本地变量或者参数，或者作为调用方法的实参。 索引器 和属性差不多： 和属性意义，不用分配内存来存储 索引器和属性都是主要被用来访问其他数据成员 属性通常表示单独的数据成员 索引通常表示多个数据成员 索引器不能被声明为static 需要注意： 索引器没有名称，在名称的位置关键字是this 参数列表再方括号中间 参数列表至少声明一个参数 索引器的set访问器接受两项数据：1.隐式参数value持有要保存的数据，2.一个或更多索引参数表示数据应该保存到哪。 get、访问器必须检查索引参数确定他表示那个字段，并返回字段值。 补充 set和get是不能显示调用的，当索引器在表达式中取值时将自动调用get 赋值时自动调用set emp[0] = “q”; string name = emp[0]; 例子 12345678910111213141516171819202122class Empolyee&#123; public string LastName; public string FirstName; public string City; public string this[int index] &#123; set&#123; switch(idnex)&#123; case 0:lastName = value; break; ... default: throw new ArgumentOutOfRangeexception("index"); &#125; &#125; get&#123; case 0:return LastName; break; ... default: throw new ArgumentOutOfRangeexception("index"); &#125; &#125;&#125; 12345678910111213141516171819class Class1&#123; int tmp1; int tmp2; public int this[int index] &#123; get&#123; return (0 == index) ? tmp1 :tmp1; &#125; set&#123; if(0 == idnex) tmp1 = value; else tmp2 = value; &#125; &#125;&#125; 索引器可以重载，一定要保持有不同的参数列表。 123456789101112131415161718192021222324class Class1&#123; int tmp1; int tmp2; public int this[int index] &#123; get&#123; ... &#125; set&#123; ... &#125; &#125; public int this[int index，int index] &#123; get&#123; ... &#125; set&#123; ... &#125; &#125;&#125; 访问器的修饰符 看好了 是访问器 不是索引器 属性和索引器是函数成员，并自带了get和set索引器 可以对get和set设置不同的访问级别 可以用于在对象的外部，只能读取该属性 是一个非常重要的封装工具 但要注意 必须同时有gat和set访问器时，访问器才能有修饰符，并且只能有一个访问修饰符 访问器的修饰符必须比成员的级别更严格。 也就是访问器的访问级别必须要比成员的访问级别的位置低，也不能等于属性的访问级别 访问级别： public –&gt; protected ——&gt;protected——–&gt; private ​ internal———-&gt;internal———–&gt;private 分部类和分部类型： 分部类可以生命在不同或相同的文件中 ，局部声明要被标注为partial class。 partial不是关键字，在程序中可以用于标识符。但在class struct（局部结构） interface（局部借口）前它表示分布类型。 分部方法： 分布方法是声明在分部类中不同部分的方法，也可以声明在同一个类中 分为两个部分： 定义分布方法声明：给出签名和返回类型，声明的实现部分知识一个分号。 实现分部方法声明：给出签名和返回类型，是以正常形式的语句块实现。 需要注意的内容： 定义和实现的签名和返回类型必须匹配。返回类型必须是void，签名不能包括访问修饰符，也就是说分部方法是私有的，列表不能包含out参数。定义和实现必须包含上下文关键字partial，直接放在关键字void之前。 可以有定义而没有实现 编译器会把方法的声明以及方法内部任何对方法的调用移除。 例子： 12345678910111213141516171819public class Myclass&#123; partial void PrintSum(int x , int y); public void Add(int x, int y) &#123; PrintSum(x,y); &#125;&#125;partial class Myclass&#123; partial void PrintSum(int x, int y) &#123; console.writeLine("xxx:" , x +y); &#125;&#125; 七已存在类的成为基类 (base class) 新类叫派生类derived class 要声明一个派生类，类名后要加入基类规格说明 就是冒号+基类 派生类被描述为直接继承自列出的基类 所有类都派生自object类 即时没有任何基类规格说明(继承)的类 object是唯一的非派生类 它是继承层次结构的基础 没有基类规格说明的类隐式派生自object c#是单继承 但继承的层次没有限制 屏蔽基类成员 无法删除父类的任何成员 但是可以通过声明和父类一样名字的成员来屏蔽（mask）基类成员： 1.声明一个相同名称相同类型的成员 2.屏蔽方法需要在派生类中声明新的带有相同签名的函数成员。 签名是有名称和参数列表组成，不包括返回类型。 3.使用new修饰符告诉编译器正在故意屏蔽继承的成员，否则程序会成功编译但会警告你隐藏了一个继承的成员。 比如： 12345678class Someclass ｛ public string a; ｝class someclass2&#123; new public string a;&#125; 可以使用基类访问（base access）表达式访问隐藏的继承成员。 1Console.WriteLine("&#123;0&#125;" , base.a); (屏蔽基类成员再使用基类访问并不是好的设计方式) 7.6使用基类的引用派生类的实例由基类的实例加上派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分。 虚方法和覆写方法基类引用调用派生类（derived class）方法： 1.派生类的方法和基类的方法有享用的签名和返回类型 2.基类的方法使用virtual标注 3.派生类的方法使用override标注 （注意此方式和new隐藏基类成员在行为上的区别。） 这样就实现了基类方法调用了子类中的方法 需要注意： 1，覆写和被覆写的方法必须具有相同的可访问性。 2.不能覆写static方法或非虚方法 （override的其他用途？） 3.方法，属性，索引器，以及事件，都可以被声明为virtual和override 覆写标记为override的方法]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
</search>
