<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSharp基础8 泛型</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%808%20%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>枚举相关内容</p>
<p>接口基础</p>
<a id="more"></a>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>接口是指定一组方法成员而不实现它们的引用类型。只能类和结构来实现接口。</p>
<p>接口是引用类型。</p>
<p>类强制转换未实现的接口的引用会抛出一个异常，可以使用as运算符避免这个问题。如果类没有实现接口，as运算符的表达式会返回null而不是抛出异常。</p>
<p>例如：array类的sort方法依赖于Icomparable接口，接口声明在BCL中，包含一个comparato方法。我们可以为自己的类添加compareto方法，这样sort就可以使用了。如果没有自定义compareto方法，sort调用不存在的compareto方法会抛出异常。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现IComparable的例子</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title">Myclass</span>:<span class="title">IComparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> TheValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass mc = (Myclass)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &lt; mc.TheValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个使用的例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Iinfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">GetName</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">GetAge</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CA</span>:<span class="title">Iinfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetName</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> Name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetAge</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> Age.ToString();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CB</span>:<span class="title">Iinfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> First;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Last;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> PersonsAge;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetName</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> First;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetAge</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> Last;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params">Iinfo item</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(item.GetName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        CA a = <span class="keyword">new</span> CA()&#123;Name = <span class="string">"xxxxx"</span>,Age = <span class="number">12</span>&#125;;</span><br><span class="line">        CB b = <span class="keyword">new</span> CB()&#123;First = <span class="string">"zzzzz"</span>,PersonsAge = <span class="number">22.2</span>&#125;;</span><br><span class="line">        <span class="comment">//对象的引用自动转换为接口的引用。</span></span><br><span class="line">        PrintInfo(a);</span><br><span class="line">        PrintInfo(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph LR;
    subgraph 栈
    id1[ifc]
    id2[mc]
    end

    subgraph 在堆上的myclass 
    id3[接口IIfc printout]
    id4[printout]
    id5[这个类]
    end
    id3-->id4
    id1-->id3
    id2-->id5</pre>



<h2 id="1-2-声明接口"><a href="#1-2-声明接口" class="headerlink" title="1.2 声明接口"></a>1.2 声明接口</h2><p>声明的惯例是接口命名以大写i开头。</p>
<p>接口的声明可以有任何访问修饰符(public protected internal private)，但是接口的成员不允许有任何访问修饰符，成员为隐式public的。</p>
<p>接口不能包含以下成员：</p>
<ul>
<li>数据成员</li>
<li>静态成员</li>
</ul>
<p>只能包含以下类型的非静态成员函数声明：</p>
<ul>
<li>方法</li>
<li>属性</li>
<li>事件</li>
<li>索引器</li>
</ul>
<p>如果类从基类实现了接口，基类列表中的基类名称必须放在所有接口之前。</p>
<h2 id="1-3-实现多个接口"><a href="#1-3-实现多个接口" class="headerlink" title="1.3 实现多个接口"></a>1.3 实现多个接口</h2><p>接口可以实现多个。</p>
<ul>
<li>类或结构可以实现任意数量的接口，这一点和类的继承是不同的。</li>
<li>所有实现的接口必须列在基类列表中并用逗号分隔。</li>
<li>如果一个类实现了多个接口，那他可以通过转换as运算符来获得多个接口的引用。</li>
</ul>
<h2 id="1-4-派生成员作为实现"><a href="#1-4-派生成员作为实现" class="headerlink" title="1.4 派生成员作为实现"></a>1.4 派生成员作为实现</h2><p>MyBassClass包含了PrintOut方法，和IIfc1的方向相匹配，Derived有一个空的声明主题，但他派生自MyBaseClass，并且在基类列表包含了IIfc1，所以即使Derived的声明主体是空的，基类的代码还是能满足接口的需求。</p>
<p>:grey_question:子类没有实现方法怎么办？</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="keyword">string</span> s</span>)&#125;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyBassClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">MyBassClass</span>, <span class="title">IIfc1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Derived d = <span class="keyword">new</span> Derived();</span><br><span class="line">        d.PrintOut(<span class="string">"object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-显示接口成员实现"><a href="#1-5-显示接口成员实现" class="headerlink" title="1.5 显示接口成员实现"></a>1.5 显示接口成员实现</h2><p>如果需要分离不同的接口，可以创建显示接口成员实现。</p>
<p>和所有接口的实现一样，位于实现了接口的类或结构中。但它使用限定接口名称声明：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">MyBassClass</span>, <span class="title">IIfc1</span>,<span class="title">IIfc2</span></span><br><span class="line">&#123;   <span class="keyword">public</span> <span class="keyword">void</span> IIfc1.PrintOut(<span class="keyword">string</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> IIfc2.PrintOut(<span class="keyword">string</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为他们不是类级别的实现了，所以显示接口成员实现之后，可以通过接口的引用调用方法。</p>
<p>即使是类中的其他成员，也不能访问显示实现。需要强制转换此类或实例为接口的引用调用显示接口实现：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PrintOut();  <span class="comment">//编译错误</span></span><br><span class="line">	<span class="keyword">this</span>.PrintOut();  <span class="comment">//编译错误</span></span><br><span class="line">	((IIfc1)<span class="keyword">this</span>).PrintOut();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示接口实现对继承产生了重要的影响，由于其它类成员不能直接访问显示接口成员实现，衍生类的成员也不能直接访问他们，必须总是通过接口的引用来访问。</p>
<h2 id="1-6-接口可以继承接口"><a href="#1-6-接口可以继承接口" class="headerlink" title="1.6 接口可以继承接口"></a>1.6 接口可以继承接口</h2><p>接口本身可以被一个或多个接口继承。</p>
<p>与类不同，类的基类列表只能只能有一个类。但接口可以在基接口列表有任意多的接口。列表中的接口可以继承其他接口。结果接口包括它声明的所有接口和所有基接口成员。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础7 事件</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%807%20%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>发布者/订阅者模式，源代码组件概览</p>
<a id="more"></a>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ul>
<li>事件和委托类似，事件就像是某种特殊用途的简单委托。</li>
<li>事件内部包含了一个私有的委托，并提供了对私有委托的结构化访问，用户无法直接访问委托。</li>
<li>事件可用的操作比委托要少，事件只能添加删除调用事件处理程序。</li>
<li>事件被触发时，调用委托来一次调用方法列表中的方法。</li>
<li>事件也可以是静态的。</li>
<li>事件是成员，并不是类型。</li>
</ul>
<h2 id="1-2-发布者-订阅者模式"><a href="#1-2-发布者-订阅者模式" class="headerlink" title="1.2 发布者/订阅者模式"></a>1.2 发布者/订阅者模式</h2><p>发布者/订阅者模式可以在特定的程序事件发生时，程序的其他部分收到通知。</p>
<p>发布者定义一个事件，其他类可以通过向发布者提供体一个方法来注册，当事件发生时，发布者执行订阅者所提交的方法，订阅者提供的方法称为回调方法。</p>
<pre class="mermaid">graph LR;
    subgraph 发布者
    id0[事件成员]
    end
    subgraph 订阅者类1
    id1[回调方法]
    end
     subgraph 订阅者类2
    id2[回调方法]
    end
    id1--订阅-->id0
    id2--订阅-->id0</pre>

<ul>
<li>发布者：发布某个事件的类或者结构，其他类可以在该事件发生时得到通知。</li>
<li>订阅者：注册并在事件发生时得到通知的结构。</li>
<li>事件处理程序：由订阅者注册到事件的方法。</li>
<li>触发事件：调用或触发事件。</li>
</ul>
<h2 id="1-3-源代码组件概览"><a href="#1-3-源代码组件概览" class="headerlink" title="1.3 源代码组件概览"></a>1.3 源代码组件概览</h2><p>事件由五个部分组成：</p>
<ol>
<li>委托类型声明：事件和事件处理程序必须有相同的签名和返回类型，通过委托进行描述。</li>
<li>事件处理程序声明：不一定是显示的命名方法，也可以是匿名方法或者lambda表达式。</li>
<li>事件声明：发布者必须声明一个订阅者类可以注册的事件成员，当声明的事件为public时，称发布了事件。</li>
<li>事件注册：订阅者必须订阅事件才能得到通知。</li>
<li>触发事件的代码：发布者类触发事件并导致调用所有事件处理程序的代码。</li>
</ol>
<pre class="mermaid">graph TB;
    id3[委托类型声明]
    id4[事件注册]
    subgraph 发布者类
    id0[事件声明]
    id2[触发事件的代码]
    end
    subgraph 订阅者类
    id1[事件处理 程序声明]
    end</pre>

<h2 id="1-4-声明组件"><a href="#1-4-声明组件" class="headerlink" title="1.4 声明组件"></a>1.4 声明组件</h2><p>事件声明需要委托类型的名字。可以用已存在的，或自己声明一个。如果自己声明，必须指定事件保存的方法的签名和返回类型。BCL中有EventHandler委托，专门用于系统事件。</p>
<p>事件声明在一个类中，声明需要注意的点：</p>
<ol>
<li>它需要委托类型的名称，任何附加到事件的事件处理程序都必须和委托类型的签名和返回类型匹配。</li>
<li>声明为public，其他类和结构才能注册事件处理程序。</li>
<li>不能使用对象创建表达式new来创建事件对象。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Eg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//   关键字   委托类型      事件名</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">event</span> EventHandler AEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以使用逗号声明一个以上的事件：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler AEvent,AEvent1,AEvent2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以使用static关键字让事件变为静态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> EventHandler AEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于事件是成员：</p>
<ul>
<li>不能在一段可执行代码中声明事件。</li>
<li>必须声明在类和结构中。</li>
<li>被隐式自动初始化为null。</li>
</ul>
<h2 id="1-5-订阅-移除事件"><a href="#1-5-订阅-移除事件" class="headerlink" title="1.5 订阅,移除事件"></a>1.5 订阅,移除事件</h2><p>事件处理程序的规范：</p>
<ul>
<li>实例方法的名称。</li>
<li>静态方法的名称。</li>
<li>匿名方法。</li>
<li>Lambda表达式。</li>
</ul>
<p>使用+=运算符为事件增加事件处理程序，增加方法也就是订阅：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类      事件成员	</span></span><br><span class="line">Someclass.Aevent += Method;     <span class="comment">//实例方法</span></span><br><span class="line">Someclass.Aevent += Class.Method; <span class="comment">//静态方法</span></span><br><span class="line">Someclass.Aevent += <span class="keyword">new</span> EventHandler(Method) <span class="comment">//委托形式</span></span><br><span class="line">Someclass.Aevent += ()=&gt; x++; <span class="comment">//Lambda表达式</span></span><br><span class="line">Someclass.Aevent += <span class="keyword">delegate</span>&#123;x++;&#125; <span class="comment">//匿名方法</span></span><br></pre></td></tr></table></figure>
<p>使用-=号移除一个订阅，但如果 处理程序向事件注册了多次，那当执行命令移除处理程序时，将只移除列表中该处理程序的最后一个实例。和委托一样。</p>
<h2 id="1-6-触发事件"><a href="#1-6-触发事件" class="headerlink" title="1.6 触发事件"></a>1.6 触发事件</h2><p>事件保存了事件处理程序，但如果事件不被触发，任何处理程序都不会被调用。</p>
<p>触发事件之前应该和null进行比较，看看是否事件是或否包含处理程序：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Aevent != <span class="literal">null</span>)</span><br><span class="line">	Aevent(x,y);</span><br></pre></td></tr></table></figure>
<p>一个简单的例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Handler</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Handler Aevent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (...)</span><br><span class="line">            Aevent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params">A classa</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        classa.Aevent += Method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        x ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-标准事件的用法"><a href="#1-7-标准事件的用法" class="headerlink" title="1.7 标准事件的用法"></a>1.7 标准事件的用法</h2><p>GUI编程是事件驱动的。</p>
<p>.net提供了一个标准模式，事件使用的标准模式的根本就是System命名空间下的Eventhandler委托类型。 Eventhandler的声明如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="keyword">object</span> sender,EventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sender参数用于保存触发事件的对象的引用。</li>
<li>e保存状态信息，指明什么类型适用于该应用程序。</li>
<li>事件处理程序的签名必须和EventHandler委托匹配。</li>
</ul>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用系统定义的EventHandler委托。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler Aevent; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (...)</span><br><span class="line">            <span class="comment">//触发事件时使用EventHandler的参数</span></span><br><span class="line">            Aevent(<span class="keyword">this</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params">A classa</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        classa.Aevent += Method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件处理程序的签名必须和委托匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">object</span> sender,EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        x ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-1-Eventargs"><a href="#1-7-1-Eventargs" class="headerlink" title="1.7.1 Eventargs"></a>1.7.1 Eventargs</h3><p>Eventargs被设计为不能传递任何数据，它用于不需要传递数据的事件处理程序。通常会被忽略。（类型结构）</p>
<p>但Eventargs很重要，他和object总是基类，这样eventhandler提供了任何事件和事件处理程序都通用的签名。</p>
<p>拓展Eventargs来传递数据：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AExtendClass</span>:<span class="title">Eventargs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> SomeArg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用,泛型委托使用自定义类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> EventHandler&lt;AExtendClass&gt; Aevent;</span><br></pre></td></tr></table></figure>
<p>:grey_question:不明为什么要用泛型</p>
<p>完整的例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AExtendClass</span>:<span class="title">Eventargs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> SomeArg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用自定义的泛型委托。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;AExtendClass&gt; Aevent; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AExtendClass eventarg = <span class="keyword">new</span> AExtendClass();</span><br><span class="line">        <span class="keyword">for</span> (...)</span><br><span class="line">            <span class="comment">//触发事件时传递参数</span></span><br><span class="line">            eventarg.somearg = <span class="number">1</span>;</span><br><span class="line">            Aevent(<span class="keyword">this</span>,eventarg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params">A classa</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        classa.Aevent += Method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件处理程序的签名必须和委托匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">object</span> sender,AExtendClass e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(e.somearg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-8-事件访问器"><a href="#1-8-事件访问器" class="headerlink" title="1.8 事件访问器"></a>1.8 事件访问器</h2><p>+=和-=是事件唯一允许的运算符，但可以通过实现事件访问器自定义一些代码进去。修改运算符的行为。</p>
<p>事件访问器看上去和声明一个属性差不多，声明了事件访问器以后，事件不包含任何内嵌的委托对象。必须自己实现机制来存储和移除事件注册方法。</p>
<p>事件访问器表现为void方法 就是不能使用带返回值的return语句。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler Aevent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">add</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">remove</span>&#123;.....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础6 委托</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%806%20%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p>声明,创建,调用委托</p>
<a id="more"></a>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>可以认为委托是持有一个或多个方法的对象。通过执行委托，执行它所持有的方法。其实委托就相当于类型安全的，面向对象的c++函数指针。也可以把委托看作是包含有序方法列表的对象，这些方法具有相同的签名和返回类型。</p>
<p>使用前，一般会创建一个委托类型。（注意一开始创建的是委托类型，不是委托对象。）</p>
<p>使用方法：</p>
<ol>
<li>.声明一个委托类型，委托的声明和方法声明类似，但是没有实现块。</li>
<li>使用委托类型声明一个委托变量。</li>
<li>创建委托类型的对象，赋值给委托变量。</li>
<li>为委托变量增加方法，方法的签名和返回类型和委托类型声明的一致。</li>
<li>调用委托。</li>
</ol>
<p>需要注意的点：</p>
<ul>
<li>方法的列表成为调用列表。</li>
<li>需要保存的方法可以是任何类或者结构的，只要返回类型和签名（包括ref和out修饰符）一致。</li>
<li>列表中的方法也可以是静态的。</li>
</ul>
<h2 id="1-2-声明-创建-调用委托"><a href="#1-2-声明-创建-调用委托" class="headerlink" title="1.2 声明,创建,调用委托"></a>1.2 声明,创建,调用委托</h2><p>声明委托对象：因为委托是类型的声明，所以他不需要在类内部声明。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键字  返回类型 委托类型名 签名</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span>    <span class="title">MyDel</span>   (<span class="params"><span class="keyword">int</span> x</span>)</span></span><br></pre></td></tr></table></figure>
<p>创建委托对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">delvar = <span class="keyword">new</span> MyDel&#123;someobj.MyMethod&#125;; <span class="comment">//创建委托并保存引用，传入对象的成员方法</span></span><br><span class="line">dvar = new MyDel&#123;class.Method&#125;; //创建委托并保存引用，传入类的静态成员</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">delvar = someobj.MyMethod;</span><br><span class="line">dvar = <span class="keyword">class</span>.<span class="title">Method</span>;</span><br></pre></td></tr></table></figure>
<p>使用委托对象：</p>
<ul>
<li><p>通过赋值可以改变包含在委托变量中的引用，旧的委托对象会被垃圾回收。</p>
</li>
<li><p>委托是恒定的，委托对象被创建后就不能被改变。在使用+=时，实际上是创建了新的委托（里面是原委托的方法列表和+=号右边的方法）然后再复制给+=左边。-=用于删除方法，和+=一样，新的委托是旧的委托的副本删除时会从方法列表最后开始搜索，移除第一个与方法匹配的实例。</p>
</li>
<li><p>试图删除委托中不存在的方法没有效果。</p>
</li>
<li><p>调用空委托会抛出异常。可以和null做比较然后抛出。</p>
</li>
<li><p>如果一个方法在方法列表里多次，当委托被调用时，每有一个该方法就会调用一次。</p>
</li>
<li><p>调用列表最后一个方法的返回值就是委托调用返回的值，其他方法的值会被忽略。</p>
</li>
<li><p>如果委托有引用参数，在调用委托列表的下一个方法时，参数的新值（不是初始值）会传给下一个方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> x</span>)</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add2</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> x</span>)</span>&#123;x += <span class="number">2</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add3</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> x</span>)</span>&#123;x += <span class="number">3</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass mc = <span class="keyword">new</span> Myclass();</span><br><span class="line">        MyDel mdel = mc.Add2;</span><br><span class="line">        mdel += mc.Add3;</span><br><span class="line">        mdel += mc.Add2;</span><br><span class="line">        <span class="keyword">int</span> x= <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//输出：12</span></span><br><span class="line">        mdel(<span class="keyword">ref</span> x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-3-匿名方法"><a href="#1-3-匿名方法" class="headerlink" title="1.3 匿名方法"></a>1.3 匿名方法</h2><p>匿名方法允许不创建具名方法。以下地方可以使用匿名方法：</p>
<ul>
<li>声明委托变量时作为初始化表达式。</li>
<li>组合委托时赋值语句的右边。</li>
<li>为委托增加事件时赋值语句的右边。</li>
</ul>
<p>使用方法：</p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键字  参数列表 语句块</span></span><br><span class="line"><span class="keyword">delegate</span> (parameters) &#123;implementationcaode&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">OhterDel</span>(<span class="params"><span class="keyword">int</span> InParam</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OhterDel del = <span class="keyword">delegate</span>(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  匿名方法的参数必须在这几个方面和委托匹配：</p>
<ul>
<li>参数数量</li>
<li>参数类型及位置</li>
<li><p>修饰符</p>
<p>可以省略或使圆括号为空来简化匿名方法，但必须是：委托的参数列表不包含任何out参数，且匿名方法不使用任何参数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">OhterDel</span>(<span class="params"><span class="keyword">int</span> InParam</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OhterDel del = <span class="keyword">delegate</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果委托中使用了params参数，匿名参数的列表将忽略params关键字：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">OhterDel</span>(<span class="params"><span class="keyword">int</span> InParam,<span class="keyword">params</span> <span class="keyword">int</span>[] Y</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OhterDel del = <span class="keyword">delegate</span>(<span class="keyword">int</span> x,<span class="keyword">int</span>[] Y) <span class="comment">//省略</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名方法的变量和参数作用域：</p>
</li>
</ul>
<p>  被限制在实现方法的主体之内。</p>
<p>  与委托的具名方法不同，<strong>匿名方法可以访问外围作用域的局部变量和环境。</strong></p>
<p>  外围作用域的变量叫外部变量，匿名方法使用外部变量称为方法捕获。</p>
<h3 id="1-3-1-匿名方法的变量和参数作用域"><a href="#1-3-1-匿名方法的变量和参数作用域" class="headerlink" title="1.3.1 匿名方法的变量和参数作用域"></a>1.3.1 匿名方法的变量和参数作用域</h3><ul>
<li>变量和参数作用域被限制在实现方法的主体之内。</li>
<li>与委托的具名方法不同，匿名方法可以访问外围作用域的局部变量和环境。</li>
<li><p>外围作用域的变量叫外部变量，匿名方法使用外部变量称为方法捕获。</p>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一个块，x只在块内有效</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> x =<span class="number">5</span>;</span><br><span class="line">    	OhterDel del = <span class="keyword">delegate</span>()</span><br><span class="line">    	&#123;</span><br><span class="line">        	Console.WriteLine(x);<span class="comment">//x可以在匿名方法作用域之内使用。</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只要捕获方法还是委托的一部分，即使外部变量离开了作用域，也一直有效：</span></span><br><span class="line">    del();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-4-Lambda表达式"><a href="#1-4-Lambda表达式" class="headerlink" title="1.4 Lambda表达式"></a>1.4 Lambda表达式</h2><p>如果先引入了lambda方法，那就不会有匿名方法。匿名方法2.0引入的，lambda是3.0引入的。</p>
<p>lambda运算符也读作 goes to =&gt;。</p>
<p>编译器可以省略一些东西：</p>
<ul>
<li><p>带有类型的参数列表称为显示类型。</p>
</li>
<li><p>省略类型的参数列表被称为隐式类型。</p>
</li>
<li><p>如果只有一个隐式类型参数（这个和隐式类型不一样的概念，意思是隐式类型中只有一个参数），可以省略圆括号。</p>
</li>
</ul>
<p>lambda表达式要点：</p>
<pre><code>1. lambda表达式的参数列表中的参数数量类型位置必须和委托完全匹配。
2. 表达式的参数列表中的参数不一定需要包含类型（隐式类型）。除非有ref和out，此时必须标注类型（显示类型。）
3. 如果只有一个参数，且是隐式类型。圆括号可以省略否则必须有。
4. 如果没有参数必须使用圆括号。
</code></pre><p>  例子：</p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Mydel del =  <span class="keyword">delegate</span>(<span class="keyword">int</span> x)   &#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;  <span class="comment">//匿名方法</span></span><br><span class="line">Mydel del =         (<span class="keyword">int</span> x) =&gt; &#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;  <span class="comment">//Lambda表达式</span></span><br><span class="line">Mydel del = 		   	(x) =&gt;  &#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;  <span class="comment">//Lambda表达式</span></span><br><span class="line">Mydel del = 		   	  x =&gt;  &#123;<span class="keyword">return</span> x + <span class="number">1</span>;&#125;;  <span class="comment">//Lambda表达式</span></span><br><span class="line">Mydel del = 		   	  x =&gt;   x + <span class="number">1</span>;  			<span class="comment">//Lambda表达式</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础5 字符串</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%805%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p> String，StringBuilder</p>
<a id="more"></a>
<h1 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h1><h1 id="1-2-String"><a href="#1-2-String" class="headerlink" title="1.2 String"></a>1.2 String</h1><p>字符串是unicode字符串数组，是不可变的，不能被修改。所以对于一个string来说，任何改变都会分配一个新的恒定字符串。</p>
<h1 id="1-3-StringBuilder"><a href="#1-3-StringBuilder" class="headerlink" title="1.3 StringBuilder"></a>1.3 StringBuilder</h1><p>StringBuilder可以动态有效的产生字符串,避免创建许多副本。和string不同，StringBulider对象会被确实的修改。</p>
<ul>
<li>StringBuilder类是BCL的成员，位于System.Text命名空间中。</li>
<li>StringBuilder对象是Unicode字符的可变数组。</li>
</ul>
<h1 id="1-4-把字符串解析为数据值"><a href="#1-4-把字符串解析为数据值" class="headerlink" title="1.4 把字符串解析为数据值"></a>1.4 把字符串解析为数据值</h1><p>解析允许接受表示值的字符串，并把它转换为实际值。所有预定义的简单类型都有一个Parse方法，用于解析。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="keyword">double</span>.Parse(<span class="string">"25.973"</span>);</span><br></pre></td></tr></table></figure>
<p>Parse方法的缺点是如果string不能成功转换目标类型，会抛出一个异常。Tryparse方法可以避免这个问题。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> succes = <span class="keyword">int</span>.TryParse(stringFirst,<span class="keyword">out</span> intFirst)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础4 数组</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%804%20%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>枚举相关内容</p>
<p>Array</p>
<a id="more"></a>
<h1 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h1><ul>
<li>数组一旦创建大小就会固定。c#不支持动态数组。</li>
<li>数组是对象，引用类型，继承自System.Array，继承BCL基类。</li>
<li>数组被创建后元素会被自动初始化为类型默认值。</li>
</ul>
<p>数组的几个重要定义：</p>
<ol>
<li>元素</li>
<li>秩/维度：是几维的数组。</li>
<li>维度长度：每一个维度的长度。</li>
<li>数组长度：数组的所有维度的元素总和。</li>
</ol>
<p>两种类型的数组：</p>
<ol>
<li>一维数组：单行元素或元素向量。</li>
<li>多维数组：由主向量中的位置组成的，每个位置本身就是个数组，成为子数组。多维数组有两种，矩形数组和交错数组。</li>
</ol>
<p>数组的存储：</p>
<ul>
<li>System.Array继承的方法和数组的元素在堆上，数组本身对象的引用在栈或者堆上。</li>
<li>如果存储的元素都是值类型，则称数组为值类型数组。</li>
<li>如果元素都是引用类型对象，则称数组为引用类型数组。</li>
</ul>
<h1 id="1-2-一维数组和矩形数组"><a href="#1-2-一维数组和矩形数组" class="headerlink" title="1.2 一维数组和矩形数组"></a>1.2 一维数组和矩形数组</h1><p>声明时的逗号是秩说明符，指定了数组的维度。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明方式,几个逗号就是数量+1维度的数组。</span></span><br><span class="line"><span class="keyword">int</span>[] arrty11;</span><br><span class="line"><span class="keyword">int</span>[，，] arrty11;</span><br></pre></td></tr></table></figure>
<p>不能在数组类型区域中设置数组的维度长度。秩是数组类型的一部分，但长度不是。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] arrty11；<span class="comment">//不可以。</span></span><br></pre></td></tr></table></figure>
<p>*注：c/c++方括号是放在基类型的后面，不是在变量名称后面。</p>
<p>实例化数组：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]; <span class="comment">//4个元素</span></span><br><span class="line">MyClass[] mcArr = <span class="keyword">new</span> MyClass[<span class="number">4</span>]; <span class="comment">//数组创建表达式</span></span><br><span class="line"><span class="keyword">int</span>[,,,] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>矩形数组的元素获取方式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>,<span class="number">10</span>];</span><br><span class="line">arr2[<span class="number">2</span>,<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a = arr2[<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>初始化列表用于显示的初始化数组。不用输入长度，会自动判断:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[,,] arr = <span class="keyword">new</span> <span class="keyword">int</span>[,]&#123;&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样初始化矩形数组是一个技巧，逗号不在大括号的内部使用，同时使用缩进和回车。</span></span><br><span class="line"><span class="comment">//可以读成：4组两个元素一组的三组分组。</span></span><br><span class="line"><span class="keyword">int</span>[,,] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]&#123;</span><br><span class="line">    &#123;&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br><span class="line">    &#123;&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br><span class="line">    &#123;&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以省略new的部分：</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组也可以是隐式类型的</span></span><br><span class="line"><span class="keyword">var</span> arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">//但是秩说明符还是要有的。</span></span><br><span class="line"><span class="keyword">var</span> arr =  <span class="keyword">new</span> [,]&#123;&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1-3-交错数组"><a href="#1-3-交错数组" class="headerlink" title="1.3 交错数组"></a>1.3 交错数组</h1><p>交错数组是数组的数组。交错数组的结构是，堆中存在着顶层数组，顶层数组的每一个元素保存着每一个子数组在堆上的位置。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意声明方式和一维数组，矩形数组的不同。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span>[][] jagArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][] <span class="comment">//声明并创建顶层数组</span></span><br><span class="line">jagArr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;; <span class="comment">//声明并创建子数组</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>声明语句中不能初始化顶层数组之外的数组。</li>
<li>交错数组的实例化无法在一个步骤中完成，因为每个子数组都是独立的。</li>
<li>交错数组中也可以有矩形数组。</li>
</ul>
<p>其实交错数组就相当于保存了各个子数组的引用。</p>
<h1 id="1-4-交错数组和矩形数组的差别"><a href="#1-4-交错数组和矩形数组的差别" class="headerlink" title="1.4 交错数组和矩形数组的差别"></a>1.4 交错数组和矩形数组的差别</h1><p>两者的结构区别很大：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆上矩形数组的结构 Attr[3,3]</span></span><br><span class="line"><span class="number">56</span>|<span class="number">23</span>|<span class="number">32</span></span><br><span class="line"><span class="number">45</span>|<span class="number">43</span>|<span class="number">21</span></span><br><span class="line"><span class="number">12</span>|<span class="number">21</span>|<span class="number">32</span></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆上交错数组的结构 Attr[3][3]</span></span><br><span class="line">Attr[<span class="number">0</span>] ---&gt; <span class="number">56</span>|<span class="number">23</span>|<span class="number">32</span>   </span><br><span class="line">Attr[<span class="number">1</span>] --&gt; <span class="number">45</span>|<span class="number">43</span>|<span class="number">21</span></span><br><span class="line">Attr[<span class="number">2</span>] -&gt; <span class="number">12</span>|<span class="number">21</span>|<span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>BCL中，一维数组有特定的指令用于性能优化，矩形数组没有。并且不能在相同级别进行优化，所以有时使用一维数组（可以被优化）的交错数组比矩形数组（不能被优化）更有效率。但矩形数组的编程复杂程度很小。</p>
<h1 id="1-5-数组协变"><a href="#1-5-数组协变" class="headerlink" title="1.5 数组协变"></a>1.5 数组协变</h1><p>某个对象不是数组的基类型，也可以把它赋值给数组元素。这种属性叫数组协变。值类型数组没有协变。</p>
<p>以下情况可以使用数组协变：</p>
<ol>
<li>数组是引用类型数组。</li>
<li>在赋值的对象类型和数组基类型之间有隐式或者显示转换。（一般是存在继承关系）</li>
</ol>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mian</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//两个A类型的数组</span></span><br><span class="line">        A[] array1 = <span class="keyword">new</span> A[<span class="number">3</span>];</span><br><span class="line">        A[] array2 = <span class="keyword">new</span> A[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//普通：</span></span><br><span class="line">        array1[<span class="number">0</span>] = <span class="keyword">new</span> A();   array1[<span class="number">1</span>] = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//协变：将b类型的对象赋值给A类型的数组</span></span><br><span class="line">        array2[<span class="number">0</span>] = <span class="keyword">new</span> B();   array2[<span class="number">1</span>] = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：规则是赋值对象和数组基类型有显示或隐式转换，而没有强调存在继承关系，就说明协变和父子类之间的关系是没有必要的联系的。重要的是数组协变提供了将兼容不同类型元素的办法。</p>
<h1 id="1-6-数组继承的一些成员"><a href="#1-6-数组继承的一些成员" class="headerlink" title="1.6 数组继承的一些成员"></a>1.6 数组继承的一些成员</h1><p><strong>clone方法：</strong></p>
<p>为数组进行浅复制，只创建了数组本身的克隆。如果是引用类型数组，他不会复制元素引用的对象。但clone值类型数组会产生两个独立数组。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础3 枚举</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%803%20%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>概述，底层类型，位标志</p>
<a id="more"></a>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>枚举是值类型，只有一种类型的成员：命名的整数数值常量。</li>
<li>每个枚举类型都有一个底层整数类型，默认int。</li>
<li>每个枚举成员都会被赋予一个底层类型的常量值</li>
<li>默认情况下，第一个成员的赋值为0，后面一次+1.</li>
<li>枚举成员的名字不可以重复，但是值可以。</li>
<li>枚举只有单一的成员类型。</li>
<li>不能对成员使用修饰符。隐式的具有和枚举相同的可访问性。</li>
<li>比较不同的枚举类型编译会报错，哪怕值和结构完全一样。</li>
<li></li>
</ul>
<h3 id="1-2-底层类型和显示值"><a href="#1-2-底层类型和显示值" class="headerlink" title="1.2 底层类型和显示值"></a>1.2 底层类型和显示值</h3><p>可以使枚举使用除int以外的<strong>整数类型</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enumeg：<span class="keyword">ulong</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>枚举可以显式的赋值常量，但如果不初始化，编译器会隐式的赋值。规则如下：</p>
<pre class="mermaid">graph LR;
    id1[第一个成员有初始化吗]--是-->id2(把它设置为初始化值);
    id1--否-->id3(把它设置为0);
    id3-->id4(下一个成员有初始化吗);
    id4--是-->id2
    id4--否-->id5(给它赋一个比前一个多1的值)
    id2-->id4;</pre>

<h3 id="1-3-位标志"><a href="#1-3-位标志" class="headerlink" title="1.3 位标志"></a>1.3 位标志</h3><p>单个枚举变量可以表示多种状态。书中称之为标志字，flagword。</p>
<p>使用的方式：</p>
<ol>
<li>确认需要多少个位标志，选择足够多的无符号正数类型保存。</li>
<li>确认每个位代表什么，声明一个选好的整数类型用位表示，如0001。</li>
<li>用按位或添加一个枚举状态 0001 or 0010 = 0011</li>
<li>使用按位与，或hasflag解开一个状态。</li>
</ol>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">enum</span> CardDeckSettings:<span class="keyword">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    one = <span class="number">0x01</span>，<span class="comment">//位0</span></span><br><span class="line">    two = <span class="number">0x02</span>，<span class="comment">//位1 </span></span><br><span class="line">    tree = <span class="number">0x04</span>，<span class="comment">//位2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用位标志，枚举中任何成员的值都是2的n次方。标志字加一个状态用位或，减去一个状态用位与。</p>
<p>在.net4.8之后，可以使用HasFlag()方法来确定某个枚举变量是否包含一个状态：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> enumsome = ops.HasFlag(CardDeckSettings.One); <span class="comment">//ops,标志字（枚举变量）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这样</span></span><br><span class="line">CardDeckSettings testflags = CardDeckSettings.one|CardDeckSettings.two;</span><br><span class="line"><span class="keyword">bool</span> haveenum =  ops.HasFlag(testflags);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以这样,判断ops标志字是否包含one枚举。</span></span><br><span class="line"><span class="keyword">bool</span> haveenum =  (ops &amp; CardDeckSettings.one) == CardDeckSettings.one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原理：</span></span><br><span class="line"><span class="number">0</span>|....|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span> <span class="comment">//one</span></span><br><span class="line"><span class="number">0</span>|....|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span> <span class="comment">//two</span></span><br><span class="line"><span class="number">0</span>|....|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">0</span> <span class="comment">//tree</span></span><br><span class="line"><span class="number">0</span>|....|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span> <span class="comment">//ops（包含tree和one）</span></span><br><span class="line"><span class="comment">//位与检查</span></span><br><span class="line"><span class="number">0</span>|....|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span> <span class="comment">//one</span></span><br><span class="line"><span class="number">0</span>|....|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span> <span class="comment">//ops</span></span><br><span class="line"><span class="comment">//位与</span></span><br><span class="line"><span class="number">0</span>|....|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span> <span class="comment">// ops&amp;one</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-Flags特性"><a href="#1-4-Flags特性" class="headerlink" title="1.4 Flags特性"></a>1.4 Flags特性</h3><p>添加了flags特性会加入一些方便的特性，它会告诉编译器，对象浏览器以及其他查看代码的工具，该枚举的成员不仅可以当作单独的值，还可以按位进行组合。其次，允许枚举的tosrting方法为位标志的值提供更多的格式化信息。这样tostring会取匹配枚举的成员然后返回枚举成员的字符串名称。</p>
<p>例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> CardDeckSettings:<span class="keyword">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    one = <span class="number">0x01</span>，<span class="comment">//位0</span></span><br><span class="line">    two = <span class="number">0x02</span>，<span class="comment">//位1 </span></span><br><span class="line">    tree = <span class="number">0x04</span>，<span class="comment">//位2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        CardDeckSettings ops;</span><br><span class="line">        ops = CardDeckSettings.one;</span><br><span class="line">        Console.WriteLine(ops.ToString());</span><br><span class="line">        </span><br><span class="line">        ops = CardDeckSettings.one | CardDeckSettings.tree;</span><br><span class="line">        Console.WriteLine(ops.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//1.one</span></span><br><span class="line"><span class="comment">//2.5</span></span><br></pre></td></tr></table></figure>
<p>可以看到，如果没加flags的ops含有多个枚举成员，则输出只会显示值，因为tostring方法没有找到哪个枚举成员是3的值。</p>
<p>如果加了flags就是这样的：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//1.one</span></span><br><span class="line"><span class="comment">//2.one,tree</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础1 基础</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%801%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>基础内容，包括：.Net框架概述，语言规则，变量类型和存储，方法，类，表达式运算符和语句。</p>
<a id="more"></a>
<h2 id="一-Net框架"><a href="#一-Net框架" class="headerlink" title="一 .Net框架"></a>一 .Net框架</h2><h3 id="1-1-net框架构成"><a href="#1-1-net框架构成" class="headerlink" title="1.1 .net框架构成"></a>1.1 .net框架构成</h3><pre class="mermaid">graph LR;
    id1[编程工具]--产生-->id2(编译的代码);
    id2--使用-->id3[BCL基类库]
    id2--被执行-->id4[CLR公共语言运行库]
    id3--被执行-->id4</pre>

<p><strong>BCL(Base Class Library )</strong> :</p>
<p>基础类库(或者称为框架类库 Framework Class Library ， FCL)，自己写程序时也会调到BCL</p>
<p><strong>CLR(Common Language Runtime)</strong>： </p>
<p>公共语言运行库。.net框架的核心组件，在操作系统的顶层，负责<strong>管理</strong>程序的执行。可以从下图看到，可以看到，非托管代码CLR不提供服务。</p>
<p>CRL还提供这几种服务：1.自动垃圾收集，2.安全和认证。3.通过访问BCL得到广泛的编程功能，如Web服务和数据服务。</p>
<pre class="mermaid">graph TB;
    id1-->id5
    id1-->id6
    id1-->id7
    id1-->id4
    id11[非.net程序]-->id10[操作系统]
    id7-->id10
subgraph 托管代码
    id1[程序集1]
    id2[程序集2]
    id3[程序集3]
end
subgraph CLR
    id4[内存管理\异常处理]
    id5[垃圾收集\反射服务]
    id6[JIT编辑器\类加载器]
    id7[安全服务]
end
subgraph 非托管代码
    id11
end</pre>

<p><strong>托管代码(managed code)</strong>：</p>
<p>.net编写的代码称为托管代码。</p>
<p><strong>非托管代码(unmanaged code)：</strong></p>
<p>不在CLR控制之下的代码，如Win32，C/C++ DLL。</p>
<h3 id="1-2-编译过程"><a href="#1-2-编译过程" class="headerlink" title="1.2 编译过程"></a>1.2 编译过程</h3><pre class="mermaid">graph LR;
    id1[1.net兼容语言的源代码]-->id2(.net兼容编译器)
    id2-->id3[2.程序集:A.CIL B.类型信息 C.安全信息]</pre>

<p><strong>解释：</strong></p>
<ol>
<li>使用c#或vb等.net语言编写的文本文件。</li>
<li>使用编程语言写好的文件需要使用编译器生成<strong>程序集</strong>文件，程序集文件只能是可执行的，或者是<strong>DLL</strong>。并且程序集中的不是本机代码，而是CIL公共中间语言的中间语言，</li>
</ol>
<p><strong>CIL（Common Intermediate Language）：</strong></p>
<p>公共语言基础结构，CIL是一组阐述了系统架构，规则，和约定的规范。也是一组数据结构，系统标准。和CIL有关的还有<strong>IL</strong>和<strong>MSIL</strong> 不过已经很少用到了。</p>
<pre class="mermaid">graph TB
subgraph CLR
    id2[公共语言运行库CLR] 
    id3[公共语言规范CLS]
    id4[基类库BCL]
      id5[元数据定义]
    id6[公告类型系统]
    id7[公共中间语言CIL指令组]
end</pre>

<p>CLI的重要组成部分是：</p>
<ol>
<li><strong>CTS（COmmon Type System ）</strong>：公共类型系统，定义了托管代码中一定会使用的类型特征。.net兼容的编程语言的类型通常会映射到CTS中已定义的类型。CTS最重要的特征是，所有类型都继承公共的基类 object,使用CTS可以确保系统类型和用户定义类型能被任何.net兼容的语言所使用</li>
<li><strong>CLS（COmmon Language Soecification）</strong>：公共语言规范，详细说明了.net兼任语言的规则和行为，包括参数传递，类结构，数据类型。</li>
</ol>
<h3 id="1-3-编译成本机代码并执行"><a href="#1-3-编译成本机代码并执行" class="headerlink" title="1.3 编译成本机代码并执行"></a>1.3 编译成本机代码并执行</h3><pre class="mermaid">graph LR;
    id0-->id7
    id7-->id1
    id1-->id2
    id2-->id3
    id3-->id5
    subgraph 编译时
    id0[c#源文件]
    id7[c#编译器]
    id1[程序集:A.类型信息 B.CIL]
    end
    subgraph 运行时
    id2[JIT编译器 公共语言运行库CLR]
    id3[本机代码]
    id5[操作系统服务]
    end</pre>

<p><strong>编译步骤</strong>：</p>
<ol>
<li>检查程序集的安全特性</li>
<li>在内存中分配空间</li>
<li>把程序集中的可执行代码发送给JIT，把其中一部分编译成本机代码。</li>
</ol>
<p><strong>需要注意的点：</strong></p>
<ul>
<li>程序集中的可执行代码只有在需要时才会有JIT编译，编译后被缓存起来以备后面的程序执行。不被调用的代码将不会被编译。并且被调用的代码只编译一次。</li>
<li>CIL被JIT编译为本机代码后，在运行时会被CLR管理，执行GC检查数组边界参数类型异常管理的任务。</li>
<li>CIL被调用运行时才会被编译成本机代码。</li>
</ul>
<p><strong>JIT(Just-in-Time):</strong>  实时编译器</p>
<p>Ngen工具可以将程序集转换成当前处理器的本机代码。Ngen处理过的代码可以免去运行时的JIT编译过程。</p>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>.net的框架的结构和缩写:</p>
<pre class="mermaid">graph TB
    subgraph 程序集
        id2[公共中间语言CILILMSIL]
    end
subgraph 公共语言基础结构
    id4[CTS公共类型系统]
    id5[CTS公共语言规范]
end
subgraph 公共语言运行库CLR
    id7[GC垃圾收集器]
    id8[JIT实时编译器]
    id9[BCL基类库]
end</pre>

<h3 id="1-5-Main方法"><a href="#1-5-Main方法" class="headerlink" title="1.5  Main方法"></a>1.5  Main方法</h3><p>C#程序必须有一个Main方法入口点。返回int值用于报告程序是否运行成功。agrs不会是null。而是一个没有元素的数组。Main可以被声明为private或public。</p>
<p>main总是声明为static，Main可以被声明类或结构。</p>
<p>Main不是关键字。</p>
<h2 id="二-格式规则"><a href="#二-格式规则" class="headerlink" title="二.格式规则"></a>二.格式规则</h2><h3 id="2-1-标识符"><a href="#2-1-标识符" class="headerlink" title="2.1 标识符"></a>2.1 标识符</h3><p>用来命名如变量，方法，参数等程序结构的字符串。命名上有一些规则：</p>
<ul>
<li>字幕和下划线可以用在任何位置。</li>
<li>数字不能放在首位，但是可以放在其他地方。</li>
<li>@字符只能放在标识符首位，虽然允许使用，但不推荐使用@做字符。</li>
<li>标识符区分大小写。</li>
</ul>
<h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h3><p><strong>定义：</strong></p>
<blockquote>
<p>关键字是预定义的保留标识符，对编译器有特殊意义。 除非前面有 <code>@</code> 前缀，否则不能在程序中用作标识符。 例如，<code>@if</code> 是有效标识符，而 <code>if</code> 则不是，因为 <code>if</code> 是关键字。</p>
</blockquote>
<p><strong>上下文关键字：</strong></p>
<blockquote>
<p>上下文关键字仅在一部分程序上下文中有特殊含义，可以在相应上下文范围之外用作标识符。 一般来说，C# 语言中新增的关键字会作为上下文关键字添加，以免破坏用旧版语言编写的程序。</p>
</blockquote>
<p>上下关键字是仅在特定语言结构中充当关键字的标识符，可以在代码的其他部分被用做标识符。</p>
<p>上下文关键字：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th style="text-align:right"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">add</td>
<td>ascending</td>
<td>async</td>
<td>await</td>
<td>by</td>
<td style="text-align:right">descending</td>
<td style="text-align:center">dynamic</td>
</tr>
<tr>
<td style="text-align:left">equals</td>
<td>from</td>
<td>get</td>
<td>global</td>
<td>group</td>
<td style="text-align:right">in</td>
<td style="text-align:center">into</td>
</tr>
<tr>
<td style="text-align:left">join</td>
<td>let</td>
<td>on</td>
<td>orderby</td>
<td>partial</td>
<td style="text-align:right">remove</td>
<td style="text-align:center">select</td>
</tr>
<tr>
<td style="text-align:left">set</td>
<td>value</td>
<td>var</td>
<td>where</td>
<td>yield</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<h3 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h3><p><strong>块：</strong></p>
<p>大括号包围的多条语句和序列，<strong>在语法上相当于一条语句</strong>。用于语法上只需要一条语句，但执行的动作无法用一条简单语句表达。</p>
<p><strong>WriteLine</strong>:</p>
<p>{0} {1} 这叫替换值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"aaaa &#123;0&#125; and &#123;1&#125;"</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>也可以：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"aaaa &#123;1&#125; and &#123;0&#125;"</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>不要试图引用替换值长度列以外位置的值，比如{2}</p>
<p><strong>格式化数字字符串</strong>：</p>
<p>这{1：C}叫格式说明符或者对齐说明符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;index(必选指定列表中的某一项),alignment(可选,指定字段宽度对齐):format(可选，指定项的格式)&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式说明符如：</span></span><br><span class="line">Console.WriteLine(<span class="string">"aaaa &#123;0:C&#125;"</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对齐说明符如：</span></span><br><span class="line"><span class="comment">//负数表示左对齐</span></span><br><span class="line">Console.WriteLine(<span class="string">"aaaa &#123;0,10&#125;"</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准的格式字段字符串形如:Axx，其中A代表格式说明符，XX代表精度</span></span><br><span class="line">Console.WriteLine(<span class="string">"aaaa &#123;0:F4&#125;"</span>,<span class="number">3.123</span>); <span class="comment">//像这种就表示显示四位小数点。</span></span><br></pre></td></tr></table></figure>
<p><strong>文档注释</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>这是说明</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>文档注释包含XML文本，可以生成程序文档。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="三-类型，存储和变量"><a href="#三-类型，存储和变量" class="headerlink" title="三.类型，存储和变量"></a>三.类型，存储和变量</h2><h3 id="3-1-CSharp的相关特点"><a href="#3-1-CSharp的相关特点" class="headerlink" title="3.1 CSharp的相关特点"></a>3.1 CSharp的相关特点</h3><p>c的程序是一组函数和数据类型，c++是一组函数和类，但是<strong>c#的程序(可执行程序或DLL)是一组类型声明。</strong></p>
<p>Main方法当然也是必须的，c#同时引入了命名空间:</p>
<p><strong>命名空间</strong>是一种把相关的类型声明分组并命名的办法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Game</span></span><br><span class="line">&#123;</span><br><span class="line">    DeclarationOfTypeA</span><br><span class="line">    DeclarationOfTypeB</span><br><span class="line">    <span class="keyword">class</span> <span class="title">C</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>*</strong>类就是一个模板，它本身并不是数据结构，但他说明了由模板构造的对象的特征。</p>
<h3 id="3-2-预定义类型"><a href="#3-2-预定义类型" class="headerlink" title="3.2 预定义类型"></a>3.2 预定义类型</h3><pre class="mermaid">graph TB

id6[简单类型]
id8[预定义类型]
id9[非数值类型]
id10[数值类型]
id11[整数类型]
id12[浮点类型]
id6---id10
id10---id11
id10---id12
id11---id13
id11---id15
id11---id17
id11---id18
id12---id20
id12---id21
id12---id22
id8---id6
id8---id2
id8---id3
id8---id4
id6---id9
id9---id5
id9---id7
subgraph  
    id2[object]
    id3[string]
    id4[dynamic]
end
subgraph    
id5[bool]
id7[char]
end
subgraph  
id20[decimal]
id21[float]
id22[double]
end
subgraph    
id13[8bit sbyte\byte]
id15[16bit short\ushort]
id17[32bit int\uint]
id18[ 64bitlong\along]
end</pre>

<p>常用的预定义简单类型:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>范围</th>
<th>.net框架类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>0~255 (2^8)</td>
<td>System.Byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>-32768~32767 (2^16)</td>
<td>System.Int16</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>-2147483638~2147483647 (2^32)</td>
<td>System.Int32</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>-9223372036854775808~<br>9223372036854775807 (2^64)</td>
<td>System.Int64</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>1.5<em>10^(-45) ~ 3.4 </em>10^(38)</td>
<td>Sytem.Single</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>5<em>10^(-324) ~ 1.7 </em>10^(308)</td>
<td>System.Double</td>
<td>0.0D</td>
</tr>
<tr>
<td>char</td>
<td>U+0000~U+ffffSystem.Char</td>
<td>System.Char</td>
<td>\ x0000</td>
</tr>
</tbody>
</table>
<p>c#的类型名称就是.net框架类型的别名。.net框架类型可以在c#中直接使用但不推荐。</p>
<p>和C/C++不一样，c#数字不具有布尔意义。</p>
<p>预定义类型可以直接用，如int，和用户类型不一样。</p>
<h3 id="3-3-用户类型"><a href="#3-3-用户类型" class="headerlink" title="3.3 用户类型"></a>3.3 用户类型</h3><p>除了16种预定义类型，还可以创建用户定义类型，有6种类型可以由用户自己创建:</p>
<ul>
<li>类类型(class)</li>
<li>结构类型(struct)</li>
<li>数组类型(array)</li>
<li>枚举类型(enum)</li>
<li>委托类型(delegate)</li>
<li>接口类型(interface)</li>
</ul>
<p><strong>*</strong>用户定义类型必须先声明后实例化。</p>
<h3 id="3-4-堆和栈"><a href="#3-4-堆和栈" class="headerlink" title="3.4 堆和栈"></a>3.4 堆和栈</h3><ul>
<li>栈是内存数组。</li>
<li>堆是一块内存区域，GC会自动清除堆对象。</li>
</ul>
<p>类型决定了对象的存储位置。类型有两种：值类型和引用类型。</p>
<ul>
<li>值类型存放在栈里。</li>
<li>引用类型需要两块内存，一个存实际的数据，在堆中。另一个存引用，指向堆的存放位置，可能在堆中也可能在栈中。</li>
</ul>
<p><strong>*</strong>对于一个引用类型，其实例数据部分始终存放在堆里，无论值还是引用</p>
<table>
<thead>
<tr>
<th>变量类型</th>
<th>存储位置</th>
<th>自动初始化</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>本地变量</td>
<td>栈或者栈和堆</td>
<td>否</td>
<td>用于函数成员内部的本地计算</td>
</tr>
<tr>
<td>类字段</td>
<td>堆</td>
<td>是</td>
<td>类的成员</td>
</tr>
<tr>
<td>结构字段</td>
<td>栈或堆</td>
<td>是</td>
<td>结构的成员</td>
</tr>
<tr>
<td>参数</td>
<td>栈</td>
<td>否</td>
<td>用于把值传入或传出方法</td>
</tr>
<tr>
<td>数组元素</td>
<td>堆</td>
<td>是</td>
<td>数组的成员</td>
</tr>
</tbody>
</table>
<p><em>注意：</em></p>
<ul>
<li>dynamic关键字的类型在运行时才会被解析。</li>
<li>c#和c++不同，不能再类型的外部声明全局变量。所有的字段都属于类型。也没有全局方法（在类型的外部)。</li>
</ul>
<h3 id="3-5-可空类型"><a href="#3-5-可空类型" class="headerlink" title="3.5 可空类型"></a>3.5 可空类型</h3><p>可空类型总是基于基础类型（underlying type）的已经被声明的类型。可以把值类型的变量设置为null，和引用类型的null的创建和使用方法都不同。</p>
<ul>
<li>可以从任何值类型创建可空类型，包括预定义的简单类型。</li>
<li>不能从引用类型或其他可空类型创建可空类型。</li>
<li>不能显示声明可空类型，只能声明可空类型的变量。</li>
</ul>
<p>使用方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>? a = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span>(a != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    somthing</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    somthing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会产生可空类型并关联变量类型，此时可空类型内包括：</p>
<ul>
<li>HasValue</li>
<li>Value</li>
<li>基础类型对象（int 28）</li>
</ul>
<p>三种类型的值可以赋值给可空类型变量：</p>
<ul>
<li>基础类型的值</li>
<li>同一可空类型</li>
<li>null值</li>
</ul>
<p>使用空接合运算符，允许在可空类型变量为null时返回一个值给表达式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WtriteLine(<span class="string">"My :&#123;0&#125;"</span>,a ?? <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>使用可空的结构体类型：</p>
<p>结构的可空形式只通过Value属性暴露基础类型，不直接暴露它的任何成员。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">mstruct.x</span><br><span class="line">mnull.Value.x</span><br></pre></td></tr></table></figure>
<h2 id="四-方法"><a href="#四-方法" class="headerlink" title="四.方法"></a>四.方法</h2><p><strong>*</strong>方法体也是个块</p>
<h3 id="4-1-变量的生存周期"><a href="#4-1-变量的生存周期" class="headerlink" title="4.1 变量的生存周期"></a>4.1 变量的生存周期</h3><table>
<thead>
<tr>
<th></th>
<th>实例字段</th>
<th>本地变量</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>生存期</strong></td>
<td>从实例被创建开始</td>
<td>从它在块中被声明的那点开始，在块完成执行时结束。</td>
</tr>
<tr>
<td><strong>隐式初始化</strong></td>
<td>初始化该类型的默认值</td>
<td>没有隐式初始化。未初始化尝试使用编译器会报错。</td>
</tr>
<tr>
<td><strong>存储区域</strong></td>
<td>实例字段是类的成员，所以所有字段都存在堆里。无论是值类型还是引用类型。</td>
<td>值类型：栈。引用类型：引用存在栈里，数据存在堆里。</td>
</tr>
</tbody>
</table>
<p><strong>*</strong>c#和c++不一样 不允许在第一个有效范围内声明另一个同名本地变量。</p>
<h3 id="4-2-隐式类型"><a href="#4-2-隐式类型" class="headerlink" title="4.2 隐式类型"></a>4.2 隐式类型</h3><ul>
<li>在方法范围内声明的变量可以具有隐式类型var。var关键字不是特定类型变量的符号，只是语法速记。表示可以从右侧推断出类型。</li>
<li>隐式类型本地变量为强类型。</li>
<li>var只能用于本地变量，不能用于字段，只能在变量声明中包括初始化时使用，一旦推断出类型则是固定不可更改的。</li>
<li>和js的var不一样。</li>
</ul>
<h3 id="4-3-Const关键字"><a href="#4-3-Const关键字" class="headerlink" title="4.3 Const关键字"></a>4.3 Const关键字</h3><ul>
<li>const 是核心声明的一部分必须放在类型前面。</li>
<li>必须有初始化语句，变量必须在声明时初始化，且以后不能改变。</li>
<li><strong>const也可以是null，但不能是某个对象的引用，因为对象的引用是在运行时决定的。</strong></li>
</ul>
<h3 id="4-4-参数"><a href="#4-4-参数" class="headerlink" title="4.4 参数"></a>4.4 参数</h3><p><strong>形参和实参</strong></p>
<p>形参（形式参数）：</p>
<ul>
<li>方法的定义中的参数，一个占位符。没有数据，等到方法调用时接受传过来的参数。</li>
<li>只有在方法被调用时才会分配内存，方法调用结束后立即释放内存。</li>
</ul>
<p>实参（实际参数）：</p>
<ul>
<li>调用时传给形参。</li>
<li>实参必须有确切的值。</li>
<li>如果存在和形参类型的兼容，那么实参的类型可以和形参不一致。</li>
</ul>
<p><strong>值传递参数和引用传递参数</strong></p>
<p>值传递参数：</p>
<ul>
<li>把实参的值复制给形参。引用类型的实参会复制引用，对于值类型会复制值。</li>
<li>通过值传递参数，系统在栈上为形参分配内存。</li>
</ul>
<p>引用传递参数：</p>
<ul>
<li>引用传递参数不会在栈上分配内存，实际上，形参的参数名作为了实参变量的别名。指向相同的内存位置。所以修改了形参就是在修改实参。可以理解为C中的指针。</li>
<li>声明和调用使用ref修饰符。</li>
<li>实参同时必须是变量，在用作实参前必须被赋值。必须是变量的意思是 ，Function(ref 3+4)这种是不可以的。</li>
</ul>
<p><strong>*</strong>数组作为实参传递，便一起会使用实参数组而不是创建新的</p>
<p><strong>引用类型作为值传递参数和引用传递参数</strong></p>
<p>无论是值参数还是引用参数，都可以在方法内部修改它的成员。但实质上还是有区别的。</p>
<p>作为值参数传递：</p>
<p>如果在方法内创建一个新对象并赋值给形参，实参和形参的关联会切断。 方法调用结束后，新对象也就不在了。</p>
<pre class="mermaid">graph TB;
    subgraph 2对成员赋值后
    id4[栈:ref:f1]
    id5[栈:ref:a1]
    id6[堆:Val 20]
    id4-->id6
    id5-->id6
    end
    subgraph 1调用开始时
    id1[栈:ref:f1]
    id2[栈:ref:a1]
    id3[堆:Val 50]
    id1-->id3
    id2-->id3
    end</pre>

<pre class="mermaid">graph TB;
    subgraph 4方法完成后
    id5[栈:ref:a1]
    id6[堆:Val 50]
    id5-->id6
    end
    subgraph 3创建新对象并赋值给形参之后
    id1[栈:ref:f1]
    id2[栈:ref:a1]
    id3[堆:Val 20]
    id4[堆:Val 50]
    id1-->id3
    id2-->id4
    end</pre>

<p>作为引用参数传递:</p>
<p>如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。</p>
<p><strong>输出参数</strong></p>
<p>输出参数用于方法体内把数据传出到调用代码,必须在声明和调用中都使用out修饰符。输出参数out，我个人理解和ref是不同功能的，out参数主要是为了将方法中的变量传出，而ref是为了将变量传入方法。</p>
<ul>
<li>实参同时也必须是变量（out 3+5 不可以），不能是其他类型的表达式，因为方法需要内存位置保存返回值。</li>
<li>和引用参数相似，形参担当实参的别名，实参和形参是同一块内存。所以对形参的更改会改变实参。</li>
</ul>
<p>输出参数有几个要求：</p>
<ul>
<li>在方法中，输出参数在能够被读取前<strong>必须被赋值</strong>。这意味着参数的初始值是无关的，并且没必要在方法调用之前为实参赋值。</li>
<li>在方法返回前，内部贯穿的任何可能路径都必须为所有输出参数进行一次赋值。</li>
<li>此外，因为在方法内读取输出变量之前必须对其写入，所以不可能使用输出参数把数据传入方法。如果在赋值之前试图读取他，编译器会有错误信息。</li>
</ul>
<p><strong>参数数组</strong></p>
<p>关键字params，允许零个或多个实参对应一个特殊的形参，注意的点：</p>
<ul>
<li>参数列表中只能有一个参数数组。并且是最后一个</li>
<li>参数数组表示的所有参数必须有相同的类型。</li>
<li>params修饰符不需要在调用时使用。</li>
</ul>
<p>格式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInts</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">int</span>[] invals</span>)</span></span><br></pre></td></tr></table></figure>
<p>可以通过两种方式给参数数组传参：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ListInts（<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>）；</span><br><span class="line"><span class="keyword">int</span>[] intarray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ListInts（intarray）;</span><br></pre></td></tr></table></figure>
<p>一些补充：</p>
<ul>
<li>参数数组是一个数组，数组是引用类型，所以所有数据都保存在堆中。</li>
<li>如果对应的形参数组没有实参，编译器会创建一个有零个元素的数组使用。</li>
<li>当数组在堆中被创建时，实参的值是被<strong>复制</strong>到数组中，像值传递参数。</li>
<li>如果数组是值类型，则值被复制，实参不受方法内部影响。</li>
<li>如果数组是引用类型，那引用被复制，实参可能会收到方法内部影响。</li>
</ul>
<p><strong>命名参数和位置参数</strong></p>
<p>一般的方法，实参和形参的顺序一致。称为位置参数。</p>
<p>还有一种，只需要要指定参数的名字，就可以任意顺序在方法调用中列出实参。叫做命名参数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Method(c:<span class="number">2</span>,a:<span class="number">4</span>,B:<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>可以同时使用位置参数和命名参数，但位置参数必须先列出来。</p>
<p><strong>可选参数</strong></p>
<p>表明某个参数是可选的，需要在方法声明时为参数提供默认值。不是所有的参数类型都可以作为可选参数：</p>
<ul>
<li>只有值类型的默认值可以在编译时确定，才可以将值类型作为可选参数</li>
<li>只有默认值是null的时候引用类型才可以作为可选参数使用（意思是只能在方法签名上将此形参标记为null，而不是在签名中去尝试new这个引用类型。）</li>
<li>可选参数只能是值类型。</li>
</ul>
<p>对于方法签名：所有必填参数必须在可选参数声明之前声明，如果有params参数必须在所有可选参数之后声明。</p>
<p>对于调用方法：省略参数必须在最后开始，也就是说不能前面省略，后面不省略。如果需要随意省略可选参数，必须使用命名参数的特性来实现，使用可选参数的名字来消除歧义。</p>
<ul>
<li><p><strong>参数类型语法使用总结</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">参数类型</th>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">是否在声明时使用</th>
<th style="text-align:center">是否在调用时使用</th>
<th style="text-align:center">执行</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">值</td>
<td style="text-align:center">无</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">系统把实参的值复制到形参</td>
</tr>
<tr>
<td style="text-align:center">引用</td>
<td style="text-align:center">ref</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">仅包含一个返回的值。形参是实参的别名。</td>
</tr>
<tr>
<td style="text-align:center">输出</td>
<td style="text-align:center">out</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">仅包含一个返回的值。形参是实参的别名</td>
</tr>
<tr>
<td style="text-align:center">数组</td>
<td style="text-align:center">params</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">允许传递可变数目的实参到方法。</td>
</tr>
</tbody>
</table>
<h3 id="4-6-重载"><a href="#4-6-重载" class="headerlink" title="4.6 重载"></a>4.6 重载</h3><p>注意重载的讲解放入在方法章节中，可以作为提醒:重载是方法的一个性质，和类无关。</p>
<p>（突然想到，c支持重载吗？）</p>
<ul>
<li>重载必须有和其他方法不一样的签名，签名包括：方法名称，参数数目，参数数据类型和顺序，参数修饰符。</li>
<li><strong>返回类型不是签名的一部分，形参的名称也不是签名的一部分。</strong></li>
</ul>
<h3 id="4-7-栈帧"><a href="#4-7-栈帧" class="headerlink" title="4.7 栈帧"></a>4.7 栈帧</h3><p>调用方法时内存从栈的顶部开始分配，保存和方法关联的数据项。这块内存叫<strong>栈帧</strong>(stack frame)。栈帧包括如下内容：</p>
<ul>
<li>返回地址，方法退出时继续执行的位置。</li>
<li>方法的值参数，或者参数数组。</li>
<li>和方法调用相关的其他数据管理项。</li>
</ul>
<p>栈帧的展开过程：</p>
<pre class="mermaid">graph TB
    subgraph 从栈中弹出Methoda
    id10["Main()"]
    end
    subgraph 从栈中弹出MethodB
    id8["Main()"]
    id9["MethodA()"]
    end
    subgraph 从Main调用MethodB
    id2["Main()"]
    id3["MethodA()"]
    id4["MethodA()"]
    end
subgraph 从Main调用MethodA
    id4["Main()"]
    id5["MethodA()"]
end
subgraph 开始执行Main 
    id7["Main()"]
end</pre>

<p><strong>*</strong>递归的调用会产生很多不同的独立栈帧。</p>
<h2 id="五-类"><a href="#五-类" class="headerlink" title="五.类"></a>五.类</h2><p>类成员类型有9种：</p>
<ul>
<li>数据成员：字段，常量</li>
<li>函数成员：方法，属性，运算符，构造函数，析构函数，事件，索引</li>
</ul>
<p>声明类成员的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[特性][修饰符]核心声明</span><br></pre></td></tr></table></figure>
<p>多个特性和多个修饰符内部可以顺序随意，但整体上必须是这个顺序。</p>
<p>c#是单继承，但继承的层次没有限制。所有类都派生自object类，即使没有任何基类规格说明继承的类。object是唯一的非派生类，它是继承层次结构的基础。没有基类规格说明的类隐式派生自object。</p>
<p>派生类的实例由基类的实例加上派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分。</p>
<h3 id="5-1静态成员"><a href="#5-1静态成员" class="headerlink" title="5.1静态成员"></a>5.1静态成员</h3><p><strong>Static 静态变量 </strong>：</p>
<p>可修饰的类型不限，声明和构造方法种初始化，运行时是常量，只是使变量持有的引用不可变。初次构造后就确定了值。</p>
<ul>
<li>静态字段被类的所有实例共享，所有实例都访问内存同一位置。</li>
<li>如果静态字段有初始化语句，那会在使用任何静态成员之前初始化该字段。但是不会在程序执行开始就初始化。</li>
<li>静态方法不能访问实例成员，但是能访问其他静态成员。</li>
<li>静态的成员当然也是在堆上。</li>
</ul>
<p><strong>const常量</strong>：</p>
<p>可修饰基本类型，声明的时候初始化，是常量。使用时不需要加载到内存。</p>
<ul>
<li>成员常量不能被声明为静态的。</li>
<li>成员常量和本地常量差不多。同时成员常量的值必须是编译时可计算的。</li>
<li>和静态量不同，常量没有自己的存储位置，而是在编译时被编译器替换，类似于c和c++的define。</li>
</ul>
<h3 id="5-2-属性"><a href="#5-2-属性" class="headerlink" title="5.2 属性"></a>5.2 属性</h3><p>属性不为数据存储分配内存，和字段不同，它是执行代码的。属性上不允许有除了get和set以外的其他方法，同时，访问器不能显示调用。</p>
<p>set 和 get访问器有预定义的语法和语义。set有一个隐式的值参数value，返回类型是void。get没有参数，且get所有路径必须包含一条return语句，返回和属性相同的类型。</p>
<p>属性和字段的区别：</p>
<ul>
<li>属性是函数性成员不是数据成员。允许处理输入输出。字段不行</li>
<li>属性可以只读或者只写，字段不行。</li>
<li>编译后的变量和编译后的属性语义不同，这意味着将公共字段改为属性后，访问这个字段的其他程序集都需要编译。如果属性本身做一些更改，那不需要重新编译访问它的其他程序集。</li>
</ul>
<p><strong>自动实现属性</strong></p>
<p>允许只声明属性而不声明后备字段。编译器会创建隐藏的后备字段，并自动挂接到get和set访问器上。自动属性使开发者在倾向于声明一个公有字段的地方很容易的插入一个属性。</p>
<ul>
<li>不声明后备字段，编译器根据属性的类型分配存储。</li>
<li>不能提供访问器的方法体。也就是不能实现get和set。</li>
<li>除非通过访问器，否则不能访问后备字段。所以实现只读和只写属性没有意义，因此必须同时提供读写访问器。</li>
</ul>
<p>静态属性：不能访问实例成员，只能被实例成员访问。不管有没有实例都是存在的。外部访问使用类名。</p>
<p>自动实现属性这个在具体开发的时候才能深刻理解到它存在的必要性，非常方便。</p>
<h3 id="5-3-构造方法"><a href="#5-3-构造方法" class="headerlink" title="5.3 构造方法"></a>5.3 构造方法</h3><p>构造函数声明为public可以从类的外部创建实例，需要注意的点：</p>
<ul>
<li>构造函数没有返回值。</li>
<li>构造函数可以被重载。</li>
<li>如果用户声明了任何构造方法，则编译器不会提供默认的构造方法。</li>
<li>构造方法可以声明为static，用于初始化类级别的项，静态字段这种。</li>
</ul>
<p><strong>静态构造方法</strong>：</p>
<ul>
<li>类中只能有一个静态构造函数，而且不能带参数。</li>
<li>静态构造函数不能有任何访问修饰符。</li>
<li>静态构造函数和静态方法一样，不能访问实例成员，因此不能使用this访问器</li>
<li>不能从程序中显示调用静态构造方法，系统会自动调用它，在：引用任何静态成员之前，创建类的任何实例之前。</li>
</ul>
<p><strong>对象初始化</strong></p>
<p>两种初始化方法：</p>
<ul>
<li>new xxx()</li>
<li>new xxx(){在此初始化设置公有字段的值}  大括号里就是初始化。这种方式也叫对象初始化语句，扩展了对象创建的语法。</li>
</ul>
<p><strong>*</strong>需要注意，初始化发生在构造方法执行之后，因此构造方法中设置的值可能会在之后对象初始化中重置为相同或不相同的值。</p>
<h3 id="5-4-析构函数"><a href="#5-4-析构函数" class="headerlink" title="5.4 析构函数"></a>5.4 析构函数</h3><p>执行类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源是指通过win32api获得的文件句柄。与c++不同，c#的析构函数不会在实例超出作用域时立即调用，你无法知道何时会调用析构函数。</p>
<p>如果希望代码中包含的非托管资源释放的越快越好，应该使用标准dispose模式：</p>
<ul>
<li>包含非托管的类应该实现IDisposable接口，后者包含单一方法dispose。</li>
<li>如果需要释放资源，在代码中调用dispose。（不是系统主动调用）</li>
<li>类还需要实现一个析构函数，在其中调用dispose方法。</li>
</ul>
<p>标准的格式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Myclass</span>:<span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> disposed = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dispose(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//如果主动调用了Dispose，应该通知GC不要再调用析构函数。</span></span><br><span class="line">        GC.SuppressFinaliza(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数也调用Dispose，防止没有被调用Dispose。</span></span><br><span class="line">    ~MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实际清除的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(disposed == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(disposing == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果是主动调用，释放托管资源</span></span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是析构函数调用，释放非托管资源</span></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-6-readonly修饰符"><a href="#5-6-readonly修饰符" class="headerlink" title="5.6 readonly修饰符"></a>5.6 readonly修饰符</h3><p>字段可以用readonly修饰符声明，作为类似const，一旦值被设定就不能改变。但有一些却别：</p>
<ul>
<li>const字段只能在声明语句中初始化，readonly可以在声明语句和任何构造函数中初始化。但如果readonly的字段是static的则需要在静态构造函数中初始化。</li>
<li>const字段的值必须在编译的时候决定，但readonly可以在运行时决定。也就是说可以在不同的构造方法中设置不同的值。</li>
<li>const的行为总是静态的，但readonly可以是实例字段，也可以是静态字段，并且在内存中有存储位置。</li>
</ul>
<h3 id="5-7-this关键字"><a href="#5-7-this关键字" class="headerlink" title="5.7 this关键字"></a>5.7 this关键字</h3><p>在类中使用，对当前实例的引用。只能被用在实例构造函数、实例方法、属性和索引器的实例访问器中。this的目的是区分类的成员和本地变量或者参数，或者作为调用方法的实参。</p>
<p>*不能再静态方法中使用this。</p>
<h3 id="5-8-索引器"><a href="#5-8-索引器" class="headerlink" title="5.8 索引器"></a>5.8 索引器</h3><p>和属性的比较：</p>
<ul>
<li>和属性一样，不用分配内存来存储。</li>
<li>索引器和属性都是主要被用来访问其他数据成员。</li>
<li>属性通常表示单独的数据成员，索引通常表示多个数据成员。</li>
</ul>
<p>*索引器不能被声明为static</p>
<p>需要注意：</p>
<ul>
<li><p>索引器没有名称，在名称的位置是关键字this。</p>
</li>
<li><p>参数列表在方括号中间。</p>
</li>
<li><p>参数列表至少声明一个参数。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ReturnType <span class="keyword">this</span>[ Type param1,....]</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">set</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>索引器的set访问器接受两项数据：</strong></p>
<ul>
<li>隐式参数value持有的要保存的数据，</li>
<li>一个或更多索引参数表示数据应该保存到哪。</li>
</ul>
<p>set访问器的含义:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span>(<span class="params">ParameterList,Type <span class="keyword">value</span></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>get访问器必须检查索引参数确定他表示哪个字段，并返回字段值。get访问器的含义:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span>(<span class="params">ParameterList</span>)</span>&#123;<span class="keyword">return</span> ValueOftype&#125;</span><br></pre></td></tr></table></figure>
<p>*和属性一样，set和get是不能显示调用的，当索引器在表达式中取值时将自动调用get，赋值时自动调用set。</p>
<p>索引器的例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Empolyee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FirstName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> City;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(idnex)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:lastName = <span class="keyword">value</span>; <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeexception(<span class="string">"index"</span>);&#125;&#125;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> LastName; <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeexception(<span class="string">"index"</span>);&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>*索引器可以重载，一定要保持有不同的参数列表:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp1;</span><br><span class="line">    <span class="keyword">int</span> tmp2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;   ... &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;   ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">this</span>[<span class="keyword">int</span> index，<span class="keyword">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;...&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-9-访问器的修饰符"><a href="#5-9-访问器的修饰符" class="headerlink" title="5.9 访问器的修饰符"></a>5.9 访问器的修饰符</h3><p>*注意是访问器，是属性和索引中的访问器。</p>
<p>属性和索引器是函数成员，并自带了get和set访问器。可以通过对get和set设置不同的访问级别，是对象的外部只能读取该属性而不能写入，这是一个非常重要的封装工具。在实际的开发中很常用这种封装方法。</p>
<p>但要注意，必须同时有gat和set访问器时，访问器才能有修饰符，并且只能有一个访问修饰符。访问器的修饰符必须比成员的级别更严格。 也就是访问器的访问级别必须要比成员的访问级别的位置低，也不能等于属性的访问级别。</p>
<p>访问级别：</p>
<pre class="mermaid">graph LR
id0[public]-->id1[protected internal]
id1-->id2[protected]
id1-->id3[internal]
id2-->id4[private]
id3-->id4[private]</pre>

<h3 id="5-10-分部类和分部类型"><a href="#5-10-分部类和分部类型" class="headerlink" title="5.10 分部类和分部类型"></a>5.10 分部类和分部类型</h3><p>分部类可以声明在不同或相同的文件中，局部声明要被标注为partial class。partial不是关键字，在程序中可以用于标识符。但在class struct（局部结构），interface（局部借口）前它表示分布类型。</p>
<p><strong>分部方法：</strong></p>
<p>分布方法是声明在分部类中不同部分的方法，也可以声明在同一个类中，分为两个部分：</p>
<ul>
<li>定义分布方法声明：给出签名和返回类型，声明的实现部分知识一个分号。</li>
<li>实现分部方法声明：给出签名和返回类型，是以正常形式的语句块实现。</li>
</ul>
<p>需要注意的内容：</p>
<p>定义和实现的签名和返回类型必须匹配。返回类型必须是void，签名不能包括访问修饰符，也就是说分部方法是私有的，列表不能包含out参数。定义和实现必须包含上下文关键字partial，直接放在关键字void之前。可以有定义而没有实现，但编译器会把方法的声明以及方法内部任何对方法的调用移除。</p>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"><span class="keyword">int</span> x , <span class="keyword">int</span> y</span>)</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        PrintSum(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        console.writeLine(<span class="string">"xxx:"</span> , x +y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-11-屏蔽基类成员"><a href="#5-11-屏蔽基类成员" class="headerlink" title="5.11 屏蔽基类成员"></a>5.11 屏蔽基类成员</h3><p>无法删除父类的任何成员，但是可以通过声明和父类一样名字的成员来屏蔽基类成员：</p>
<ol>
<li>声明一个相同名称相同类型的成员</li>
<li>屏蔽方法需要在派生类中声明新的带有相同签名的函数成员。</li>
<li>使用new修饰符告诉编译器正在故意屏蔽继承的成员，否则程序会成功编译，但会警告你隐藏了一个继承的成员。</li>
</ol>
<p><strong>*</strong>签名是有名称和参数列表组成，不包括返回类型。</p>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Someclass</span></span><br><span class="line"> ｛</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> a;</span><br><span class="line">   ｝</span><br><span class="line"><span class="keyword">class</span> <span class="title">someclass2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">public</span> <span class="keyword">string</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用基类访问（base access）表达式访问隐藏的继承成员。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"&#123;0&#125;"</span> , <span class="keyword">base</span>.a);</span><br></pre></td></tr></table></figure>
<p>*屏蔽基类成员再使用基类访问，并不是好的设计方式</p>
<h3 id="5-12虚方法和覆写方法"><a href="#5-12虚方法和覆写方法" class="headerlink" title="5.12虚方法和覆写方法"></a>5.12虚方法和覆写方法</h3><p>基类引用调用派生类（derived class）方法：</p>
<ol>
<li>派生类的方法和基类的方法有享用的签名和返回类型</li>
<li>基类的方法使用virtual标注</li>
<li>派生类的方法使用override标注</li>
</ol>
<p>*注意此方式和new隐藏基类成员在行为上的区别。</p>
<p>需要注意：</p>
<ul>
<li>覆写和被覆写的方法必须具有相同的可访问性。</li>
<li>不能覆写static方法或非虚方法</li>
<li>方法，属性，索引器，以及事件，都可以被声明为virtual和override</li>
</ul>
<p><strong>覆写标记为override的方法</strong></p>
<p>覆写方法可以在继承的任何层次出现，对象的基类部分引用调用一个被覆写的方法时，方法会执行标记为override的方法的最高派生版本。若更高的派生级别有该方法的其他声明，但没标记override，则不会被调用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Class MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Virtual <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">	   <span class="comment">//输出 base</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Class myderivedClass:MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">	 <span class="comment">//输出derivedclass</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Class SecondDervied:MyDerivedClass</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="comment">//输出Second</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几种情况：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.SecondDervied的Print是正常覆写的。</span></span><br><span class="line">SecondDervied secd = <span class="keyword">new</span> SecondDervied() </span><br><span class="line">MyBaseClass mybb = （ MyBaseClass）d；</span><br><span class="line"></span><br><span class="line">secd.print  <span class="comment">//调用的是SecondDervied的方法，这是正常的</span></span><br><span class="line">mybb.print <span class="comment">//调用的也是SecondDervied的方法</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.使用new声明sec类的Print</span></span><br><span class="line"></span><br><span class="line">SecondDervied d = <span class="keyword">new</span> SecondDervied() </span><br><span class="line">MyBaseClass b = （ MyBaseClass）d；</span><br><span class="line"></span><br><span class="line">d.print  <span class="comment">//调用的是SecondDervied 的方法，这是正常的</span></span><br><span class="line">b.print <span class="comment">//调用的是myderivedClass的方法，也就是说，只向上传递了一级到了myderivedClass override的print方法。sec类的print方法被new屏蔽掉了无法调用。</span></span><br></pre></td></tr></table></figure>
<p>*属性，事件索引器也是可以被覆写的。</p>
<p><strong>一些问题</strong></p>
<ol>
<li>b可以调用SecondDervied 的方法，是因为它虽然是父类的引用，但堆上有子类的数据所以可以调用子类的方法。如果只是单纯的new了一个父类，是不是就没法调用子类的方法了？</li>
<li>覆写到底是什么，和覆盖的区别是</li>
<li>覆写，覆盖，重载？</li>
</ol>
<h3 id="5-13-构造函数的执行"><a href="#5-13-构造函数的执行" class="headerlink" title="5.13 构造函数的执行"></a>5.13 构造函数的执行</h3><ul>
<li>调用对象的基类部分，需要隐式调用基类的某个构造函数作为创建实例过程的一部分。</li>
<li>继承层次中的每个类在执行自己的构造方法之前执行它的基类构造方法。</li>
<li>构造方法中调用虚方法是及其不推荐的。</li>
</ul>
<p><strong>一些问题：</strong></p>
<p>如果基类的构造方法没有无参的怎么办还会自动调用吗</p>
<p><strong>指定构造方法</strong></p>
<p>派生类使用指定的基类构造函数，或使用指定的派生类构造方法，有两个办法：</p>
<ol>
<li><p>使用关键字base并指明使用哪一个基类构造函数 </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">Public <span class="title">aclass</span>(<span class="params"><span class="keyword">int</span> x</span>):<span class="title">base</span>(<span class="params">x</span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用关键字this,并指明使用父类的哪一个构造函数</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">Public <span class="title">aclass</span>(<span class="params"><span class="keyword">int</span> x</span>):<span class="title">this</span>(<span class="params">x,<span class="string">"dadasdad"</span></span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>*</strong>this的一个用处是从多个构造函数中抽离出公用的构造方法代码，书中很推荐这种做法。</p>
<p><strong>*</strong>还有一种写法，但并不是好办法。抽离出代码，只作为一个公共方法，而不是公共构造方法，这样的坏处有两点：一是编译器知道方法是构造方法后会进行一些优化，第二有些事必须在构造方法中执行，比如readonly字段只能在构造方法中初始化。</p>
<p><strong>*</strong>当然，如果this抽离的公共构造方法可以初始化类所需要的所有东西，那也可以作为独立有效的构造方法，反之可以设置成private，只能让其他构造方法调用。</p>
</li>
</ol>
<h3 id="5-14-类的访问级别"><a href="#5-14-类的访问级别" class="headerlink" title="5.14 类的访问级别"></a>5.14 类的访问级别</h3><p>类的可访问级别有两种：public和internal。标记为internal的类只能被其所在的程序集中的类看到（程序集不是程序也不是dll，第二十一章讲）。</p>
<p>*类和成员的访问修饰符是有区别的</p>
<h3 id="5-15-程序集间的继承"><a href="#5-15-程序集间的继承" class="headerlink" title="5.15 程序集间的继承"></a>5.15 程序集间的继承</h3><p>c#可以从不同的程序集内定义的基类来派生类，不同的程序集派生类需要几个条件：</p>
<ol>
<li>基类必须为public，这样才能在外部访问。</li>
<li>在vs工程中的reference节点添加对包含该基类的程序集的引用。</li>
</ol>
<p><strong>*</strong>放置一个using指令，带上要访问的类或类型所在的命名空间就可以不使用完全限定名称。</p>
<p><strong>*</strong>增加对其他程序集的引用和using指令是两回事。增加引用是告诉编译器所需的类型在哪定义，using只是允许不使用完全限定名称而已。</p>
<h3 id="5-16-成员访问修饰符"><a href="#5-16-成员访问修饰符" class="headerlink" title="5.16 成员访问修饰符"></a>5.16 成员访问修饰符</h3><p>b类能否访问a类成员，取决于a类的两个特征：</p>
<ol>
<li>B是否派生自A。</li>
<li>.B是否和A在同一个程序集。</li>
</ol>
<p>成员默认的访问级别是private，不能比类有更高级别的访问性。</p>
<p><strong>成员可访问性需要注意的点：</strong></p>
<ul>
<li>private类成员只能被自己的类成员访问，不能被继承的类访问。但private类能被嵌套类访问。</li>
<li>protected的访问级别和private差不多，但它允许派生类访问该成员。（程序集外部继承也能访问）</li>
<li>internal对程序集内部的所有类可见，对程序集外部的类不可见。</li>
<li>Protect internal 对所有继承该类以及程序集内部的类可见。是并集，不是交集。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">只在类的内部可访问。</td>
</tr>
<tr>
<td style="text-align:center">internal</td>
<td style="text-align:center">对该程序集内所有类可访问。</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">对所有继承该类的类可访问。</td>
</tr>
<tr>
<td style="text-align:center">protected internal</td>
<td style="text-align:center">对所有继承该类或在该程序集内声明的类可访问</td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">对任何类可访问。</td>
</tr>
</tbody>
</table>
<h3 id="5-17-抽象成员"><a href="#5-17-抽象成员" class="headerlink" title="5.17 抽象成员"></a>5.17 抽象成员</h3><p>抽象成员是被设计为覆盖的函数成员（字段和常量不可以）。</p>
<p><strong>需要注意的点：</strong></p>
<ul>
<li>必须用abstract修饰符标记。不能实现代码。</li>
<li>抽象成员只能在抽象类中声明。方法，属性，事件，索引可以被声明为抽象的。</li>
<li>virtual修饰符不能被附加到abstract。</li>
<li>实现派生类抽象成员，必须指定override修饰符。</li>
</ul>
<p>比较虚成员和抽象成员</p>
<table>
<thead>
<tr>
<th></th>
<th>虚成员</th>
<th>抽象成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键字</td>
<td>virtual</td>
<td>abstract</td>
</tr>
<tr>
<td>实现体</td>
<td>有实现体。</td>
<td>没有实现体，分号代替。</td>
</tr>
<tr>
<td>在派生类中被覆写</td>
<td>能被覆写，使用override。</td>
<td>必须被覆写，使用override。</td>
</tr>
<tr>
<td>成员的类型</td>
<td>方法，属性，事件，索引器。</td>
<td>方法，属性，事件，索引器。</td>
</tr>
</tbody>
</table>
<h3 id="5-17-抽象类"><a href="#5-17-抽象类" class="headerlink" title="5.17 抽象类"></a>5.17 抽象类</h3><p>抽象类是被设计为继承的类。抽象类只能被用作其他类的基类。</p>
<p>注意的几点：</p>
<ul>
<li>不能创建抽象类的实例。</li>
<li>抽象类使用abstract修饰符声明。</li>
<li>抽象类可以包含抽象成员和普通成员。</li>
<li>抽象类可以派生自另一个抽象类。</li>
<li>派生自抽象类的类必须使用override关键字实现抽象类的所有抽象成员，除非派生类也是抽象的。</li>
</ul>
<h3 id="5-18-密封类"><a href="#5-18-密封类" class="headerlink" title="5.18 密封类"></a>5.18 密封类</h3><p>sealed只能被用作独立的类，不能被当作基类。继承密封类编译器会报错</p>
<h3 id="5-19-静态类"><a href="#5-19-静态类" class="headerlink" title="5.19 静态类"></a>5.19 静态类</h3><p>静态类中所有成员都是静态的。数学库这样的类就很适合作为静态库。</p>
<p>注意的几点：</p>
<ul>
<li>类必须标记为static</li>
<li>所有成员必须是静态的</li>
<li>类可以有一个静态构造函数但不能有实例构造函数。</li>
<li>静态类是隐式密封的。</li>
<li>静态类的成员是用过类名调用。</li>
</ul>
<h3 id="5-20-嵌套类"><a href="#5-20-嵌套类" class="headerlink" title="5.20 嵌套类"></a>5.20 嵌套类</h3><p>在另一个类型中声明的类型叫做可嵌套类型，嵌套类型像封闭类型的成员一样声明。</p>
<p>嵌套指的是声明的位置，而不是内存对象的位置。实际上是和包裹他的类在堆上的同一位置。</p>
<p>嵌套类型有成员访问级别，而不是类型访问级别。默认访问级别是private，不能被封闭类型以外的类型所见。不管封闭类型的成员声明什么级别，嵌套类型都能访问这些成员，但封闭类型的成员不能完全访问嵌套类型的成员，访问权限受限于嵌套类型的成员声明访问级别。</p>
<h3 id="5-21-扩展方法"><a href="#5-21-扩展方法" class="headerlink" title="5.21 扩展方法"></a>5.21 扩展方法</h3><p>扩展方法允许编写的放和声明他的类之外的类关联。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Static <span class="keyword">class</span> <span class="title">extendmydata</span></span><br><span class="line"></span><br><span class="line">｛</span><br><span class="line"></span><br><span class="line"><span class="function">Public <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">xxx</span>(<span class="params"><span class="keyword">this</span> 类名 md</span>)｛｝</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">｝</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>声明的扩展方法必须声明为static。</li>
<li>扩张方法必须声明问static。</li>
<li>.第一个参数类型是this 且后面跟着它想扩展的类名称。</li>
</ul>
<h2 id="六-表达式和运算符"><a href="#六-表达式和运算符" class="headerlink" title="六 表达式和运算符"></a>六 表达式和运算符</h2><h3 id="6-1-简述"><a href="#6-1-简述" class="headerlink" title="6.1 简述"></a>6.1 简述</h3><ul>
<li>表达式求值是将每个运算符应用到它的操作数的过程。</li>
<li>运算符是符号，表示返回单个结果的操作。运算符会做：将操作数作为输入-执行某个操作-基于该操作返回一个值。比如说：a+b+c+d 就是3个运算符4个操作数。</li>
<li>操作数是指作为运算符输入的数据元素。</li>
</ul>
<p>*表达式和运算符的关系:表达式里包含了运算符。</p>
<p>运算符需要注意的点：</p>
<ul>
<li><p>特殊运算符：可空类型的特殊运算符，空接合运算符。</p>
</li>
<li><p>赋值运算符：对运算符右边的表达式求值，并设置为左边变量的值。赋值表达式是一个表达式，所以x=10也是一个值，所以x=z=y=10也是成立的。</p>
</li>
<li><p>条件运算符：和If 不一样，if是控制流语句，应当作为控制，控制两个行为执行其中一个。条件运算符返回的是一个表达式，他应该是返回两个值中的一个。</p>
</li>
<li><p>typeof运算符：不能重载。一元运算符使用示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type t =<span class="keyword">typeof</span>(someclass);</span><br><span class="line">T.getFields();</span><br><span class="line">T.Getmethod();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-2-字面量"><a href="#6-2-字面量" class="headerlink" title="6.2 字面量"></a>6.2 字面量</h3><p>字面量是明确，固定的值。字面量是写入源代码的，所以它的值必须在编译时可知。</p>
<ul>
<li>整数字面量：可以是 123，123L，123U（无符号整型）,123UL（无符号长整形）,或者是16进制。对于已知后缀，编译器会把数字字符串解释为能表示该值而不丢失数据的最小类型。</li>
<li>实数字面量：6.2698e-12 ，123.31F.注意无后缀的实数字面量是double类型。</li>
<li>字符字面量：类型是char，简单转移数序列是反斜杠加单个字符 \n这种。</li>
<li>常规字符串字面量：包含字符，简单转移序列，16进制和Unicode转移序列。</li>
<li>逐字字符串字面量：有一个@作为前缀，并且转义字符串不会被求值。都会被打印出来。有一个例外是双引号组会被解释为单个双引号字符。</li>
</ul>
<p><strong>*</strong>编译器会让相同的字符串字面量共享堆中同一内存位置以节约内存。</p>
<h3 id="6-3-求值顺序"><a href="#6-3-求值顺序" class="headerlink" title="6.3 求值顺序"></a>6.3 求值顺序</h3><p>赋值运算符和条件是最低的，其次是位或与，接着是相等，然后是移位，移位上面是加减乘除。初级运算符（语言中的. 方法调用，索引，自增，new）是最高的，其次是一元运算符（+-!~）。</p>
<p><strong>*</strong>注意：之前上学的时候有讲过++x和x++的区别，在c#中，x++是初级运算符，++x是一元运算符。所以说他们是两种不一样的操作。</p>
<h3 id="6-4-关系比较运算符和相等比较运算符"><a href="#6-4-关系比较运算符和相等比较运算符" class="headerlink" title="6.4 关系比较运算符和相等比较运算符"></a>6.4 关系比较运算符和相等比较运算符</h3><p>关系比较运算符和相等比较运算符就是&lt; =&gt;，比较操作数并返回bool类型值。</p>
<p>C#中数字不具备布尔意义。</p>
<p>这有一个疑问，实际上我在StackOverflow上有看过关于这个解释，因为false是0的表示，所以取反是true的同时，0取反也恰好是1，不知道c#是不是有这个意思。</p>
<h4 id="6-4-1-浅比较"><a href="#6-4-1-浅比较" class="headerlink" title="6.4.1 浅比较"></a>6.4.1 浅比较</h4><p>比较两个引用类型的相等性时，一般是比较它们的引用。如果引用相等，就意味着两个变量都指向内存中同一个对象，相等性比较为true。如果两个变量不指向同一个对象，哪怕是两个对象的数据完全一致也是false。</p>
<h4 id="6-4-2-深比较"><a href="#6-4-2-深比较" class="headerlink" title="6.4.2 深比较"></a>6.4.2 深比较</h4><p>string类型的对象也是引用类型，但是他的比较方式不同。比较时会比较内容（区分大小写）和长度。即使两个string占据不同的内存区域，但长度和内容相等，那相等性比较的也是true。</p>
<p><strong>*</strong>委托使用的也是深比较。不看内存位置，只看内容。</p>
<h3 id="6-5-条件逻辑运算符"><a href="#6-5-条件逻辑运算符" class="headerlink" title="6.5 条件逻辑运算符"></a>6.5 条件逻辑运算符</h3><p>短路操作：如果 expr1&amp;&amp;expr2 或 expr1&amp;&amp;expr2 中expr1的结果已经确定了就会跳过expr2的值。</p>
<p>因为短路操作的存在，所以不要在expr2中放置带副作用的表达式。</p>
<h3 id="6-6-逻辑运算符"><a href="#6-6-逻辑运算符" class="headerlink" title="6.6 逻辑运算符"></a>6.6 逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>仅当两个操作位都为1时结果位才是1。</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>位或</td>
<td>只要任意一个操作位为1结果位就是1。</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>仅当一个而不是两个操作数为1时结果位为1。</td>
</tr>
<tr>
<td>~</td>
<td>位非</td>
<td>一元操作符。操作数的每一个位都取反。该操作得到操作数的二进制反码。</td>
</tr>
</tbody>
</table>
<h3 id="6-7-移位运算符"><a href="#6-7-移位运算符" class="headerlink" title="6.7 移位运算符"></a>6.7 移位运算符</h3><h4 id="6-7-1-补码"><a href="#6-7-1-补码" class="headerlink" title="6.7.1 补码"></a>6.7.1 补码</h4><p>底层使用二进制补码的形式表示有符号二进制数。正数使用正常的二进制形式，如果取一个数的相反数需要把这个数按位取反再加一。二进制补码中所有的负数最左边的比特位置都是1。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">0</span> <span class="comment">//12</span></span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">1</span> <span class="comment">//按位取反</span></span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">0</span> <span class="comment">//+1 二进制补码 -12</span></span><br></pre></td></tr></table></figure>
<p>若直接将10111111转换成十进制，发现结果并不是-65，而是191。 事实上，在计算机内，如果是一个二进制数，其最左边的位是1，则我们可以判定它为负数，并且是用补码表示。 若要得到一个负二进制补码的数值，只要对补码全部取反并加1，就可得到其数值。所以说当要使用一个负数时，是有一层补码的转换的。</p>
<h4 id="6-7-2-移位运算完成乘法"><a href="#6-7-2-移位运算完成乘法" class="headerlink" title="6.7.2 移位运算完成乘法"></a>6.7.2 移位运算完成乘法</h4><p>通过位移可以迅速的完成乘法，比如把整数左移一位的结果和乘2的结果是相同的，右移一位的结果和除以2相同，移掉的位置补0。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span> <span class="comment">//14</span></span><br><span class="line"><span class="number">0</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span> <span class="comment">//14 &lt;&lt; 3 = 112</span></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span> <span class="comment">//14</span></span><br><span class="line"><span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span> <span class="comment">//14 &gt;&gt; 3 = 1</span></span><br></pre></td></tr></table></figure>
<p>但是在负数中右移会有问题，右移一位左边补0的话就变成了正数，所以，当操作数是有符号负数时，如果最左边的位是1，在左边移开的位位置用1填充，而不是0。正数还照常。</p>
<h3 id="6-8-类型转换"><a href="#6-8-类型转换" class="headerlink" title="6.8 类型转换"></a>6.8 类型转换</h3><p>隐式转换：如果有必要，编译器会自动执行转换。</p>
<p>显示转换：编译器只在使用显示转换运算符时才执行转换。</p>
<h4 id="6-8-1-用户定义转换"><a href="#6-8-1-用户定义转换" class="headerlink" title="6.8.1 用户定义转换"></a>6.8.1 用户定义转换</h4><p>声明隐式转换：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">pulic <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> TargetType（Sourcetype identifier）</span><br><span class="line">&#123; Return objectoftargettype；&#125;</span><br></pre></td></tr></table></figure>
<p>声明显示转换：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">pulic <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> TargetType（Sourcetype identifier）</span><br><span class="line">&#123;Return objectoftargettype；&#125;</span><br></pre></td></tr></table></figure>
<p>public和static是必须的。</p>
<h3 id="6-9-运算符重载"><a href="#6-9-运算符重载" class="headerlink" title="6.9 运算符重载"></a>6.9 运算符重载</h3><p>运算符重载只能用于类和结构。</p>
<p>一元重载运算符的重载方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span>-(LimitedInt x)</span><br></pre></td></tr></table></figure>
<p>二元重载运算符的重载方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span>+(LimitedInt x，<span class="keyword">double</span> y)</span><br></pre></td></tr></table></figure>
<p>可以重载的符号：</p>
<ul>
<li>一元运算符：+，-，!，~，++，–，true,false。</li>
<li>二元运算符：+，-，*，/，%，&amp;，|，^，&lt;&lt;，&gt;&gt;，==，!=，&gt;，&lt;，&gt;=，&lt;=</li>
</ul>
<p>重载的符号不可以做的事情：</p>
<ul>
<li>创建新运算符</li>
<li>改变运算符语法</li>
<li>重新定义运算符如何处理预定义类型</li>
<li>改变运算符的优先级或结合性</li>
</ul>
<h2 id="七-语句"><a href="#七-语句" class="headerlink" title="七 语句"></a>七 语句</h2><h3 id="7-1-什么是语句"><a href="#7-1-什么是语句" class="headerlink" title="7.1 什么是语句"></a>7.1 什么是语句</h3><p>简单语句由一个表达式和后面跟着的分号组成。</p>
<p>块是由一对大括号括起来的语句序列。括起来的语句可以包括：</p>
<ul>
<li>声明语句</li>
<li>嵌入语句</li>
<li>标签语句</li>
<li>嵌套块。</li>
</ul>
<h3 id="7-2-表达式语句"><a href="#7-2-表达式语句" class="headerlink" title="7.2 表达式语句"></a>7.2 表达式语句</h3><p>表达式有返回值，但实际上表达式也有副作用。副作用是一种影响程序状态的行为，许多表达式求值只是为了他们的副作用，比如说x=10这个赋值表达式（由一个运算符和两个操作数组成），实质上我们只是想给x赋值，但给x赋值只是副作用。表达式的主要目的返回x的新值由于没人接收反而被忽略了。</p>
<p>可以在表达式的后面防止语句终结符，分号；来从一个表达式创建一条语句。表达式返回的值会被丢弃。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">x=<span class="number">10</span>; <span class="comment">//表示计算这个表达式的全部原因就是为了完成这个副作用。</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-控制流语句"><a href="#7-3-控制流语句" class="headerlink" title="7.3 控制流语句"></a>7.3 控制流语句</h3><p>控制流结构：条件执行，循环语句，跳转语句。</p>
<p>条件执行和循环结构（除了foreach）都需要一个测试表达式或条件来决定怎么执行。</p>
<p>*注意foreach不能在循环时删减遍历元素。</p>
<h4 id="7-3-1-do语句"><a href="#7-3-1-do语句" class="headerlink" title="7.3.1 do语句"></a>7.3.1 do语句</h4><p>即使条件为false，do也会至少执行一次。</p>
<p>:grey_question: 如果在while里改变了了测试表达式的值怎么办</p>
<h4 id="7-3-2-for语句"><a href="#7-3-2-for语句" class="headerlink" title="7.3.2 for语句"></a>7.3.2 for语句</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(initiallizer;testexpr;iterationexpr)</span><br><span class="line">&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initiallizer只执行一次，在所有for结构其他部分之前。initiallizer中的变量只在改for语句的内部可见。</p>
<h4 id="7-3-3-swich语句"><a href="#7-3-3-swich语句" class="headerlink" title="7.3.3 swich语句"></a>7.3.3 swich语句</h4><ul>
<li>每个分支以一个或多个分支标签case开始。</li>
<li>每个分支末尾必须是break结束或者其他四种跳转语句。所以说，不是说一个case分支可以不写跳转语句而去读了下一个case的语句，而是，其实他们两个是一个分支语句，但是有两个分支标签。</li>
<li>分支标签会按顺序求值，如果case和swtich的测试表达式一致则执行该分支。然后跳到swtich语句底部。</li>
<li>如果写了default，那一定要写跳转语句。</li>
<li>case后面的分支标签是常量表达式，必须在编译的时候就完全获取到运算结果。</li>
<li>与c和c++不同，每个switch段，包括default必须以一个跳转语句结尾，也不可以执行一个switch段中的代码然后直接执行接下来的部分。c#不允许一个分支到另一个分支。</li>
</ul>
<h4 id="7-3-4-foreach语句"><a href="#7-3-4-foreach语句" class="headerlink" title="7.3.4 foreach语句"></a>7.3.4 foreach语句</h4><ul>
<li><p>foreach不能对遍历的列表进行删除操作。如果需要安全的遍历表并删除，可以使用倒序遍历列表并删除。</p>
</li>
<li><p>迭代变量是只读的。迭代变量只是保存了数据的引用，不是数据本身，因此不能更改引用。但是可以通过迭代遍历修改数据。</p>
</li>
<li><p>对于交错数组，需要为每一个维度都添加foreach语句，必须嵌套才能确保每一个数组都被处理。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">int</span>[] array <span class="keyword">in</span> arr1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Start"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">int</span> item <span class="keyword">in</span> array)</span><br><span class="line">    &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-3-4-跳转语句"><a href="#7-3-4-跳转语句" class="headerlink" title="7.3.4 跳转语句"></a>7.3.4 跳转语句</h4><p>break跳出最内层的封装语句。</p>
<p>continue转到最内层的封装语句的顶端</p>
<h5 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h5><p>标签语句主要用于goto语句。</p>
<ul>
<li>标签语句的形式：Identifier：statement</li>
<li>标签语句会执行statement，不会执行任何identifier有关的东西。</li>
<li>标签语句有自己的声明空间，所以和作用域内的其他标识符重复也没关系。</li>
<li>标签语句不能是关键字，或在范围内和其他标签标识符相同。</li>
</ul>
<p>作用域：声明所在的块，嵌套在该块内部的块。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">xyz：x=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h5 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h5><p>goto语句无条件转移控制到一个标签语句</p>
<p>goto也可以把控制转移到switch语句内部的标签中</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> <span class="keyword">case</span> constantexpression</span><br><span class="line"><span class="keyword">goto</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-using语句"><a href="#7-4-using语句" class="headerlink" title="7.4 using语句"></a>7.4 using语句</h3><p>using语句用于简化释放非托管对象资源，被适当的dispose。资源是指实现了system.idisposable接口的类或者结构。idisposable接口中含有一个名称为dispose的方法。</p>
<p><strong>*</strong>using指令不等同于using语句。</p>
<p>using语句帮助减少了意外的运行错误带来的潜在问题，常规的资源使用流程:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.分配资源</span></span><br><span class="line">ResType Resource = <span class="keyword">new</span> ResType(....);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用资源,如果这一段发生异常，Dispose将不被调用。</span></span><br><span class="line"><span class="comment">//使用Resource的语句</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//异常导致控制转移出方法之外，步骤3将不会被调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.处置资源</span></span><br><span class="line">Resource.Dispose;</span><br></pre></td></tr></table></figure>
<p>使用using语句的方式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆括号内的代码分配资源</span></span><br><span class="line"><span class="comment">//statement是使用资源的代码</span></span><br><span class="line"><span class="comment">//using语句隐式产生处置该资源的代码。</span></span><br><span class="line"><span class="keyword">using</span>(ResType res = Expression)Statement</span><br></pre></td></tr></table></figure>
<p>using语句的内部原理：</p>
<ol>
<li>分配资源</li>
<li>把statement放进try块</li>
<li>创建资源的dispose方法的调用，并放进finally块。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span>(ResType res = <span class="keyword">new</span> ResType(....) )Statement</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部是这样的：</span></span><br><span class="line">&#123;</span><br><span class="line">    ResType res = <span class="keyword">new</span> ResType(....);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Statement</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//由using语句隐式提供</span></span><br><span class="line">        Dispose of resource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多种using语句的使用实例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UsingStatement</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">using</span>(TextWriter tw = File.CreateText(<span class="string">"L.txt"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                tw.WriteLine(<span class="string">"YYY"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//也可以用于相同类型的多个资源</span></span><br><span class="line">            <span class="keyword">using</span>(TextWriter tw = File.CreateText(<span class="string">"L1.txt"</span>)</span><br><span class="line">                 			 tw2 = File.CreateText(<span class="string">"L2.txt"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                tw.WriteLine(<span class="string">"zzzzz"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//也可以嵌套</span></span><br><span class="line">            <span class="keyword">using</span>(TextWriter tw = File.CreateText(<span class="string">"L1.txt"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">using</span>(TextWriter tw = File.CreateText(<span class="string">"L3.txt"</span>))</span><br><span class="line">            	&#123;</span><br><span class="line">                tw.WriteLine(<span class="string">"XXXX"</span>);</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//另一种形式 using(资源)使用资源</span></span><br><span class="line">            <span class="comment">//这种形式也能确保调用dispose方法，</span></span><br><span class="line">            <span class="comment">//但不能防止using语句已经释放了他的非托管资源后使用该资源。</span></span><br><span class="line">            <span class="comment">//资源声明和之前的声明已经不同了，是在try的外面。</span></span><br><span class="line">            TextWriter tw = File.CreateText(<span class="string">"L4.txt"</span>);</span><br><span class="line">            <span class="keyword">using</span>(tw)</span><br><span class="line">                tw.WriteLine(<span class="string">"ccccc"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础2 结构体</title>
    <url>/2020/02/19/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%802%20%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<p>结构体相关内容 </p>
<a id="more"></a>
<h2 id="1-1-结构"><a href="#1-1-结构" class="headerlink" title="1.1 结构"></a>1.1 结构</h2><h3 id="1-1-1概述"><a href="#1-1-1概述" class="headerlink" title="1.1.1概述"></a>1.1.1概述</h3><p>对结构进行分配（注意书上说的是分配不是创建）比创建类的实例开销小，所以使用结构代替类有时可以提高性能，但要注意装箱和拆箱的代价。</p>
<p>预定义的简单类型（int short）等，尽管在.net和c#中是为原始类型，但实际上在.net中都实现为结构。</p>
<p>一些注意的点：</p>
<ul>
<li>结构可以有实力构造函数和静态构造函数，但不允许有析构函数。</li>
<li>结构的赋值是复制的。</li>
<li>结构可以被分布声明，也可以实现接口。</li>
<li>不允许在结构中初始化字段。</li>
<li>如果结构需要作为引用类型对象，则需要创建装箱的副本。因为他是值类型的。</li>
</ul>
<h3 id="1-1-2-结构和类的不同"><a href="#1-1-2-结构和类的不同" class="headerlink" title="1.1.2 结构和类的不同"></a>1.1.2 结构和类的不同</h3><ul>
<li>类是引用类型，结构是值类型。</li>
<li>结构是隐式密封的，这意味着它们不能被派生。</li>
<li>结构本身派生自system.valuetype，system.valuetype派生自object。</li>
<li>结构只能使用new和override修饰符，当创建一个和基类system.valuetype成员相同名称时使用。</li>
</ul>
<h3 id="1-1-3-结构体的构造方法"><a href="#1-1-3-结构体的构造方法" class="headerlink" title="1.1.3 结构体的构造方法"></a>1.1.3 结构体的构造方法</h3><p>c#隐式为结构提供无参构造函数，并会把每个成员设置为该类型的默认值，值类型是默认值，引用类型设置为null。预定义的无参构造方法不能被删除和重定义，但是可以创建其他有参的构造方法，和类是不同的，类只在没有其他构造函数时隐式提供。</p>
<p>调用构造方法需要使用new运算符，即使不从堆中分配内存也要使用new运算符。</p>
<p>如果不适用new运算符，则需要：</p>
<ul>
<li>在显示设置数据成员后，才能使用值。</li>
<li>对所有数据成员赋值后，才能调用任何函数成员。</li>
</ul>
<h5 id="静态构造方法"><a href="#静态构造方法" class="headerlink" title="静态构造方法"></a>静态构造方法</h5><p>静态构造函数可以初始化静态数据成员，但不能引用实例成员。和类的静态构造函数一样的规则。</p>
<p>调用静态构造函数的时机：</p>
<ul>
<li>调用显示声明的构造函数。</li>
<li>引用结构的静态成员。</li>
</ul>
<h5 id="结构的构造方法和析构方法的使用"><a href="#结构的构造方法和析构方法的使用" class="headerlink" title="结构的构造方法和析构方法的使用"></a>结构的构造方法和析构方法的使用</h5><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例构造方法(无参数)</td>
<td>不能再程序中声明，系统提供隐式的。不能被删除或重定义。</td>
</tr>
<tr>
<td>实例构造方法(有参数)</td>
<td>可以在程序中声明。</td>
</tr>
<tr>
<td>静态析构方法</td>
<td>可以在程序中声明。</td>
</tr>
<tr>
<td>析构方法</td>
<td>不能在程序中声明，不允许声明析构方法。</td>
</tr>
</tbody>
</table>
<h5 id="结构作为返回值和参数"><a href="#结构作为返回值和参数" class="headerlink" title="结构作为返回值和参数"></a>结构作为返回值和参数</h5><ul>
<li>返回值：创建结构的副本。</li>
<li>值参数：创建实参结构的副本。</li>
<li>ref和out：传入的是该结构的一个引用。</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础10 枚举类型</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%8010%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Ienumerator接口</p>
<a id="more"></a>
<h1 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h1><p>数组能使用foreach语句是因为，数组提供了一个叫做枚举器的对象。枚举器实现了Getenumerator方法，可以依次返回请求的数组中的元素，枚举器知道项的次序并跟踪他在序列中的位置。</p>
<p>获取一个枚举器的方法：调用对象的Getenumerator方法。</p>
<p>foreach要和可枚举类型一起使用，只要遍历对象是可枚举类型，它就会执行以下行为：</p>
<ul>
<li>调用Getenumerator获取对象枚举器。</li>
<li>从枚举器中请求每一项并且把它作为迭代变量，代码可以读取变量但不可以改变。</li>
</ul>
<h1 id="1-2-Ienumerator接口"><a href="#1-2-Ienumerator接口" class="headerlink" title="1.2 Ienumerator接口"></a>1.2 Ienumerator接口</h1><p>实现了ienumerator接口的枚举器包含了3个函数成员：<code>current()</code>, <code>movenext()</code> ,<code>reset()</code>。</p>
<ul>
<li>Current 返回序列中当前位置项的属性，它是只读属性，它返回object类型的引用，所以可以返回任何类型。</li>
<li>Movenext把枚举器位置前进到集合中下一项的方法，它也返回布尔值，指示新的位置是有效的位置还是超过了序列的尾部。</li>
<li>Reset是把位置重置为原始状态的方法。</li>
</ul>
<p>编写foreach循环时，编译器会生成与下面类似的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] array = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">31</span>&#125;;</span><br><span class="line">	IEnumerator ie = array.GetEnumerator();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>( ie.MoveNext())</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">int</span> i = (<span class="keyword">int</span>) ie.Current;</span><br><span class="line">		Console.WriteLine(<span class="string">"&#123;0&#125;"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-3-Ienumerable-接口"><a href="#1-3-Ienumerable-接口" class="headerlink" title="1.3  Ienumerable 接口"></a>1.3  Ienumerable 接口</h1><p>和上面说的ienumerator是不一样的接口。</p>
<p>可枚举类是指实现了ienumerable接口的类，只有一个成员：Getenumerator方法，它返回对象的枚举器（实现了ienumerator接口）。</p>
<p>一个例子：</p>
<p>1.先实现一个枚举器，实现ienumerator接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ColorEnumerator</span>:<span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">string</span>[] colors;</span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorEnumerator</span>(<span class="params"><span class="keyword">string</span>[] thecolors</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        colors = <span class="keyword">new</span> <span class="keyword">string</span>[thecolors.Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thoColors.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            colors[i] = thecolors[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (position == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (position &gt;= colors.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  colors[position];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (position &lt; colors.Length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            position ++ ;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.类实现Ienumerable 接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title">Spectrum</span>:<span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">string</span>[] Colors = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable <span class="title">GerEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator(Colors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Spectrum spectrum = <span class="keyword">new</span> Spectrum();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> color <span class="keyword">in</span> spectrum)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台输出：1，2，3</span></span><br></pre></td></tr></table></figure>
<h1 id="1-4-泛型枚举接口"><a href="#1-4-泛型枚举接口" class="headerlink" title="1.4 泛型枚举接口"></a>1.4 泛型枚举接口</h1><p>大多数情况下应该使用泛型版本的枚举接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Ienumerable&lt;T&gt;</span><br><span class="line">Ienumerator&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>泛型和非泛型枚举接口的差异：</p>
<p>对于非泛型接口的形式：</p>
<ul>
<li>IEnumerable接口的GetEnumerator方法返回实现Ienumerator枚举器的示例；</li>
<li>实现了IEnumerable的类实现了Current属性，它返回object的引用，然后我们必须把它转换为实际类型的对象。</li>
</ul>
<p>对于泛型接口形式：</p>
<ul>
<li>IEnumerable<T>接口的GetEnumerator方法返回实现IEnumator<T>的枚举器类的实例。</T></T></li>
<li>实现IEnumerator<T>的类实现了Current属性，他返回实际类型的对象，而不是object基类的引用。</T></li>
</ul>
<p>为什么推荐使用泛型枚举接口：</p>
<ul>
<li>非泛型接口的实现是不安全的，它们返回object类型的引用，然后必须转化为实际类型。</li>
<li>泛型接口的枚举器是类型安全的，它返回实际类型的引用，如果要创建自己的可枚举类，应该实现这些泛型接口。</li>
</ul>
<h1 id="1-5-迭代器"><a href="#1-5-迭代器" class="headerlink" title="1.5 迭代器"></a>1.5 迭代器</h1><p>可以把手动写的，替换为迭代器生成的可枚举类型和枚举器。</p>
<h2 id="1-5-1-迭代器块"><a href="#1-5-1-迭代器块" class="headerlink" title="1.5.1 迭代器块"></a>1.5.1 迭代器块</h2><p>迭代器块是有一个或多个yield语句的代码块。</p>
<p> 以下3种类型的代码块中的任意一种都可以是迭代器块：</p>
<ol>
<li>方法主体</li>
<li>访问器主体</li>
<li>运算符主体</li>
</ol>
<p>两个版本的迭代器块：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="keyword">string</span>&gt; <span class="title">BlackAndWhite</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"Black"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"gray"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"white"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="keyword">string</span>&gt; <span class="title">BlackAndWhite</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span>[] colors = &#123;<span class="string">"Black"</span>,<span class="string">"gray"</span>,<span class="string">"white"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colors.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> thoColors[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-2-yield关键字"><a href="#1-5-2-yield关键字" class="headerlink" title="1.5.2 yield关键字"></a>1.5.2 yield关键字</h2><blockquote>
<p>使用 <code>yield return</code> 语句可一次返回一个元素。</p>
<p>可通过使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/foreach-in">foreach</a> 语句或 LINQ 查询来使用从迭代器方法返回的序列。 <code>foreach</code> 循环的每次迭代都会调用迭代器方法。 迭代器方法运行到 <code>yield return</code> 语句时，会返回一个 <code>expression</code>，并保留当前在代码中的位置。 下次调用迭代器函数时，将从该位置重新开始执行。</p>
<p>可以使用 <code>yield break</code> 语句来终止迭代。</p>
</blockquote>
<h2 id="1-5-3-使用迭代器创建枚举器"><a href="#1-5-3-使用迭代器创建枚举器" class="headerlink" title="1.5.3 使用迭代器创建枚举器"></a>1.5.3 使用迭代器创建枚举器</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">GerEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> BlackAndWhite();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="keyword">string</span>&gt; <span class="title">BlackAndWhite</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"Black"</span>;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"gray"</span>;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"white"</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass myclass = <span class="keyword">new</span> Myclass();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> color <span class="keyword">in</span> myclass)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，比手动实现IEnumerator要方便一些。实际上编译器在<code>BlackAndWhite()</code>方法内部用一个嵌套类自动实现了枚举器,并且还生成了一个方法<code>BlackAndWhite()</code>。</p>
<h2 id="1-5-4使用迭代器创建可枚举类"><a href="#1-5-4使用迭代器创建可枚举类" class="headerlink" title="1.5.4使用迭代器创建可枚举类"></a>1.5.4使用迭代器创建可枚举类</h2><p> 这个例子中，<code>BlackAndWhite()</code>方法实现了一个可枚举类，在类中<code>GetEnumerator()</code>返回了这个枚举类。</p>
<p>此时编译器生成的类既是<code>IEnumerable</code>又是<code>IEnumerator</code>的，并且还生成了一个方法<code>BlackAndWhite()</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IEnumerable&lt;<span class="keyword">string</span>&gt; enumable = BlackAndWhite();</span><br><span class="line">        <span class="keyword">return</span> enumable.GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">BlackAndWhite</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"Black"</span>;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"gray"</span>;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"white"</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Myclass myclass = <span class="keyword">new</span> Myclass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用类对象迭代</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> color <span class="keyword">in</span> myclass)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(color);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用类的枚举器方法。</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">string</span> color <span class="keyword">in</span> myclass.BlackAndWhite())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-5-常见迭代器模式"><a href="#1-5-5-常见迭代器模式" class="headerlink" title="1.5.5 常见迭代器模式"></a>1.5.5 常见迭代器模式</h2><p>先说一下前两节的不同</p>
<p>1.5.3：<code>BlackAndWhite()</code>生成了一个<code>Enumerator</code>枚举器。</p>
<p>1.5.4：<code>BlackAndWhite()</code>生成了一个<code>Enumerable</code>枚举类，而枚举类中包含了<code>Enumerator</code>枚举器，类中还包含一个<code>GetEnumerator()</code>方法。</p>
<p>所以说1.5.4这种方法要更全面一些，实际上，这两节正是迭代器的常用法：</p>
<ol>
<li><p>枚举器的迭代器模式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">GerEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> IteratorMethod();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="keyword">string</span>&gt; <span class="title">IteratorMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> ....;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">string</span> color <span class="keyword">in</span> myclass)</span><br><span class="line">   &#123;</span><br><span class="line">      Console.WriteLine(color);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可枚举类型的迭代器模式</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">GerEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> IteratorMethod().GerEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">IteratorMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">    	<span class="keyword">yield</span> <span class="keyword">return</span> ....;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">string</span> color <span class="keyword">in</span> myclass)</span><br><span class="line">   &#123;</span><br><span class="line">      Console.WriteLine(color);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础11 LINQ</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%8011%20LINQ/</url>
    <content><![CDATA[<p>LINQ基础</p>
<a id="more"></a>
<h1 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h1><p>LINQ发音为Link 语言集成查询的缩写（language interated query）</p>
<p>LINQ是.net框架的扩展，它允许我们以使用SQL查询数据库的方式查询数据集合。</p>
<p>LINQ可以从数据库，程序对象的集合以及XML文档中查询数据。</p>
<h1 id="1-2-LINQ提供程序"><a href="#1-2-LINQ提供程序" class="headerlink" title="1.2 LINQ提供程序"></a>1.2 LINQ提供程序</h1><p>每一种数据源类型，在其背后一定有根据该数据源类型实现LINQ查询的代码模块。这些模块叫做LINQ提供程序（provider）。</p>
<p>关于LINQ提供程序：</p>
<ul>
<li>微软为常见的数据源类型提供了LINQ提供程序。</li>
<li>可以使用任何支持LINQ的语言来查询有LINQ提供程序的数据源类型。</li>
<li>第三方也会提供各种数据源类型的提供程序。</li>
</ul>
<h2 id="1-2-1-匿名类型"><a href="#1-2-1-匿名类型" class="headerlink" title="1.2.1 匿名类型"></a>1.2.1 匿名类型</h2><p>无名类类型的特性叫做匿名类型，常用于LINQ查询的结果之中。</p>
<p>匿名类型的变量使用和初始化对象一样的表达式（new关键字，类名。或构造方法以及对象初始化语句。），但没有类名和构造函数，且必须使用var声明的对象来赋值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span>&#123;name = <span class="string">"123"</span>,age = <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>匿名类型只能和局部变量配合使用，不能用于类成员。</li>
<li>匿名类型没有名字，必须使用var关键字作为变量类型。</li>
<li>不能设置匿名类型对象的属性，编译器为匿名对象创建的属性都是只读的。</li>
</ol>
<p>除了对象初始化语句的赋值形式，匿名类型的对象初始化语句还可以使用简单标识符和成员访问表达式，这两种形式叫做投影初始化语句。如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> something = <span class="string">""</span>;</span><br><span class="line"><span class="comment">//name 赋值形式，someclass.obj成员访问，something标识符</span></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span>&#123;name = <span class="string">"123"</span>,someclass.obj，something&#125;;</span><br><span class="line">Console.Write(stu.name,stu.obj,stu.somthing);</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span>&#123;name = <span class="string">"123"</span>, obj = someclass.obj，something = something&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="1-3-方法语法和查询语法"><a href="#1-3-方法语法和查询语法" class="headerlink" title="1.3 方法语法和查询语法"></a>1.3 方法语法和查询语法</h1><p>LINQ查询有两种形式的语法：查询语法和方法语法。在一个查询中可以组合这两种形式。</p>
<ul>
<li>方法语法： 标准方法调用，使用一组标准查询运算符。是命令式的，指明了查询方法的调用的顺序。方法语法使用了lambda表达式。</li>
<li>查询语法：类似于SQL，使用查询表达式形式书写。是声明式的，查询描述了你需要返回的数据。但没有指明如何执行这个查询。 </li>
</ul>
<p>官方推荐查询语法。但有些运算符必须使用方法语法书写。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询语法</span></span><br><span class="line">    <span class="keyword">var</span> numsQuery = <span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="keyword">where</span> n &lt; <span class="number">20</span>  <span class="keyword">select</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法语法</span></span><br><span class="line">    <span class="keyword">var</span> numsMethod = numbers.<span class="keyword">where</span>(x=&gt;x &lt; <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结合</span></span><br><span class="line">    <span class="keyword">int</span> numscount = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="keyword">where</span> n&lt;<span class="number">20</span> <span class="keyword">select</span> n).Count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-4-查询变量"><a href="#1-4-查询变量" class="headerlink" title="1.4  查询变量"></a>1.4  查询变量</h1><p>LINQ查询可以返回两种类型的结果：可以是一个可枚举的一组数据，满足查询参数的项列表。也可以是一个叫做标量的单一值。它满足查询条件的结果的某种摘要形式。比如说<code>Count()</code>返回的就是标量。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,&#125;;</span><br><span class="line">    </span><br><span class="line">    IEnumerable&lt;<span class="keyword">int</span>&gt; lownums = <span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="keyword">where</span> n &lt; <span class="number">20</span>  <span class="keyword">select</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numscount = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="keyword">where</span> n&lt;<span class="number">20</span> <span class="keyword">select</span> n).Count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行上面的代码后，lowNums查询变量不会包含查询结果。编译器会创建能够执行这个查询的代码。</p>
<p>查询变量numcount包含的是真实的整数值，但只能通过真实运行查询后获得。</p>
<p>上图两个查询变量有很大的区别，主要是查询执行的时间：</p>
<ul>
<li>如果查询表达式返回的是枚举（可枚举类型），查询会在处理枚举时才执行。</li>
<li>如果枚举被处理多次，查询就会执行多次。</li>
<li>如果在进行被查询的数据遍历后，查询执行之前数据有改动，则查询会使用新的数据。</li>
<li>如果查询表达式返回标量，查询立即执行，并会把结果保存在查询变量之中。</li>
</ul>
<p>个人理解：使用时查询是因为，一旦被查询的集合有任何改变，那之前查询到的结果就会出现问题，甚至是异常。</p>
<h1 id="1-5-查询表达式的结构"><a href="#1-5-查询表达式的结构" class="headerlink" title="1.5 查询表达式的结构"></a>1.5 查询表达式的结构</h1><p>方法语法的结构：</p>
<ul>
<li>子句必须按照一定顺序出现。</li>
<li>from子句和select group子句是必须的。</li>
<li>其他子句可选。</li>
<li>LINQ查询表达式中，select子句在表达式最后，c#中这么做的原因之一是让visual studio智能感应能在我们输入代码时给我们更多选项。</li>
<li>可以有任意多的from let where子句。</li>
</ul>
<p>*这些东西组合的结构叫查询体。</p>
<h2 id="from子句"><a href="#from子句" class="headerlink" title="from子句"></a>from子句</h2><p>from指定作为数据源使用的数据集合。</p>
<p>from语句和foreach不同点如下：</p>
<ul>
<li>foreach语句命令式的指定了要从第一个到最后一个按顺序地访问集合中的项，而from子句声明式地规定规定每个项都要被访问，但是没有规定顺序。</li>
<li>foreach语句遇到代码就执行主体，from语句什么也不执行，之创建可以查询的后台代码对象，只有程序访问查询变量语句时，才会执行查询。</li>
</ul>
<h2 id="join子句"><a href="#join子句" class="headerlink" title="join子句"></a>join子句</h2><p>使用联结来结合两个或多个集合中的数据。联结操作接受两个集合然后创建一个临时的对象集合，每个对象包含原始集合对象中的所有字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">join some in collection on field1 equal field2</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">			<span class="keyword">join</span> c <span class="keyword">in</span> studentsInCourses <span class="keyword">on</span> s.StID <span class="keyword">equals</span> c.StID</span><br></pre></td></tr></table></figure>
<h2 id="let子句"><a href="#let子句" class="headerlink" title="let子句"></a>let子句</h2><p>let子句接受一个表达式的运算符，并且把它赋值给一个需要在其他运算中使用的标识符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = Expression</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[]&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> a <span class="keyword">in</span> groupA <span class="keyword">from</span> b <span class="keyword">in</span> groupB</span><br><span class="line">                   <span class="keyword">let</span> sum = a + b</span><br><span class="line">                   <span class="keyword">where</span> sum == <span class="number">12</span></span><br><span class="line">                   <span class="keyword">select</span> <span class="keyword">new</span> &#123;a,b,sum&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> someInts)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Orderby语句"><a href="#Orderby语句" class="headerlink" title="Orderby语句"></a>Orderby语句</h2><p>orderby子句的默认排序是升序。 可以使用asending和descending关键字显示的设置元素的排序为升序或降序。</p>
<p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">			<span class="keyword">orderby</span> s.age</span><br><span class="line">    		<span class="keyword">select</span> student</span><br></pre></td></tr></table></figure>
<h2 id="Select-Group语句"><a href="#Select-Group语句" class="headerlink" title="Select Group语句"></a>Select Group语句</h2><p>group by子句可选，用来指定选择的项如何被分组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Exp <span class="keyword">group</span> collection <span class="keyword">by</span> filed</span><br></pre></td></tr></table></figure>
<h2 id="查询的匿名类型"><a href="#查询的匿名类型" class="headerlink" title="查询的匿名类型"></a>查询的匿名类型</h2><p>查询结果可以由原始集合的项，项和某些字段或匿名类型组成。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> &#123;filed = <span class="string">"1"</span>,filed2 = <span class="string">"2"</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123;filed = <span class="string">"1"</span>,filed2 = <span class="string">"2"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> groupA</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">new</span> &#123;s.filed&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> query <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a.filed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-6标准查询运算符"><a href="#1-6标准查询运算符" class="headerlink" title="1.6标准查询运算符"></a>1.6标准查询运算符</h1><p>标准查询运算符由一系列的API方法组成，能查询任何.net数组或集合。需要注意的点：</p>
<ul>
<li>被查询的集合对象叫序列，必须实现Ienumerable接口。</li>
<li>标准查询运算符使用方法语法。</li>
<li>一些运算符返回Ienumerable对象，而其他的一些运算符返回标量。返回标量的运算符立即执行，并返回一个值。</li>
<li>有很多操作都是一个谓词作为参数，谓词是一个方法，以对象作为参数根据对象是否满足某个条件而返回true和false。</li>
</ul>
<p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> total = numbers.Sum();</span><br><span class="line"><span class="keyword">int</span> howmayn = numbers.Count();</span><br></pre></td></tr></table></figure>
<h2 id="1-6-1-标准查询运算符的签名"><a href="#1-6-1-标准查询运算符的签名" class="headerlink" title="1.6.1 标准查询运算符的签名"></a>1.6.1 标准查询运算符的签名</h2><p>System.LINQ.enumerable类声明了标准查询运算符方法，他们也是扩展了Ienumerable<T> 泛型类的扩展方法。</T></p>
<p>直接调用扩展方法和将其作为扩展进行调用的不同如下面所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意下面的使用方法是完全等价的</span></span><br><span class="line"><span class="keyword">var</span> count = Enumerable.Count(array);</span><br><span class="line"><span class="keyword">var</span> count2 = array.Count;</span><br></pre></td></tr></table></figure>
<h1 id="1-7-查询表达式和标准运算符"><a href="#1-7-查询表达式和标准运算符" class="headerlink" title="1.7 查询表达式和标准运算符"></a>1.7 查询表达式和标准运算符</h1><p>标准查询运算符是进行查询的一组方法。</p>
<p>可以使用带有标准查询运算符的方法语法来编写查询表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> howmany = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers </span><br><span class="line">                    <span class="keyword">where</span> n &lt; <span class="number">7</span> </span><br><span class="line">                    <span class="keyword">select</span> n).Count();</span><br><span class="line">    Console.WriteLine(<span class="string">"Count:&#123;0&#125;"</span>,howMant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-1-将委托作为参数"><a href="#1-7-1-将委托作为参数" class="headerlink" title="1.7.1 将委托作为参数"></a>1.7.1 将委托作为参数</h2><p>泛型委托用于给运算符提供用户自定义的代码：</p>
<p>(count运算符被重载了，且有两种形式，第二种是带泛型委托的参数。）</p>
<p>第一种：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Count&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source);</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Count&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source,Func&lt;T,<span class="keyword">bool</span>&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>如果传入的方法语句只有一条，比较简单，或者并不会在程序的其他地方调用，可以传入lambda表达式。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础12 异步编程</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%8012%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>异步编程相关内容</p>
<a id="more"></a>
<h1 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h1><p>异步编程时.Net框架的一部分，并不是c#特有的。</p>
<p>启动程序时，系统会在内存中创建一个新的进程。进程是构成运行程序资源的集合，资源包括：虚地址空间，文件句柄，和其他程序运行需要的东西。</p>
<p>进程内部，系统创建了一个称为线程（执行线程的简称）的内核对象，它代表真正执行的程序。 一旦进程建立，系统会在Main方法的第一句语句处就开始线程的执行。</p>
<p>关于线程的几点：</p>
<ul>
<li>默认情况，一个进程只包括一个线程。从程序的开始一直到执行结束。</li>
<li>线程可以派生其他线程，一个进程可以包含不同状态的多个线程，来执行程序的不同部分。</li>
<li>一个进程拥有多个线程，线程间会共享进程的资源。</li>
<li>系统为处理器执行所规划的单元是线程，不是进程。</li>
</ul>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">SyncPractice</span></span><br><span class="line">    &#123;</span><br><span class="line">     	<span class="comment">//用于测试代码中不同任务的执行时间</span></span><br><span class="line">        Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> LargeNumber = <span class="number">600000</span>;</span><br><span class="line">            sw.Start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> t1 = CountCharacters(<span class="number">1</span>,<span class="string">"http://www.microsoft.com"</span>);</span><br><span class="line">            <span class="keyword">int</span> t2 = CountCharacters(<span class="number">2</span>, <span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line">            CountToALargeNumber(<span class="number">1</span>, LargeNumber);</span><br><span class="line">            CountToALargeNumber(<span class="number">2</span>, LargeNumber);</span><br><span class="line">            CountToALargeNumber(<span class="number">3</span>, LargeNumber);</span><br><span class="line">            CountToALargeNumber(<span class="number">4</span>, LargeNumber);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"chars in www.microsoft.com:&#123;0&#125;"</span>, t1);</span><br><span class="line">            Console.WriteLine(<span class="string">"chars in www.baidu.com:&#123;1&#125;"</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//下载网站的内容，返回网站包含的字符串数。     </span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">CountCharacters</span>(<span class="params"><span class="keyword">int</span> id , <span class="keyword">string</span> uriString</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">            Console.WriteLine(<span class="string">"Starting call&#123;0&#125;:&#123;1,4:NO&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> result = wc1.DownloadString(<span class="keyword">new</span> Uri(uriString));</span><br><span class="line">            Console.WriteLine(<span class="string">"call&#123;0&#125; compelted:&#123;1,4:NO&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     	<span class="comment">//只是一个消耗时间的方法，测试用</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i  = <span class="number">0</span>;  i &lt; <span class="keyword">value</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"End Counting &#123;0&#125; : &#123;1,4:NO&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">    SyncPractice sp = <span class="keyword">new</span> SyncPractice();</span><br><span class="line">    sp.DoRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting call 1:0.7881 ms</span><br><span class="line">call1 compelted:132.0713 ms</span><br><span class="line">Starting call 2:132.1764 ms</span><br><span class="line">call2 compelted:983.1649 ms</span><br><span class="line">End Counting 1 : 983.5177 ms</span><br><span class="line">End Counting 2 : 983.8779 ms</span><br><span class="line">End Counting 3 : 984.1251 ms</span><br><span class="line">End Counting 4 : 984.416 ms</span><br><span class="line">chars in www.bing.com:14462</span><br><span class="line">chars in www.baidu.com:111980</span><br></pre></td></tr></table></figure>
<p>实例的执行顺序是：1.执行两次下载网页内容的CountCharacters。2.执行四次CountToALargeNumber，可以看到，时间大部分都浪费在等待网站相应上了，如果先执行四次CountToALargeNumber方法，同时等待网络，时间会减少很多。所以引入了Async/await特性。</p>
<h1 id="1-2-Async-Await特性"><a href="#1-2-Async-Await特性" class="headerlink" title="1.2 Async/Await特性"></a>1.2 Async/Await特性</h1><p>Async/Await特性可以实现不需像上例中等待网络响应后再做其他操作。</p>
<h2 id="1-2-1-例子"><a href="#1-2-1-例子" class="headerlink" title="1.2.1 例子"></a>1.2.1 例子</h2><p>一个应用了Async/await特性的例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SyncPracticeUseSync</span></span><br><span class="line">&#123;</span><br><span class="line">        Stopwatch sw = <span class="keyword">new</span> Stopwatch();    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> LargeNumber = <span class="number">6</span>;</span><br><span class="line">        sw.Start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保存结果的对象</span></span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; t1 = CountCharacters(<span class="number">1</span>, <span class="string">"https://www.baidu.com/"</span>);</span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; t2 = CountCharacters(<span class="number">2</span>, <span class="string">"https://cn.bing.com"</span>);</span><br><span class="line"></span><br><span class="line">        CountToALargeNumber(<span class="number">1</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">2</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">3</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">4</span>, LargeNumber);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        Console.WriteLine(<span class="string">"chars in www.bing.com:&#123;0&#125;"</span>, t1.Result);</span><br><span class="line">        Console.WriteLine(<span class="string">"chars in www.baidu.com:&#123;0&#125;"</span>, t2.Result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//上下文关键字 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">CountCharacters</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> uriString</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">        Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"Starting call &#123;0&#125;:&#123;1&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds));</span><br><span class="line">			<span class="comment">//上下文关键字</span></span><br><span class="line">        <span class="keyword">string</span> result = <span class="keyword">await</span> wc1.DownloadStringTaskAsync(<span class="keyword">new</span> Uri(uriString));</span><br><span class="line">        Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"call&#123;0&#125; compelted:&#123;1&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">value</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"End Counting &#123;0&#125; : &#123;1&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Starting call 1:1.6199 ms</span><br><span class="line">Starting call 2:85.9381 ms</span><br><span class="line">End Counting 1 : 87.4253 ms</span><br><span class="line">End Counting 2 : 87.8023 ms</span><br><span class="line">End Counting 3 : 87.8327 ms</span><br><span class="line">End Counting 4 : 88.333 ms</span><br><span class="line">call1 compelted:381.3264 ms</span><br><span class="line">chars in www.bing.com:14462</span><br><span class="line">call2 compelted:924.1949 ms</span><br><span class="line">chars in www.baidu.com:111980</span><br></pre></td></tr></table></figure>
<p>比之前的结果快很多，现在CountToALargeNumber方法的4次调用是在等待网站响应时进行的，<strong>所有的工作都是在主线程中进行的，并没有创建额外的线程。</strong></p>
<h2 id="1-2-2-Async-Await的结构"><a href="#1-2-2-Async-Await的结构" class="headerlink" title="1.2.2 Async/Await的结构"></a>1.2.2 Async/Await的结构</h2><p>两种调用方法的时机：</p>
<ul>
<li>同步方法：一个程序调用某个方法，等待方法执行所有处理后才能继续执行。</li>
<li>异步方法：在方法处理完成之前就返回到调用位置。</li>
</ul>
<p>async/await可以创建并使用异步方法，它由三个部分组成：</p>
<ol>
<li><p>调用方法：该方法调用异步方法，然后异步方法（可能在相同的线程，亦可能在不同的线程）执行其任务时继续执行。如例子中的DoRun()。</p>
</li>
<li><p>异步方法：该方法异步执行其工作，然后立即返回到调用方法。如同例子中的CountCharacters();</p>
</li>
<li><p>await表达式：用于异步方法内部，指明需要异步执行的任务，异步方法可以包含任意多个await表达式，如果一个不包含的话编译器会发出警告。如同例子的：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> result = <span class="keyword">await</span> wc1.DownloadStringTaskAsync(<span class="keyword">new</span> Uri(uriString));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="1-3-异步方法"><a href="#1-3-异步方法" class="headerlink" title="1.3 异步方法"></a>1.3 异步方法</h1><p>异步方法的语法特点：</p>
<ol>
<li>方法头中包含async方法修饰符。</li>
<li>包含一个或多个await表达式，表示可以异步完成的任务。</li>
<li>必须具备以下三种返回类型：Void，Task，Task<T> 。后两种的返回对象表示将在未来完成的工作，调用方法和异步方法可以继续执行。</T></li>
<li>异步方法的参数可以为任意类型任意数量，但不能是out或ref参数。</li>
<li>按约定，异步方法名称应该以Async为后缀。</li>
<li>除方法以外，lambda表达式和匿名方法也可以作为异步对象。</li>
<li>await语句可以放入Try Catch结构内。</li>
</ol>
<p>async关键字只是包含一个或多个await表达式，它本身不能创建任何异步操作。同时，async关键字还是一个上下文关键字，除了作为方法的修饰符，async还可作为标识符。</p>
<h2 id="1-3-1-三种返回类型介绍"><a href="#1-3-1-三种返回类型介绍" class="headerlink" title="1.3.1 三种返回类型介绍"></a>1.3.1 三种返回类型介绍</h2><p>Task<T> ：</T></p>
<p>如果调用方法要从调用中获取一个T类型的值，异步方法的返回类型就必须是Task<T> ，调用方法将通过读取Task的Result属性获取这个T类型的值。</T></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Task&lt;<span class="keyword">int</span>&gt; t1 = CountCharacters(<span class="number">1</span>, <span class="string">"https://www.baidu.com/"</span>);</span><br></pre></td></tr></table></figure>
<p>Task :</p>
<p>如果调用方法不需要从异步方法中返回值，但需要检查异步方法的状态，就可以只返回一个Task类型的对象，如果异步方法种有return语句，也不会返回任何东西：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Task t1 = CountCharacters(<span class="number">1</span>, <span class="string">"https://www.baidu.com/"</span>);</span><br></pre></td></tr></table></figure>
<p>Void :</p>
<p>如果调用方法仅仅想执行异步方法，而不需要做任何交互，这种叫做调用并忘记，异步方法可以返回void类型，同时return语句也不会返回任何东西。</p>
<h2 id="1-3-2-异步方法的控制流"><a href="#1-3-2-异步方法的控制流" class="headerlink" title="1.3.2 异步方法的控制流"></a>1.3.2 异步方法的控制流</h2><p>异步方法的结构包括三个不同的区域：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">CountCharacters</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> uriString</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*1.await表达式之前的部分*/</span></span><br><span class="line">  	WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2.await表达式*/</span></span><br><span class="line">    <span class="keyword">string</span> result = <span class="keyword">await</span> wc1.DownloadStringTaskAsync(<span class="keyword">new</span> Uri(uriString));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*3.后续部分*/</span></span><br><span class="line">    <span class="keyword">return</span> result.Length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制流：</p>
<pre class="mermaid">graph TD;
    id1[调用异步方法]-->id2(同步地执行代码,是否遇到await表达式);
    id2--否-->id100[继续执行]
    id2--是-->id3[await表达式是否完成?]
    id3--是-->id2
    id3--否-->id4[1.创建空闲任务2.创建后续部分3.返回调用方法的控制流]
    id4-->id100
    id4-->id5[执行await的空闲任务]
    id5-->id6[执行后续部分]
    id6-->id7[设置返回的task状态和返回值]
    id7-->id9[退出]</pre>

<p>*注：这需要解释一下，异步方法的返回值返回的是一个任务，里面有需要的数值length。 当执行到await时，异步方法会继续执行调用方法，同时返回了一个task，此时任务可能未完成，但异步方法还是返回了一个task，同时可以通过task来判断await表达式是否执行完成。当await表达式结束后，return legnth才会真正执行，同时可以通过调用task对象的成员来使用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">CountCharacters</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> uriString</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">    <span class="keyword">string</span> result = <span class="keyword">await</span> wc1.DownloadStringTaskAsync(<span class="keyword">new</span> Uri(uriString));</span><br><span class="line">    <span class="keyword">return</span> result.Length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-3-Await表达式"><a href="#1-3-3-Await表达式" class="headerlink" title="1.3.3 Await表达式"></a>1.3.3 Await表达式</h2><p><strong>Await</strong>：由关键字和一个空闲对象（任务）组成，表达式指定了一个异步执行的任务。</p>
<p><strong>空闲对象</strong>：就是一个awaitable类型的实例，awaitable类型指包含GetAwaiter方法的类型，该方法没有参数，返回一个awaiter类型的对象。</p>
<p><strong>Awaiter</strong>：包含以下成员(实际上，不需要构建自己的awaitable。)</p>
<ul>
<li>bool IsCompleted{get;}</li>
<li>void OnCompleted(Action);</li>
<li>Void GetResult();或T GetResult();</li>
</ul>
<h2 id="1-3-4-自定义异步任务"><a href="#1-3-4-自定义异步任务" class="headerlink" title="1.3.4 自定义异步任务"></a>1.3.4 自定义异步任务</h2><p>作为await表达式的任务，最简单的方法是在自己的方法中使用Task.run方法。</p>
<p>Task. run会在不同的线程上运行你的方法，签名：以Func<treturn>委托作为参数，返回值类型为T return。有三种创建方法：</treturn></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">UserAwaitFunc</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="comment">//第一种</span></span><br><span class="line">           Func&lt;<span class="keyword">int</span>&gt; ten = <span class="keyword">new</span> Func&lt;<span class="keyword">int</span>&gt;(GetNum);</span><br><span class="line">           <span class="keyword">int</span> a = <span class="keyword">await</span> Task.Run(ten);</span><br><span class="line">           <span class="comment">//第二种</span></span><br><span class="line">           <span class="keyword">int</span> b = <span class="keyword">await</span> Task.Run(<span class="keyword">new</span> Func&lt;<span class="keyword">int</span>&gt;(GetNum));</span><br><span class="line">           <span class="comment">//第三种</span></span><br><span class="line">           <span class="keyword">int</span> c = <span class="keyword">await</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Task.Run()有很多重载，包括以Func和Action为参数等等。如果方法的参数不匹配，则可以使用lambda表达式包装此不兼容的方法。</p>
<h2 id="1-3-5-取消一个异步操作"><a href="#1-3-5-取消一个异步操作" class="headerlink" title="1.3.5 取消一个异步操作"></a>1.3.5 取消一个异步操作</h2><p>一些.net异步方法允许请求终止执行，自定义的异步方法中也可以加入这个特性。</p>
<p>System.threading.task命名空间有两个为此设计：cancellationtoken和cancellationtokensource。</p>
<ul>
<li>cancellationtoken对象包含任务是否应被取消的信息，拥有cancellationtoken对象的任务需要定期检查其令牌（token）的状态，如果cancellationtoken对象的iscancellationrequested的属性为true，任务需停止操作并返回。cancellationtoken不可逆，一旦取消被设置为true，就不能被更改。</li>
<li>cancellationtokensource对象创建可分配给不同任务的cancellationtoken对象，任何持有cancellationtokensource的对象都可以调用其cancel方法，这样会将iscancellationrequested属性设置为true。</li>
</ul>
<p>简略的说：调用cancellationtokensource的cancel时，本身并不会执行取消操作。只是将cancellationtoken的iscancellationrequested属性设置为true，包含cancellationtoken的代码负责检查该属性来判断任务是否停止执行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CancelSync</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">RunAsync</span>(<span class="params"> CancellationToken ct</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ct.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; CycleMethod(ct), ct);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CycleMethod</span>(<span class="params">CancellationToken ct</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Starting CycleMethod"</span>);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ct.IsCancellationRequested)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        CancellationToken token = cts.Token;</span><br><span class="line"></span><br><span class="line">        CancelSync mc = <span class="keyword">new</span> CancelSync();</span><br><span class="line">        Task t = mc.RunAsync(token);</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">        cts.Cancel();</span><br><span class="line">        t.Wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-6-调用方法中同步的等待任务"><a href="#1-3-6-调用方法中同步的等待任务" class="headerlink" title="1.3.6 调用方法中同步的等待任务"></a>1.3.6 调用方法中同步的等待任务</h2><p>有的时候需要等待某个Task对象完成，Task的Wait方法可以实现该功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        CancelSync mc = new CancelSync();</span><br><span class="line">        Task t = mc.RunAsync();</span><br><span class="line">        t.Wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait方法可用于单一task或一组task对象，对于一组task对象，可以等待所有任务都结束，也可以等待某一个任务结束。 实现这两个功能的是task类中的两个静态方法：</p>
<ul>
<li>Waitall(params Task[] tasks);</li>
<li>Waitany(params Task[] tasks);</li>
</ul>
<p>这两个方法都没有返回值，调用时会停止，直到条件满足后再继续执行。</p>
<h2 id="1-3-7-在异步方法中异步地等待任务"><a href="#1-3-7-在异步方法中异步地等待任务" class="headerlink" title="1.3.7 在异步方法中异步地等待任务"></a>1.3.7 在异步方法中异步地等待任务</h2><p>在异步方法中，有时会希望用await表达式等待task，这时异步方法会返回到调用方法。Task.whenall task.whenany方法实现，这两个方法称为组合子(combinator）</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> LargeNumber = <span class="number">6</span>;</span><br><span class="line">        sw.Start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保存结果的对象</span></span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; t1 = CountCharacters(<span class="number">1</span>, <span class="string">"https://www.baidu.com/"</span>);</span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; t2 = CountCharacters(<span class="number">2</span>, <span class="string">"https://cn.bing.com"</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Task&gt; tasks = <span class="keyword">new</span> List&lt;Task&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">    	tasks.Add(t1);</span><br><span class="line">    	tasks.Add(t2);</span><br><span class="line">    	<span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line">    	Console.WriteLine(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时会等待两次CountCharacters执行完毕，然后输出Done。</p>
<p>将WhenAll换成如下，此时会等待其中一个CountCharacters执行完毕，然后输出Done。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.WhenAny(tasks);</span><br></pre></td></tr></table></figure>
<h2 id="1-3-8-Task-Delay方法"><a href="#1-3-8-Task-Delay方法" class="headerlink" title="1.3.8 Task.Delay方法"></a>1.3.8 Task.Delay方法</h2><p>Task.Delay 方法创建一个task对象，该对象将暂停其在线程中的处理，和thread.sleep阻塞线程不同的是，task.delay不会阻塞线程，线程可以继续处理其他工作。</p>
<h1 id="1-4-BackgroundWork类"><a href="#1-4-BackgroundWork类" class="headerlink" title="1.4 BackgroundWork类"></a>1.4 BackgroundWork类</h1><p>Async/await 特性适合处理需要在后台完成的，不相关的小任务。但有时候，可能需要新建一个线程，在后台持续允许已完成某项工作，并不时与主线程进行通信。background类就是为此创建的。</p>
<pre class="mermaid">classDiagram
Class01 <|-- object class01 : runworkerasync() cancelasync() reportprogress() workerreportsprogress workersupportscancellation isbusy cancellationpending event:doworkevent event:progresschanged event:runworkercampleted< pre>

<p><code>WorkerReportsProgress</code>和<code>WorkerSupportsCancellation</code>用于设置后台任务是否可以把它的进度汇报给主线程，以及是否支持从主线程取消。可以用<code>isbusy</code>属性检查后台任务是否在运行。</p>
<p>后台线程开始时触发<code>DoWork</code>，后台任务汇报状态的时候触发<code>ProgressChanged</code>事件，线程退出的时候 触发<code>RunWorkerCompeted</code>事件。</p>
<p><code>RunWorkerAsync()</code>用于获取后台线程并执行DoWork事件处理程序，<code>CancelAsync()</code>会把<code>CancellationPending</code>设置为True，<code>DoWork</code>事件处理需要检查这个属性决定是否应该停止处理，<code>ReportProgress()</code>用于Dowork向主线程汇报进度。</p>
<p>要使用Back类，需要写一些事件处理程序，<code>DoWork</code>事件的处理程序是必须的。剩下两个可选。</p>
<p>注：这块东西也比较多，但是对于我来说不常用，等用到再回来补充。</p>
<h1 id="1-5-并行循环"><a href="#1-5-并行循环" class="headerlink" title="1.5 并行循环"></a>1.5 并行循环</h1><p>任务并行库（task parellel library）是BCL中的一个类库，简化了并行编程。简单的介绍以下这个类库：<code>Parallel.for</code>，<code>Parallel.foreach</code>循环，用于不与其他动作依赖的迭代行为。一定要注意的是，此方式不能保证迭代的执行次序，只能保证结果的正确。</p>
<h2 id="1-5-1-Parallel-for"><a href="#1-5-1-Parallel-for" class="headerlink" title="1.5.1 Parallel.for"></a>1.5.1 Parallel.for</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ParallelLoopResult.For(<span class="keyword">int</span> fromInclusive,<span class="keyword">int</span> toExclusive,Action body)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Parallel.<span class="keyword">for</span>(<span class="number">0</span>,<span class="number">15</span>,i=&gt;Console.WriteLine(<span class="string">"wwww"</span> + i));</span><br></pre></td></tr></table></figure>
<h2 id="1-5-2-Parallel-foreach"><a href="#1-5-2-Parallel-foreach" class="headerlink" title="1.5.2 Parallel.foreach"></a>1.5.2 Parallel.foreach</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ParallelLoopResult <span class="title">ForEach</span>(<span class="params">IEnumerable&lt;TSource&gt; source,Action&lt;TSource&gt; body</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Parallel.ForEach(array,i=&gt;Console.WriteLine(<span class="string">"wwww"</span> + i));</span><br></pre></td></tr></table></figure>
<h1 id="1-6-其他异步编程模式"><a href="#1-6-其他异步编程模式" class="headerlink" title="1.6 其他异步编程模式"></a>1.6 其他异步编程模式</h1><p>了解一下旧的异步方法的模式：</p>
<p>当委托对象在调用列表中只有一个方法，就可以异步执行这个方法（下面叫引用方法）。委托类有两个方法，叫做<code>BeginInvoke</code>和<code>Endinvoke</code>，当调用<code>Begininvoke</code>方法时，它开始在独立线程上执行引用方法，并且立即返回到原始线程。原始线程可以继续，引用方法会在线程池的线程中并行执行。</p>
<p>当程序希望获取已完成的异步方法的结果时，可以检查<code>Begininvoke</code>返回的<code>Iasyncresult</code>的<code>Iscompleted</code>属性，或调用委托的<code>Endinvoke</code>方法等待委托完成。</p>
<p>下面介绍一下原始线程如何知道发起的线程是否完成的几个办法。</p>
<h2 id="1-6-1-等待一直到结束模式"><a href="#1-6-1-等待一直到结束模式" class="headerlink" title="1.6.1 等待一直到结束模式"></a>1.6.1 等待一直到结束模式</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyDel del = <span class="keyword">new</span> MyDel(Sum);</span><br><span class="line">IAsyncReult iar = del.BeginInvoke(<span class="number">3</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//等待开启的线程结束</span></span><br><span class="line"><span class="keyword">long</span> result = del.EndInvoke(iar);</span><br></pre></td></tr></table></figure>
<h2 id="1-6-2-轮询模式"><a href="#1-6-2-轮询模式" class="headerlink" title="1.6.2 轮询模式"></a>1.6.2 轮询模式</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyDel del = <span class="keyword">new</span> MyDel(Sum);</span><br><span class="line">IAsyncReult iar = del.BeginInvoke(<span class="number">3</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!iar.IsCompleted)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用EndInvoke来获取接口并进行清理</span></span><br><span class="line"><span class="keyword">long</span> result = del.EndInvoke(iar);</span><br></pre></td></tr></table></figure>
<h2 id="1-6-3-回调模式"><a href="#1-6-3-回调模式" class="headerlink" title="1.6.3 回调模式"></a>1.6.3 回调模式</h2><p>等待一直结束模式和轮询模式中，初始线程继续自己的流程，然后去观察开启的线程是否完成，然后拿到结果并继续。回调模式不同，一旦开启，就是自己管自己，不用考虑同步，异步方法结束后，系统调用一个用户自定义的方法处理结果，并且调用委托的endinvoke方法，这个用户自定义的方法叫做回调方法或回调。</p>
<p><code>Begininvoke</code>方法需要传入两个参数：</p>
<ul>
<li>第一个，回调方法的名字。签名必须与<code>void AsyncCallback(IAsyncReult iar)</code>一致。</li>
<li>第二个，state，可以传null，或者传入回调方法的一个对象的引用。</li>
</ul>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IAsyncReult iar1 = del.BeginInvoke(<span class="number">3</span>,<span class="number">5</span>,<span class="keyword">new</span> AsyncCallback(CallBack),<span class="literal">null</span>);</span><br><span class="line">IAsyncReult iar2 = del.BeginInvoke(<span class="number">3</span>,<span class="number">5</span>,CallBack,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>回调方法内调要调用<code>Endinvoke</code>处理异步方法执行后的输出值。要调用<code>Endinvoke</code>方法，需要有委托对象的引用，但他在初始线程中，不在开启的线程中。如果不使用<code>BeginInvoke</code>的state参数作为其他用途，可以使用它发送委托的引用给回调方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IAsyncReult iar = del.BeginInvoke(<span class="number">3</span>,<span class="number">5</span>,CallBack,del);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallBack</span>(<span class="params">IAsyncReult iar</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AsyncReult ar = (AsyncReult)iar;</span><br><span class="line">	Mydel del = (Mydel)ar.AsyncDelegate;</span><br><span class="line">	<span class="keyword">long</span> Sum = del.EndInvoke(iar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-3-计时器"><a href="#1-6-3-计时器" class="headerlink" title="1.6.3 计时器"></a>1.6.3 计时器</h2><p>计时器每次时间到期后调用回调方法。回调方法必须是<code>TimerCallback</code>形式的:<code>void TimerCallback(object state)</code> </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Timeer mytimer = <span class="keyword">new</span> Timer(MyCallback,someobject,<span class="number">2000</span>,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<p>参数含义：</p>
<ol>
<li>回调的名字。</li>
<li>传给回调的对象，可以是null或者每次回调方法执行时要传入的对象引用。</li>
<li>多少秒后第一次调用。</li>
<li>每多少秒执行一次。</li>
</ol>
</|--></pre>]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础13 命名空间 程序集</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%8013%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%20%E7%A8%8B%E5%BA%8F%E9%9B%86/</url>
    <content><![CDATA[<p>命名空间 程序集 相关内容</p>
<a id="more"></a>
<h1 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h1><p>编译器接受源代码文件并生成名称为程序集的输出文件。有些项目中，可能会使用来自其他程序集的类或类型，这些程序集可能是BCL，也可能是来自第三方提供，他们被称为类库，通常它们的名称以<code>dll</code>拓展结尾，而不是exe。</p>
<pre class="mermaid">graph LR
id0[源代码 Lib.cs]-->id1[C#编译器]
id1-->id2[Lib.dll程序集]
id2-->id3[C#编译器]
id3-->id4[Myclass程序集]
id5[源代码 Myclass.cs]-->id3[C#编译器]</pre>

<p>Console类定义在mscorlib程序集中，mscorlib中含有c#类型以及大部分的.net语言的基本类型的定义，在编译c#程序时，它总会被引用，所以也不会出现在referneces目录中。</p>
<p>如果两个库中都有相同名称的类，就会出现问题。比如使用了Lib1.dll和Lib2.dll，它们都有一个叫做BClass的类，此时产生了命名冲突。</p>
<h1 id="1-2-命名空间"><a href="#1-2-命名空间" class="headerlink" title="1.2 命名空间"></a>1.2 命名空间</h1><p>命名空间的定义：</p>
<ul>
<li>命名空间名可以被视为一个字符串，它加在类名或者类型名签名并通过点进行隔离。</li>
<li>包括命名空间，分割点，以及类名的完整字符串叫类的完全限定名。</li>
<li>命名空间是共享命名空间名的一组类和类型。</li>
<li>命名空间内的类型被称为命名空间的成员。</li>
</ul>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---命名空间名--/ //---类名--//	</span></span><br><span class="line">ABCCorp.Ultralib.SquareWidget</span><br></pre></td></tr></table></figure>
<p>引用类库中的类时，使用<code>.</code>就可以避免类库的类名称重复，using命令可以解决每次用类库都要打全称的麻烦。</p>
<p>我的理解是命名空间通过点使命名更规范。其实两个点的含义是不一样的，第一个是字符串中方法标记的点，第二个是在点出命名空间中的类。</p>
<h2 id="1-2-1-命名空间跨文件伸展"><a href="#1-2-1-命名空间跨文件伸展" class="headerlink" title="1.2.1 命名空间跨文件伸展"></a>1.2.1 命名空间跨文件伸展</h2><p>命名空间不是封闭的，可以在不同的文件中再次声明它。</p>
<h2 id="1-2-2-嵌套命名空间"><a href="#1-2-2-嵌套命名空间" class="headerlink" title="1.2.2 嵌套命名空间"></a>1.2.2 嵌套命名空间</h2><p>再怎么套，命名空间也是互相独立的，不会有父子关系。</p>
<h1 id="1-3-using指令"><a href="#1-3-using指令" class="headerlink" title="1.3 using指令"></a>1.3 using指令</h1><p>完全限定名可能会很长，使用using命名空间指令和using别名指令避免这个问题。指令必须放在源文件的顶端，在任何类型声明之前。using命名空间指令应用于当前源文件中的所有命名空间。</p>
<h2 id="1-3-1using命名空间指令"><a href="#1-3-1using命名空间指令" class="headerlink" title="1.3.1using命名空间指令"></a>1.3.1using命名空间指令</h2><p>using命名空间指令通知编译器你将要使用来自某个指定命名空间的类型。当编译器遇到不在当前命名空间的名称时，它会检查using命名空间指令中给出的命名空间列表，并把未知名称加到列表中的第一个命名空间后面。如果完全限定名称匹配了这个程序集或引用程序集的一个类，编译器将使用那个类，如果不匹配，就实验列表中下一个命名空间。</p>
<h2 id="1-3-2-using别名指令"><a href="#1-3-2-using别名指令" class="headerlink" title="1.3.2 using别名指令"></a>1.3.2 using别名指令</h2><p>别名指令允许起一个别名给命名空间或命名空间内的一个类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> su = System；</span><br><span class="line"><span class="keyword">using</span> swu = System.Console；</span><br></pre></td></tr></table></figure>
<h1 id="1-4-程序集"><a href="#1-4-程序集" class="headerlink" title="1.4 程序集"></a>1.4 程序集</h1><p>程序集不包含本地机器代码，是中间公共语言代码，同时也包含编译器JIT在运行时转换CIL到本机代码所需的一切，文件拓展名通常为exe或者dll。</p>
<p>程序集有4个主要部分：</p>
<ul>
<li>清单：<ul>
<li>程序集名称标识符</li>
<li>组成程序集的文件列表</li>
<li>指示程序集中内容在哪里的地图</li>
<li>关于引用其他程序集的信息</li>
</ul>
</li>
<li>类型元数据：包含该程序集中所定义的所有类型的信息。</li>
<li>CIL代码：程序集中所有的中间代码</li>
<li>资源：可选，包括图形或语言资源</li>
</ul>
<p>程序集的代码文件称为模块，有些程序集有多个模块(文件)，一个文件是主模块，其他的是次要模块。</p>
<ul>
<li>主模块含有程序集的清单和到次要模块的引用。</li>
<li>次要模块文件以.netmodule结尾。</li>
<li>多文件程序集被视为一个单一单元。</li>
</ul>
<h2 id="1-4-1-程序集标识符"><a href="#1-4-1-程序集标识符" class="headerlink" title="1.4.1 程序集标识符"></a>1.4.1 程序集标识符</h2><p>.Net中，程序集的文件名不像N在其他操作系统和环境中那么重要。更重要的是程序集标识符。组成部分：1.简单名，2.版本号，3.文化信息，4.公钥，用于创建安全的数字签名。</p>
<h2 id="1-4-2-强弱命名程序集"><a href="#1-4-2-强弱命名程序集" class="headerlink" title="1.4.2 强弱命名程序集"></a>1.4.2 强弱命名程序集</h2><p>强命名程序集有一个唯一的数字签名，比没有强命名的程序更安全：</p>
<ul>
<li>强名称唯一标识了程序集，没有一个和其有相同名称的程序集，可以保证该程序集来自于其声称的来源。</li>
<li>没有CLR安全组件捕获更改，程序集内容不能被改变。</li>
</ul>
<p>弱命名程序集是没有被强命名的程序集。没有数字签名，天生不安全。</p>
<p>程序员不产生强名称，编译器产生。需要拿到如版本号，公钥私钥对等信息，然后进行散列化。 创建强命名程序集除了vs自带的，也可以使用strongname工具。</p>
<h2 id="1-4-3-程序集的私有方式部署"><a href="#1-4-3-程序集的私有方式部署" class="headerlink" title="1.4.3 程序集的私有方式部署"></a>1.4.3 程序集的私有方式部署</h2><p>私有程序集就是可以复制粘贴的程序集，不依赖其他程序集。这种复制粘贴的部署方式叫复制文件部署。私有程序集可以被放入任何目录中，只需要它的文件都在同一目录或子目录下。</p>
<ul>
<li>私有程序集所在的目录被称为应用程序目录。</li>
<li>私有程序集可以使强命名的，也可以是弱命名的。</li>
<li>不需要在注册表注册文件。</li>
<li>卸载只需要删除。</li>
</ul>
<h2 id="1-4-3-共享程序集和GAC"><a href="#1-4-3-共享程序集和GAC" class="headerlink" title="1.4.3 共享程序集和GAC"></a>1.4.3 共享程序集和GAC</h2><p>.NET有一个贮藏库，称为全局程序缓存(GAC)，用于把一个程序集被系统中的其他程序集共享，当今GAC的程序集称为共享程序集。重要内容如下：</p>
<ul>
<li>只有强命名程序能被添加到GAC。</li>
<li>GAC早期只接受dll扩展名文件，现在也可以添加exe扩展名的程序集。</li>
<li>GAC的目录一般在\Windows\Assembly中。</li>
</ul>
<p>试图安装到GAC时，CLR安全组件会检查数字签名是否有效。安装后，被一个程序引用时，不再需要进一步的检查。</p>
<p>如果程序集的版本有更改，会产生不同的公钥，这样再GAC中会存在不同的程序集，并可以完美共存，这被称为并兼执行。</p>
<h2 id="1-4-4-配置文件"><a href="#1-4-4-配置文件" class="headerlink" title="1.4.4 配置文件"></a>1.4.4 配置文件</h2><p>配置文件含有关于应用程序的信息，供CLR运行时使用。如指示CLR使用不同版本的DLL。配置文件由XML组成。</p>
<p>配置文件的作用时，比如现在GAC中的程序集更新了，程序还再使用老版本的DLL，如果想用新的，就得重新编译，为了避免重新编译，同时使用新的DLL，这时就需要使用配置文件告诉CLR要使用的DLL版本。配置文件以.config结尾。</p>
<h2 id="1-4-5-延迟签名"><a href="#1-4-5-延迟签名" class="headerlink" title="1.4.5 延迟签名"></a>1.4.5 延迟签名</h2><p>最终的程序集强命名一般都是在开发的末期，有特殊权限的小组执行。由于公钥是程序集标识符的4个部分之一，所以直到有了公钥才能被设置，如果要测试时需要部署到GAC，就需要一种方式：延迟签名，修改了赋值强命名的形式。或者叫分签名。</p>
<p>使用延迟签名可以把程序集部署到GAC中，但必须使用命令行取消该机器的GAC签名确认，只针对这个程序集，并允许它被装在GAC中。</p>
<h2 id="1-4-6-总结"><a href="#1-4-6-总结" class="headerlink" title="1.4.6 总结"></a>1.4.6 总结</h2><p>强命名程序集，和延迟签名程序集，弱程序集都拥有清单，元数据，CIL。区别是，前两者强命名还有拥有公钥私钥的数字签名，延迟签名拥有数字签名占位。弱程序集则没有。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础14 异常</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%8014%20%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p> 异常相关内容</p>
<a id="more"></a>
<h1 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h1><p>系统捕获错误，并抛出一个异常，如果程序没有提供处理该异常的代码，系统会挂起这个程序。</p>
<h1 id="1-2-Try语句"><a href="#1-2-Try语句" class="headerlink" title="1.2 Try语句"></a>1.2 Try语句</h1><p>try语句由三个部分组成：</p>
<ul>
<li>try块：避免出现异常被保护的语句。</li>
<li>catch语句：处理try块抛出的异常。</li>
<li>finally块：无论是否有异常都会执行的代码。</li>
</ul>
<p>catch子句可以有多个。注意finally和catch的顺序，异常一旦被捕获，就不会挂起或者有报错信息。</p>
<h1 id="1-3-异常类"><a href="#1-3-异常类" class="headerlink" title="1.3 异常类"></a>1.3 异常类</h1><p>BCL中定义了许多表示异常类型的异常类，所有异常类都派生自<code>System.exception</code>类。</p>
<h1 id="1-4-catch语句"><a href="#1-4-catch语句" class="headerlink" title="1.4 catch语句"></a>1.4 catch语句</h1><p>catch语句处理异常，有三种不同级别的处理：</p>
<ul>
<li>catch { Statements } ：捕捉任何出现的异常。</li>
<li>catch(ExceptionType) { Statements }：捕捉匹配任何该名称类型的异常。</li>
<li>catch(ExceptionType someobj) { Statements }：捕捉匹配任何该名称类型的异常，并接受一个异常变量，用于访问该对象的信息。</li>
</ul>
<p>带对象的特点catch子句提供异常的最多信息，匹配该类或派生自它的类的异常。还会给出一个异常实例，一个对CLR创建的异常对象的引用。可以在catch内访问异常变量。</p>
<p>catch字句段可以包含多个catch子句，异常发生时，系统按顺序搜索子句列表，第一个匹配该异常对象类型的子句会被执行。因此，catch子句排序有两个重要的原则：</p>
<ul>
<li>最明确的异常类型第一，直至最普通的类型。</li>
<li>如果有一个一般的catch语句，必须是最后一个。</li>
</ul>
<h1 id="1-5-Finally语句"><a href="#1-5-Finally语句" class="headerlink" title="1.5 Finally语句"></a>1.5 Finally语句</h1><p>finally始终会执行。无论是否有异常抛出。可选，可以不写。</p>
<h1 id="1-6-为异常寻找处理程序"><a href="#1-6-为异常寻找处理程序" class="headerlink" title="1.6 为异常寻找处理程序"></a>1.6 为异常寻找处理程序</h1><p>如果异常在一个没有try语句保护的块中产生，系统会按顺序搜索调用栈，进一步寻找匹配的处理代码。</p>
<h1 id="1-7-抛出异常"><a href="#1-7-抛出异常" class="headerlink" title="1.7 抛出异常"></a>1.7 抛出异常</h1><p>throw可以显示抛出一个异常：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ArgumentNullException myEx = <span class="keyword">new</span> ArgumentNullExcpetion(<span class="string">"arg"</span>);</span><br><span class="line">    <span class="keyword">throw</span> myEx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ArgumentNullException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Message:"</span>,e.Message);</span><br><span class="line">    <span class="comment">//还可以将异常在catch中抛出，让其他异常处理程序处理。</span></span><br><span class="line">    <span class="comment">//重新抛出异常，没有附加参数。</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础15 预处理指令</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%8015%20%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p> 预处理指令相关内容</p>
<a id="more"></a>
<h1 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h1><p>预处理指令指示编译器如何处理源代码。在C和C++中，有实际的预处理阶段，此时预处理程序遍历源代码并为之后的编译阶段准备文本和输出流，在C#中没有实际的预处理程序，而预处理指令由编译器处理。</p>
<p>基本规则:</p>
<ul>
<li>与代码在不同的个行。</li>
<li>不需要以分号结尾。</li>
<li>每一行必须以#字符开始，#前和指令之间可以有空格。</li>
</ul>
<h1 id="1-2-define和-undef指令"><a href="#1-2-define和-undef指令" class="headerlink" title="1.2 #define和#undef指令"></a>1.2 #define和#undef指令</h1><p>define指令用于声明一个编译符号，#undef指令取消定义一个编译符号。编译符号是只有两种可能状态的标识符，要么被定义，要么未被定义。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> valuev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> valuea</span></span><br><span class="line"><span class="comment">//允许重复定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> valuev</span></span><br></pre></td></tr></table></figure>
<h1 id="1-3-条件编译"><a href="#1-3-条件编译" class="headerlink" title="1.3 条件编译"></a>1.3 条件编译</h1><p>条件编译允许根据某个编译符号是否被定义来决定一段代码被编译或跳过，有四个指令：</p>
<ul>
<li>#if</li>
<li>#else</li>
<li>#elif</li>
<li>#endif</li>
</ul>
<h1 id="1-4-备注"><a href="#1-4-备注" class="headerlink" title="1.4 备注"></a>1.4 备注</h1><p>这没什么好讲的，就是一些工具语法，有需要再补充，有一个疑惑是，define指令定义的变量的值是什么赋值的。</p>
<p>之前在unity的platform变量中可以判断是哪个平台在运行，这个值是从哪得到的。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础16 预处理指令</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%8016%20%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p> 反射相关内容</p>
<a id="more"></a>
<h1 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h1><h1 id="1-2-元数据和反射"><a href="#1-2-元数据和反射" class="headerlink" title="1.2 元数据和反射"></a>1.2 元数据和反射</h1><p>有关程序及其类型的数据被称为元数据<code>metadata</code>，特性可以给类型添加元数据。元数据保存在程序的程序集中。</p>
<p>程序运行时，可以查看其他程序集或其本身的元数据。一个运行的程序查看本身的元数据或其他程序的元数据的行为叫做反射。对象浏览器是显示元数据的程序的一个例子。</p>
<h1 id="1-3-Type类"><a href="#1-3-Type类" class="headerlink" title="1.3 Type类"></a>1.3 Type类</h1><p>BCL中有一个叫做Type的抽象类，被设计用来包含类型的特性，使用这个类的对象可以获取程序使用的类型的信息。</p>
<p>Type是抽象类，因此不能有实例，在运行时，CLR创建从Type派生的类实例，Type包含了类型信息。访问这些实例时，CLR不会返回派生类的引用而是type基类的引用。</p>
<p>注意事项：</p>
<ul>
<li>程序中用到的每一个类型，CLR都会创建一个包含这个类型信息的Type类型的对象。</li>
<li>程序中用到的每一个类型都会关联到独立的Type类对象。</li>
<li>不管创建的类型有多少个实例，只有一个Type对象会关联到所有这些实例。</li>
</ul>
<h2 id="1-3-1-获取Type对象"><a href="#1-3-1-获取Type对象" class="headerlink" title="1.3.1 获取Type对象"></a>1.3.1 获取Type对象</h2><p>Object类型包含一个<code>GetType()</code>方法，返回实例的Type对象引用,所以可以在任何类型对象上使用<code>GetType()</code>方法。还有一个Getfields方法。</p>
<p>或者使用typeof运算符获取type对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(DerivedClass)</span><br></pre></td></tr></table></figure>
<h1 id="1-4-特性"><a href="#1-4-特性" class="headerlink" title="1.4 特性"></a>1.4 特性</h1><p>特性(attribute)允许向程序的程序集增加元数据的语言结构，应用了特性的程序结构叫目标。</p>
<ul>
<li>用来获取和使用元数据的程序叫做特性的消费者，例如对象浏览器。</li>
<li>.Net预定了很多特性，用户也可以自定义特性。</li>
</ul>
<p>在源代码中，我们将特性应用于程序结构，编译器获取源代码并且从特性产生元数据，然后把元数据放到程序集中。消费者程序可以把获取特性的元数据以及程序中其他组件的元数据。</p>
<p>编译器同时生成和消费特性。</p>
<h2 id="1-4-1-应用特性"><a href="#1-4-1-应用特性" class="headerlink" title="1.4.1 应用特性"></a>1.4.1 应用特性</h2><p>特性的目的：告知编译器将程序结构的某组元数据嵌入程序集。使用方法具体看例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyAttribute(<span class="meta-string">"Simple class"</span>,<span class="meta-string">"Version 3.57"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-2-自定义特性"><a href="#1-4-2-自定义特性" class="headerlink" title="1.4.2 自定义特性"></a>1.4.2 自定义特性</h2><p>特性值是某个特殊类型的类。所有特性类都派生自System.Attribute。</p>
<h3 id="声明自定义特性"><a href="#声明自定义特性" class="headerlink" title="声明自定义特性"></a>声明自定义特性</h3><p>声明一个自定义特性，需要做如下工作：</p>
<ul>
<li>声明一个派生自System.Attribute的类。</li>
<li>给类起一个Attribute结尾的名字。</li>
</ul>
<p>由于特性持有目标的信息，所有特性类的公共成员只能是：字段，属性，构造函数。</p>
<h3 id="使用特性的构造函数"><a href="#使用特性的构造函数" class="headerlink" title="使用特性的构造函数"></a>使用特性的构造函数</h3><p>和其他类一样，编译器会生成一个隐式公共无参的构造函数。构造函数也可以被重载。构造函数必须以Attribute后缀结尾。</p>
<h3 id="指定构造函数"><a href="#指定构造函数" class="headerlink" title="指定构造函数"></a>指定构造函数</h3><p>为目标应用特性时，其实是在指定该使用哪个构造函数来创建特性的实例。在应用特性时，构造函数的实参必须是在编译器能确定的常量表达式。</p>
<p>如果构造方法没有参数，可以省略圆括号：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyAttr</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">someclass</span></span><br></pre></td></tr></table></figure>
<h3 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h3><p>只有特想的消费者访问特性时才能调用构造函数，应用一个特性是一条声明语句，不会决定什么时候构造特性类的对象。和普通类的构造函数的，普通类的构造时命令式的，特性时声明式的。区别如下：</p>
<ul>
<li>命令语句：在这里创建一个新的对象。</li>
<li>声明语句：这份特性和这个目标关联，如果需要构造特性，使用这个构造函数。</li>
</ul>
<p>特性的构造函数同样可以使用位置参数和命名参数。</p>
<h3 id="限制特性的使用"><a href="#限制特性的使用" class="headerlink" title="限制特性的使用"></a>限制特性的使用</h3><p>AttributeUsage特性可以应用到自定义的特性上，用于限制自定义特性只能被特定的结构使用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTarget.Method| AttributeTarget.Constructor) </span>]</span><br><span class="line">public sealed class MyAttributeAttribute:System.Attribute</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>限制特性的多个实例不能应用到同一个目标上：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTarget.Class,Inherited = false, AllwoMultiple = false) </span>]</span><br><span class="line">public sealed class MyAttributeAttribute:System.Attribute</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>限制有很多种，用的时候再去查。</p>
<h3 id="自定义特性的实践"><a href="#自定义特性的实践" class="headerlink" title="自定义特性的实践"></a>自定义特性的实践</h3><p>可以参考如下规则:</p>
<ul>
<li>特性应该表示目标结构的一些状态。</li>
<li>如果特性需要某些字段，可以通过包含具有位置参数的构造函数来收集数据，可选字段可以采用命名参数按需初始化。</li>
<li>除了属性之外，不要实现公共方法或其他函数成员。</li>
<li>为了更安全，把特性声明为sealed。</li>
<li>特性中使用AttributeUsage显式指定特性可应用的目标。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTarget.Class,Inherited = false, AllwoMultiple = false) </span>]</span><br><span class="line">public sealed class MyAttributeAttribute:System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> Des&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAttributeAttribute</span>(<span class="params"><span class="keyword">string</span> des</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">	 Des = des</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问特性"><a href="#访问特性" class="headerlink" title="访问特性"></a>访问特性</h3><p>通过Type的两个方法<code>Isdefined()</code>和<code>Getcustomattributesisdefined()</code>用来检测某个特性是否应用到了某个类上。</p>
<p><strong>Isdefined</strong>:</p>
<ul>
<li>第一个参数接受需要检查的特性Type对象。</li>
<li>第二个参数是bool，指示是否搜索Myclss继承树查找这个特性。</li>
</ul>
<p><strong>Getcustomattributesisdefined</strong>：返回应用到结构的特性的数组。返回的时是object数组，必须将它强制转换为相应的特性类型。调用方法后，每个与目标相关联的特性的实例就会被创建。</p>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTarget.Class,Inherited = false, AllwoMultiple = false) </span>]</span><br><span class="line">public sealed class MyAttributeAttribute:System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> Des&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAttributeAttribute</span>(<span class="params"><span class="keyword">string</span> des</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">	 Des = des</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyAttribute(<span class="meta-string">"hello"</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Myclass</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Type t = <span class="keyword">typeof</span>(Myclass);</span><br><span class="line">        <span class="keyword">object</span>[] Attr = t.Getcustomattributesisdefined(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">foreach</span>(Attribute a <span class="keyword">in</span> Attr)</span><br><span class="line">        &#123;</span><br><span class="line">            MyAttributeAttribute attr = a <span class="keyword">as</span> MyAttributeAttribute;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != attr)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(attr.Des);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp基础9 转换</title>
    <url>/2019/12/17/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%809%20%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>显示转换和强制转换</p>
<a id="more"></a>
<h2 id="1-1-概览"><a href="#1-1-概览" class="headerlink" title="1.1 概览"></a>1.1 概览</h2><p>转换的定义： 接受一个类型的值并使用它作为另一个类型的等价值过程。</p>
<p>转换后的值应该和源值一样的。但其类型为目标类型。</p>
<h2 id="1-2-隐式转换"><a href="#1-2-隐式转换" class="headerlink" title="1.2 隐式转换"></a>1.2 隐式转换</h2><p>  语言会自动做的转换叫自动转换，比如8位转16位 从位数少的转为高数，多出来的位用0或1补充， 补0的过程叫零扩展。</p>
<p>对于有符号的类型转换，额外的高位用源表达式的符号位进行填充。这种叫符号拓展：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正数</span></span><br><span class="line">				<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|   <span class="comment">//sbyte:10</span></span><br><span class="line"><span class="comment">//复制到高位的符号位</span></span><br><span class="line"><span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|   <span class="comment">//short:10</span></span><br><span class="line">                    </span><br><span class="line"><span class="comment">//负数</span></span><br><span class="line">				<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|   <span class="comment">//sbyte:-10        </span></span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">1</span>|<span class="number">0</span>|   <span class="comment">//short:-10</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-显示转换和强制转换"><a href="#1-3-显示转换和强制转换" class="headerlink" title="1.3 显示转换和强制转换"></a>1.3 显示转换和强制转换</h2><p>当无符号16位ushort的值是相对小一点的数字(0.4%) 时，才能在不损失数据的情况下转换为无符号8位byte类型。</p>
<p>数据中其他结果会溢出，会产生其他值：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>  <span class="comment">//1365</span></span><br><span class="line">				<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>|<span class="number">0</span>|<span class="number">1</span>	 <span class="comment">//85</span></span><br></pre></td></tr></table></figure>
<p>如果原类型的任意值会被转换成目标类型值时会出现丢失值的情况，语言不会自动提供转换。必须使用显示转换，这叫做强制转换表达式。</p>
<h2 id="1-4-转换的类型"><a href="#1-4-转换的类型" class="headerlink" title="1.4 转换的类型"></a>1.4 转换的类型</h2><pre class="mermaid">graph TB;
    id1(转换)-->id2(用户自定义的)
    id1(转换)-->id3(预定义的)
    id3-->id4[数字]
    id3-->id5[装箱/拆箱]
    id3-->id6[引用]
    id4-->id7[隐式]
    id4-->id8[显式]
    id6-->id10[隐式]
    id6-->id11[显式]
    id2-->id12[隐式]
    id2-->id13[显式]</pre>

<p>可以为自定义类型定义隐式转换和显示转换。</p>
<p>还有一个预定义的转换类型，叫装箱。可以将任何值类型转换为：</p>
<ul>
<li>object类型</li>
<li>System,valuetype类型。</li>
</ul>
<p>拆箱可以将一个装箱的值转换为原始类型。</p>
<h2 id="1-5-数字的转换"><a href="#1-5-数字的转换" class="headerlink" title="1.5 数字的转换"></a>1.5 数字的转换</h2><p>图太麻烦了，总之位数大的转小的是显式转换，小的转大的是隐式转换，就像两个大小不一样的水杯倒水一样。</p>
<p>另外，同类型的无符号要比有符号位数少。</p>
<h2 id="1-6-溢出检测上下文"><a href="#1-6-溢出检测上下文" class="headerlink" title="1.6 溢出检测上下文"></a>1.6 溢出检测上下文</h2><p> checked和unchecked运算符，用于检查转换是否溢出。</p>
<p>如果指定一个表达式或一段代码为checked，CLR会在转换产生溢出时派出一个overflowexception异常。</p>
<p>如果代码不是checked，转换会继续而不管是否产生溢出。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> sb;</span><br><span class="line">    <span class="keyword">ushort</span> sh = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unchecked</span></span><br><span class="line">    &#123;</span><br><span class="line">        sb = (<span class="keyword">byte</span>)sh;</span><br><span class="line">        Console.WriteLine(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">checked</span></span><br><span class="line">        &#123;</span><br><span class="line">            sb = (<span class="keyword">byte</span>)sh;</span><br><span class="line">            Console.WriteLine(sh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> sb;</span><br><span class="line">    sb = <span class="keyword">unchecked</span>((<span class="keyword">byte</span>)sh);</span><br><span class="line">    Console.WriteLine(sb);</span><br><span class="line"></span><br><span class="line">    sb = <span class="keyword">checked</span>((<span class="keyword">byte</span>)sh);</span><br><span class="line">    Console.WriteLine(sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*checked和unchecked运算符checked和unchecked语句是两回事。</p>
<h2 id="1-7-引用转换"><a href="#1-7-引用转换" class="headerlink" title="1.7 引用转换"></a>1.7 引用转换</h2><ul>
<li>引用保存的信息是它指向的数据类型。</li>
<li>引用转换接受源引用，并返回一个指向堆中同一位置的引用，但是把引用标记为其他类型。</li>
</ul>
<h3 id="1-7-1-隐式引用转换"><a href="#1-7-1-隐式引用转换" class="headerlink" title="1.7.1 隐式引用转换"></a>1.7.1 隐式引用转换</h3><ol>
<li>所有引用类型都可以被隐式转换为object类型。</li>
<li>任何类型可以隐式转换到它继承的接口。</li>
<li>类可以隐式转换到：他继承链中的任何类，它实现的任何接口。</li>
</ol>
<p>委托可以隐式转换成.Net BCL类和接口：</p>
<ul>
<li>System.Delegate</li>
<li>System.MulticastDelegate</li>
<li>System.ICloneable</li>
<li>System.Runtime.Serilization.Iserialiable</li>
</ul>
<p>ArrayS数组，其中元素是Ts类型，可以转换成：</p>
<ul>
<li>System.ICloneable，System.IList，System.ICollection，System.IEnumerable</li>
<li>System.Array</li>
<li>另一个数组ArrayT，其中元素是Tt类型，如果Tt类型满足以下所有条件：1.两个数组有一样的维度。2.元素类型Ts和Tt都是引用类型，不是值类型。3.Ts和Tt存在隐式转换。</li>
</ul>
<h3 id="1-7-2-显示引用转换"><a href="#1-7-2-显示引用转换" class="headerlink" title="1.7.2 显示引用转换"></a>1.7.2 显示引用转换</h3><p>显示引用转换是从一个普通类型到一个更精确类型的引用转换：</p>
<ul>
<li>从object到任何引用类型的转换</li>
<li>从基类到从它继承的类的转换。</li>
</ul>
<p>编译器允许无限制的类型转换，如果没能成功转换，会抛出异常，但并不会导致编译错误。</p>
<p>有效显示引用转换有三种情况：</p>
<ol>
<li><p>没必要的显示转换。也就是说语言进行了隐式转换</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>&#123;&#125;</span><br><span class="line">B var1 = <span class="keyword">new</span> B();</span><br><span class="line">A var2 = (A)var1 <span class="comment">//不必转换，因为A是B的基类。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>源引用是null：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>&#123;&#125;</span><br><span class="line">A var1 = <span class="literal">null</span>;</span><br><span class="line">B var2 = (B)var1 <span class="comment">//允许转换，因为var1是空</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由源引用指向的实际数据可以被安全的进行隐式转换。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span>&#123;&#125;</span><br><span class="line">B var1 = <span class="keyword">new</span> B();</span><br><span class="line">A var2 = var1;</span><br><span class="line">B var3 = (B)var2;  <span class="comment">//允许转换，因为数据是B类型的。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="1-8-装箱转换"><a href="#1-8-装箱转换" class="headerlink" title="1.8 装箱转换"></a>1.8 装箱转换</h2><p>包括值类型在内的所有c#类型都派生自object类型。</p>
<h3 id="1-8-1-装箱"><a href="#1-8-1-装箱" class="headerlink" title="1.8.1 装箱"></a>1.8.1 装箱</h3><p> 如果值类型想使用对象组件，就可以使用装箱。</p>
<ul>
<li>装箱是一种隐式转换，接受值类型的值，根据这个值在堆上创建一个完整的引用类型对象并返回对象引用。</li>
<li>装箱是创建副本。装箱返回的是值的引用类型副本，装箱后该值有两份副本，原始值类型和引用类型副本。每一份独立操作。</li>
</ul>
<p>*引用类型转换成object不叫装箱，因为它只是引用指向的堆数据改变了，并非把值类型数据装到堆上。</p>
<p>装箱的过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i = 12;</span><br><span class="line">object o = null;</span><br><span class="line">o = i;</span><br></pre></td></tr></table></figure>
<p>在第三步时，系统做了如下操作：</p>
<ol>
<li>由于i时值类型对象，当i赋值给o时，必须在堆上分配一个对象的引用。所以在堆上创建了int类型的对象。</li>
<li>将i的值复制到int对象。</li>
<li>返回int对象的引用，让oi作为引用保存，此时oi指向的是，堆上的int对象的object部分。</li>
</ol>
<p>任何值类型ValueTypeS都可以被隐式转换为object类型，System.ValueType或InferfaceT(如果ValueTypeS实现了InferfaceT)。</p>
<h3 id="1-8-2-拆箱"><a href="#1-8-2-拆箱" class="headerlink" title="1.8.2 拆箱"></a>1.8.2 拆箱</h3><p>拆箱是把装箱后的对象，显示转换为值类型的过程。</p>
<p>系统把值类型拆箱为ValueTypeT时，检测到要拆箱的对象实际是ValueTypeT的装箱值，然后把对象的值复制到变量。</p>
<h2 id="1-9-用户自定义转换"><a href="#1-9-用户自定义转换" class="headerlink" title="1.9 用户自定义转换"></a>1.9 用户自定义转换</h2><p>可以为类或结构定义隐式和显示转换。</p>
<p>除了implicit和explicit关键字以外，隐式和显示转换的声明语法是一样的。</p>
<p>需要有public和static修饰符：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">TargetType</span>(<span class="params">SourceType type</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SomeObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Person P</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户自定义转换的约束：</p>
<ul>
<li>只可以为类和结构自定义。</li>
<li>不能重定义标准隐式转换或显示转换。</li>
<li>对于源类型S和目标类型T，以下命题是真：<ul>
<li>S和T必须是不同类型。</li>
<li>S和T不能通过继承关联。</li>
<li>S和T都不能是接口或object类型。</li>
<li>转换运算符必须是S或T的成员。</li>
</ul>
</li>
<li>对于相同的源和目标类型，不能声明隐式转换和显示转换。</li>
</ul>
<p>例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="keyword">string</span> name,<span class="keyword">int</span> age</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Person P</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> p.Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Person</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"None"</span>,i);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Person bill = <span class="keyword">new</span> Person(<span class="string">"bill"</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="keyword">int</span> age = bill;</span><br><span class="line">        Person p = <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示转换只是关键字换成了explicit，并且使用时需要使用强制转换表达式。</p>
<p>之前讲的是单步用户自定义转换。但用户自定义转换在完整转换中最多可以有3个步骤：</p>
<ol>
<li>预备标准转换</li>
<li>用户自定义转换</li>
<li>后续标准转换</li>
</ol>
<p>在这个链中不可能有一个以上的用户自定义转换。</p>
<p>继上面的例子，展示多步的转换：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Em</span>:<span class="title">Person</span>&#123;&#125;</span><br><span class="line">Em em = <span class="keyword">new</span> Em(); em.Name = <span class="string">"a"</span>; em.Age = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">float</span> fVar = em;  </span><br><span class="line"><span class="comment">//步骤：1.em通过标准转换为Person，2.Person通过自定义转换为int，3.int通过标准转换为float。</span></span><br></pre></td></tr></table></figure>
<h2 id="1-10-is-as运算符"><a href="#1-10-is-as运算符" class="headerlink" title="1.10 is as运算符"></a>1.10 is as运算符</h2><h3 id="1-10-1-is运算符"><a href="#1-10-1-is运算符" class="headerlink" title="1.10.1 is运算符"></a>1.10.1 is运算符</h3><p>is运算符可以避免盲目的转换。只能用于引用转换以及装箱拆箱转换，不能用于用户自定义转换。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Expr <span class="keyword">is</span> TatgetType <span class="comment">//返回bool</span></span><br></pre></td></tr></table></figure>
<p>如果Expr通过以下方式成功转换为TatgetType，返回true：</p>
<ul>
<li>引用转换</li>
<li>装箱转换</li>
<li>拆箱转换</li>
</ul>
<h3 id="1-10-2-as运算符"><a href="#1-10-2-as运算符" class="headerlink" title="1.10.2 as运算符"></a>1.10.2 as运算符</h3><p>as运算符和强制转换运算符类似 但它不抛出异常。如果转换失败返回null。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Expr <span class="keyword">as</span> TatgetType <span class="comment">//返回引用</span></span><br></pre></td></tr></table></figure>
<p>由于as运算符返回引用表达式，所以可以作为赋值操作中的源。</p>
<p>as和is类似，只能用于引用转换和装箱转换，不能用于用户自定义类型或到值类型的转换。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity插件：AStarPathfinding寻路系统（中）</title>
    <url>/2019/12/11/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<p>本为为AStarPathfinding寻路系统介绍中篇，主要讲解演示。</p>
<a id="more"></a>
<h1 id="基础寻路网格生成"><a href="#基础寻路网格生成" class="headerlink" title="基础寻路网格生成"></a>基础寻路网格生成</h1><h2 id="1-1-Grid-Graph"><a href="#1-1-Grid-Graph" class="headerlink" title="1.1 Grid Graph"></a>1.1 Grid Graph</h2><p><strong>（1）</strong>准备工作：场景中添加Plane，障碍物。为Plane添加一个Layer（我的命名是Ground）。为所有的障碍物添加一个Layer（Obs），注意障碍物要添加Box Collider组件。新建一个空物体，并添加<strong>Astar Path</strong>组件。</p>
<p><strong>（2）</strong>准备完成后，在Astar Path中添加<strong>Grid Graph</strong>，并设置网格图的长宽以足够覆盖整个Plane。根据障碍物的可攀爬高度设置<strong>Max Cilb</strong>。将Collison Testing中的<strong>Obstacle Layer</strong> Mask设置为障碍物所在的图层（Obs）。将<strong>Height Tesing</strong>中的Mask设置为Plane所在的图层（Ground）。<br><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/97475890.jpg" alt="img"></p>
<p>设置完成后点击Scan，效果如图：</p>
<p><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/16226371.jpg" alt="img"></p>
<p><strong>（3）</strong> 为人物添加寻路功能：首先添加<strong>Seeker</strong>组件，然后添加AIPah（或者RichAI，适用于NavMesh）最后添加让物体执行寻路的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c#</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using Pathfinding;</span><br><span class="line">public class AstarAI : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">public Transform target;</span><br><span class="line">public void Start()</span><br><span class="line">&#123;</span><br><span class="line">//Get a reference to the Seeker component we added earlier</span><br><span class="line">Seeker seeker = GetComponent&lt;Seeker&gt;();</span><br><span class="line">//Start a new path to the targetPosition, return the result to the OnPathComplete function</span><br><span class="line">seeker.StartPath(transform.position, target.position, OnPathComplete);</span><br><span class="line">&#125;</span><br><span class="line">public void OnPathComplete(Path p)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(&quot;Yay, we got a path back. Did it have an error? &quot; + p.error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，会显示如图的绿色寻路路径，如果未显示，检查seeker脚本中的Draw Gizmos选项是否勾选。<br><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/84506670.jpg" alt="img"></p>
<p>将Shape属性改为Hexagonal可以将网格更改为六边形：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551784583.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551784583.png" alt="Image 0011551784583.png"></a></p>
<p>也可以修改为适用于ISO的寻路网格：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551784750.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551784750.png" alt="Image 0011551784750.png"></a></p>
<h2 id="1-2-NavMesh-Graph"><a href="#1-2-NavMesh-Graph" class="headerlink" title="1.2 NavMesh Graph"></a>1.2 NavMesh Graph</h2><h2 id="1-3-Point-Graph"><a href="#1-3-Point-Graph" class="headerlink" title="1.3 Point Graph"></a>1.3 Point Graph</h2><p>（1）场景内添加添加物体和上面的图也一样，不过过多了一个如图的<strong>Way</strong>节点，用于当作路点使用。在Way中添加一些Cube充当路点。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551672728.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551672728.png" alt="Image 0011551672728.png"></a></p>
<p>（2）在A*组件中添加Point Graph。并将<strong>Root属性</strong>设置为Way。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551672544.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551672544.png" alt="Image 0011551672544.png"></a></p>
<p>（3）点击Scan即可。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551672681.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551672681.png" alt="Image 0011551672681.png"></a></p>
<h2 id="1-4-Recast-Graph"><a href="#1-4-Recast-Graph" class="headerlink" title="1.4 Recast Graph"></a>1.4 Recast Graph</h2><p><strong>（1）</strong>和1.1的Grid做一样的准备工作</p>
<p><strong>（2）</strong>在AstarPath组件中添加RecastGraph。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551669627.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551669627.png" alt="Image 0011551669627.png"></a></p>
<p><strong>（3）</strong>点击Snap Bounds按钮，组件会自动适配场景中的地形。<a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551671673.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551671673.png" alt="Image 0011551671673.png"></a></p>
<p><strong>（4）</strong>点击Scan 生成NavMesh</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551671933.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551671933.png" alt="Image 0011551671933.png"></a></p>
<p><strong>（5）</strong>寻路脚本的添加和1.1一样，不再介绍。</p>
<h2 id="1-5-Layered-Grid-Graph"><a href="#1-5-Layered-Grid-Graph" class="headerlink" title="1.5 Layered Grid Graph"></a>1.5 Layered Grid Graph</h2><p>Layered 图和Grid图的生成方式一样，但Layered图可以分辨出台阶和地面，如图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551684240.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551684240.png" alt="Image 0011551684240.png"></a></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551684260.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551684260.png" alt="Image 0011551684260.png"></a></p>
<p>Layered图中可以明确的分出台阶和地面</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551775319.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（中）/Image 0011551775319.png" alt="Image 0011551775319.png"></a><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding中/Image 0011551775716.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E4%B8%AD/Image%200011551775716.png" alt="Image 0011551775716.png"></a></p>
<p>Grid会将台阶下面的区域设定为不可走</p>
<h1 id="一些常用场景"><a href="#一些常用场景" class="headerlink" title="一些常用场景"></a>一些常用场景</h1><h2 id="1-1-RVO"><a href="#1-1-RVO" class="headerlink" title="1.1 RVO"></a>1.1 RVO</h2><h2 id="1-7-问题"><a href="#1-7-问题" class="headerlink" title="1.7 问题"></a>1.7 问题</h2><p>1.Grid和Lay图的图层问题</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity插件：AStarPathfinding寻路系统（下）</title>
    <url>/2019/12/11/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>本文为AStarPathfinding插件的进阶内容，如果需要简单的使用寻路功能可以看上和中。</p>
<p>AI漫游以及扩展系统暂时没有做介绍，感兴趣的可以去官网看。</p>
<a id="more"></a>
<h1 id="Navmesh-Cutting（付费功能）"><a href="#Navmesh-Cutting（付费功能）" class="headerlink" title="Navmesh Cutting（付费功能）"></a>Navmesh Cutting（付费功能）</h1><p><a href="https://arongranberg.com/astar/docs/navmeshcutting.html">官方文档</a></p>
<p>Navmesh Cutting用于动态添加一个物体时，移除（切割）Navmesh或Recast图中被障碍物阻挡的部分。Navmesh Cutting很适用于动态添加物体/障碍物的场景。（通常情况下Navmesh/Recast只允许更改现有的节点参数，不允许添加新内容或更改节点的位置）</p>
<p>官方文档不知道为什么没有写如何使用Navmesh Cutting是如何使用的，下面给出我使用此功能的流程：</p>
<p>1.首先新建一个具有Recast图并能正确使用的场景。</p>
<p>2.添加一个空物体，命名为Helper，为Helper添加Tile Handler Helper组件。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546871877.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546871877.png" alt="Image 0011546871877.png"></a></p>
<p>（Tile Handler Helper组件干嘛用的）</p>
<p>3.添加一个障碍物，并为其添加NavMesh Cut组件，并按下图中所示调整参数：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding上/Image 0011546871977.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011546871977.png" alt="Image 0011546871977.png"></a></p>
<p>4.运行游戏，拖动障碍物时NavMesh被遮挡的部分会不可用。</p>
<p>需要注意的是，切割的形状是XZ轴投影到Navmeshi平面的2D图形，不是3D，但2D图形通过拉伸也形成了高度，高度用于判断物体距离平面多高就需要切割的高度：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding上/Image 0011546931837.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011546931837.png" alt="Image 0011546931837.png"></a></p>
<p>所以只有物体在navmeshcut组件中设置的图形与NavMesh的接触部分才会被切割，包括高度和半径。</p>
<p>Is dual功能到底干嘛的</p>
<p>在3.x中，navmesh切割只能与重铸图一起使用，但在4.x中，它们可以与重铸和导航网图一起使用。</p>
<p>切割的形状可以自定义，自定义形状时有一些需要注意的细节，具体自行查看官方文档。</p>
<p>Navmesh Cutting会定期检查切割的应用，但也可以通过代码立即更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Schedule pending updates to be done as soon as the pathfinding threads</span><br><span class="line">// are done with what they are currently doing.</span><br><span class="line">AstarPath.active.navmeshUpdates.ForceUpdate();</span><br><span class="line">// Block until the updates have finished</span><br><span class="line">AstarPath.active.FlushGraphUpdates();</span><br><span class="line"></span><br><span class="line">也可以通过代码控制检查navmeshcut是否变化的时间:</span><br><span class="line"></span><br><span class="line">// Check every frame (the default)</span><br><span class="line">AstarPath.active.navmeshUpdates.updateInterval = 0;</span><br><span class="line"></span><br><span class="line">// Check every 0.1 seconds</span><br><span class="line">AstarPath.active.navmeshUpdates.updateInterval = 0.1f;</span><br><span class="line"></span><br><span class="line">// Never check for changes</span><br><span class="line">AstarPath.active.navmeshUpdates.updateInterval = -1;</span><br><span class="line">// You will have to schedule updates manually using</span><br><span class="line">AstarPath.active.navmeshUpdates.ForceUpdate();</span><br></pre></td></tr></table></figure>
<p>（代码都不好使）</p>
<p>也可以通过Update Interval来更改。（这个值的更改位置不对 版本不同？？ ）</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546945990.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546945990.png" alt="Image 0011546945990.png"></a></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding上/Image 0011546943710.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011546943710.png" alt="Image 0011546943710.png"></a></p>
<p>因为navmesh切割可以很好地修改navmesh中的三角形，所以在更新图形时不可能保留标签和惩罚。对于在应用更新时保持完全相同的节点，将保留标签和惩罚。</p>
<p>如果您需要使用标记，唯一可靠的方法是保留它们是应用所有图形更新，每次完成导航网格剪切更新时都会设置它们。这当然相对较慢，但它至少会起作用。</p>
<h1 id="RVO（付费）"><a href="#RVO（付费）" class="headerlink" title="RVO（付费）"></a>RVO（付费）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>到底躲的是谁  需不需要操作</p>
<p>AStarPathfinding使用了基于RVO的局部回避系统（Low level），RVO的性能良好，根据开发者的测试，i7处理器的电脑上可以以50-100FPS模拟五千个具有RVO系统的Agent。关于本章节，以及压力测试请看：<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/localavoidance.html">https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/localavoidance.html</a></p>
<p>RVO是路径规划中的Low level底层避障算法，用于躲避不可预估的障碍。具体看：</p>
<p>RVO基于采样检测和gradient descent算法来找到最佳躲避方案。它非常适合于移动的类人代理。但不太适合不能快速变换速度的物体。</p>
<p>RVO系统分为两个部分，一是完全独立不依赖Unity的核心代码，唯一使用到的Unity类是Math。核心代码控制着所有使用ROV的Agent。</p>
<blockquote>
<p>The RVO system is divided into two parts. First there is the core simulation code. It is completely independent of Unity specific objects such as GameObjects and MonoBehaviours. The only really Unity specific classes it uses are math classes which are easily interchangeable. This core handles all simulation of rvo (local avoidance) agents.</p>
</blockquote>
<p>第二部分是Unity接口，大多数的类只是对应核心代码的包装类。例如RVOSimulator类只是Pathfinding.RVO.Simulator的包装类，为了更方便的集成使用，接口还包括一些帮助类。如会经常使用到的RVOController，似于Unity的Character Controller的类，支持Move等等功能，也可以更改如速度之类的属性。</p>
<blockquote>
<p>The second part is the Unity interface. Many of those classes are just wrappers for the corresponding core classes. The RVOSimulator class is for example just a wrapper class for the Pathfinding.RVO.Simulator class. The Unity interface also contains helper classes for much easier local avoidance integration. One of those is the RVOController which you will probably use quite a lot. It is written to be similar to the Unity Character Controller, supporting functions such as Move and has properties such as velocity which you can easily access.</p>
</blockquote>
<p>Unity接口部分的所有脚本都假设场景中有且只有一个RVOSimulator，并会找到RVOSimulator获取核心代码部分。RVOSimulator可以被添加到任何游戏物体，通过一些简单的设置就可以正常工作。但注意，不要在场景内添加多个RVOSimulator，接口脚本通过FindObjectOfType 来找到RVOSimulator，FindObjectOfType无法精确控制将返回哪一个RVOSimulator。</p>
<blockquote>
<p>All of the scripts in the Unity interface part share common assumptions on how the scene should be set up: There should always be one (1) RVOSimulator in the scene, other scripts will look for it and get the core simulator instance it is a wrapper for. You can simply add it to any GameObject, edit the few settings if you want and it will work. You should never have more than one, all scripts which look for it use FindObjectOfType and there is no easy way to control exactly which of the multiple RVOSimulators it will return, so keep it to one for simplicity’s sake.</p>
</blockquote>
<h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>插件的AI脚本中，AIPath, RichAI支持RVOController，在挂载AIPath或RichAI脚本的物体上添加RVOController即可使用。（下面的Demo中不也是添加即可使用吗）</p>
<p>（3.x版本RVO在Rigidbody或CharacterController也被挂载的情况下不能很好地工作。因为RVO系统想要完全控制代理的移动。 在4.x中，可以将它与Rigidbody或CharacterController组件一起使用。需要注意的是，本地回避系统不使用碰撞系统，也不会试图避开碰撞体。）</p>
<p>AILerp脚本设计用于沿路径插入并完全跟随它，因此它没有意义偏离路径，因此它不支持本地回避。（AIlerp是怎么工作的）</p>
<h3 id="物理系统"><a href="#物理系统" class="headerlink" title="物理系统"></a>物理系统</h3><p>在拥挤情况下对Agent使用碰撞（或刚体）组件可能会使RVO的性能急剧下降，因为当拥挤时Agent可能会彼此重叠一部分。虽然Unity的物理系统会防止这种情况发生，但它并没有RVO系统做的好，还会产生错误的运动路线。</p>
<blockquote>
<p>Often you want to have colliders on your agents, maybe to be able to hit them with bullets or something. However if you just add colliders (plus a rigidbody) to your agents you may see that the local avoidance quality goes down drastically in crowded scenarios. This is because when it is very crowded agents may overlap a tiny bit, the physics system will prevent that, but it will not do it in as nice a way as the local avoidance system, and this may lead to worse movement.</p>
</blockquote>
<p>如果Agent上有碰撞器，作者建议的解决办法是禁用代理之间的物理碰撞，将所有的代理放到一个单独的图层中，在Unity的物理系统设置中将该图层自身的碰撞关闭。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/disable_collisions.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/disable_collisions.png" alt="disable_collisions.png"></a></p>
<h3 id="保持代理在图中"><a href="#保持代理在图中" class="headerlink" title="保持代理在图中"></a>保持代理在图中</h3><p>在局部躲避时，在拥挤的情况下会出现Agent将另一个Agent推出图外的情况。</p>
<p>如果使用RichAI，则会自动处理被推出的情况。因为RichAI的移动需要它。如果使用AIPath，可以通过启用constrainInsideGraph来避免。</p>
<p>还有一种办法是使用RVONavmesh 组件，组件会将图的边界转化为障碍物添加进RVO系统。RVONavmesh计算成本偏高，尤其是在图较大或者运行时更新图的时候，但它允许RVO系统更好地预测障碍，而不是当撞到时才找到墙壁。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011547030156.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011547030156.png" alt="Image 0011547030156.png"></a></p>
<p>如图所示，组件在图的边缘围一堵墙。但这样会增加一些性能开销（尤其是较大的图或者在运行期间更新图。）</p>
<p>使用方法：在场景中的任意物体添加RVONavmesh组件即可，可以通过RVOSimulator组件中的Draw Obstacles显示如图橙色的线。</p>
<h3 id="障碍"><a href="#障碍" class="headerlink" title="障碍"></a>障碍</h3><p>将障碍添加至本地躲避系统后，代理将不会通过并且会使用本地躲避系统躲开障碍。</p>
<p>在Component-Pathfinding-Localavoidance中可以找到用于添加障碍物的组件，如图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011547032327.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011547032327.png" alt="Image 0011547032327.png"></a></p>
<p>也可以自己写碰撞器，看下章。</p>
<p>内置的碰撞体可以移动，并且可以适当的更新。但因为可以在周围移动并不代表移动的内置碰撞体可以将代理推开。事实上移动的内置碰撞体并不擅长这样。当碰撞体移动很慢时可以实现推开，但移动很快时会导致代理卡住。</p>
<p>内置的障碍物组件有一个属性很重要，Obstacle Mode，有两个值：Keep out会阻止代理进入障碍物，但如果处于某种原因留在了里面则会很容易出来。Keep in会将代理留在障碍物内部自由移动。</p>
<p>（需要一个例子 gif）</p>
<h2 id="使用RVO组件"><a href="#使用RVO组件" class="headerlink" title="使用RVO组件"></a>使用RVO组件</h2><p>首先根据官方Demo做一个简单的练习：</p>
<p>1.创建一个新场景，添加一个平面尽量大一点。然后添加一个空物体命名为Simulator，并为其添加RVOSimulator组件。</p>
<p>2.添加一个新的圆柱体，并为其添加RVOController组件，将RVOController组件中的高度参数设置为圆柱体的高度，RVOController的作用和Character Controller差不多。</p>
<p>3.编写一个脚本，让圆柱体动起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using Pathfinding.RVO;</span><br><span class="line"></span><br><span class="line">public class SimpleRVOAI : MonoBehaviour &#123;</span><br><span class="line">RVOController controller;</span><br><span class="line"></span><br><span class="line">// Use this for initialization</span><br><span class="line">void Awake () &#123;</span><br><span class="line">controller = GetComponent&lt;RVOController&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Update is called once per frame</span><br><span class="line">public void Update () &#123;</span><br><span class="line">// Just some point far away</span><br><span class="line">var targetPoint = transform.position + transform.forward * 100;</span><br><span class="line"></span><br><span class="line">// Set the desired point to move towards using a desired speed of 10 and a max speed of 12</span><br><span class="line">controller.SetTarget(targetPoint, 10, 12);</span><br><span class="line"></span><br><span class="line">// Calculate how much to move during this frame</span><br><span class="line">// This information is based on movement commands from earlier frames</span><br><span class="line">// as local avoidance is calculated globally at regular intervals by the RVOSimulator component</span><br><span class="line">var delta = controller.CalculateMovementDelta(transform.position, Time.deltaTime);</span><br><span class="line">transform.position = transform.position + delta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.复制几个圆柱体并调整至相对，运行游戏可以看到圆柱体会尝试躲避其他圆柱体。</p>
<p>可以从代码看出来，<strong>RVOController本身不处理移动</strong>。因为一旦其他脚本也在控制移动，就会引起混乱。（在4.0之前RVOController是处理移动的）</p>
<p>RVOSimulator实际上是 <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/simulator.html">Pathfinding.RVO.Simulator</a>的包装类。</p>
<p>rvo面板介绍</p>
<h2 id="添加RVO障碍"><a href="#添加RVO障碍" class="headerlink" title="添加RVO障碍"></a>添加RVO障碍</h2><p>可以通过代码获取到RVOSimulator：</p>
<p>Pathfinding.RVO.Simulator sim = (FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator).GetSimulator ();</p>
<p>通过以下代码可以添加一个障碍物到RVO系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class SimpleRVOObstacle : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">void Start () &#123;</span><br><span class="line">//Get the simulator for this scene</span><br><span class="line">Pathfinding.RVO.Simulator sim = (FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator).GetSimulator ();</span><br><span class="line"></span><br><span class="line">//Define the vertices of our obstacle</span><br><span class="line">Vector3[] verts = new Vector3[] &#123;new Vector3(1,0,-1), new Vector3(1,0,1), new Vector3 (-1,0,1), new Vector3 (-1,0,-1)&#125;;</span><br><span class="line"></span><br><span class="line">//Add our obstacle to the simulation, we set the height to 2 units</span><br><span class="line">sim.AddObstacle (verts, 2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意添加向量的方向不同会有不同的结果：</p>
<p>System.Array.Reverse (verts);</p>
<p>顺时针是keep in，逆时针使keep out。</p>
<p>也可以把一条线作为障碍物添加至系统：<br>sim.AddObstacle (firstPoint, secondPoint, height);</p>
<h1 id="Tag和GraphUpdateScene"><a href="#Tag和GraphUpdateScene" class="headerlink" title="Tag和GraphUpdateScene"></a>Tag和GraphUpdateScene</h1><p>GraphUpdateScene是一个功能很强的组件，可以划分自定义区域并更改惩罚值。</p>
<p>Tag是插件的新功能，可以控制每个代理的行走区域。例如场景中有闲逛的动物和人，那他们可以走的区域是不一样的（动物不会走入人住的房子），这时就需要使用Tag来实现。</p>
<p><strong>划分自定义代价值区域的使用方法：</strong></p>
<p><strong>1.</strong>在场景中创建一个空物体命名为GUO（不是必须的），添加组件<strong>Graph Update Scene。</strong></p>
<p><strong>2.</strong>点击GUO，在场景中按住左Shift键，然后点击你想划分区域的地方，会出现一个点，再点击一下会将两个点连接起来。这样就可以创建出一块自定义的区域：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/Honeycam 2019-03-11 16-39-23.gif"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Honeycam 2019-03-11 16-39-23.gif" alt="Honeycam 2019-03-11 16-39-23.gif"></a></p>
<p>节点的位置信息可以在组件的Points属性里进行修改。</p>
<p><strong>3.</strong>根据组件中的Penalty Delta来修改区域的代价值，不同的代价会让Agent在寻路时选择最优的路线，避开代价较大的区域。也可以设置为不可走区域。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/Image 0011552293900.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011552293900.png" alt="Image 0011552293900.png"></a></p>
<p><strong>4.</strong>如图所示，代理会尝试绕过代价高的区域</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/Image 0011552295310.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011552295310.png" alt="Image 0011552295310.png"></a></p>
<p><strong>Tag的使用方法：</strong></p>
<p>Tag可以使两个Agent在同样的区域有不同的寻路结果.</p>
<p>0.新建一个场景，场景中像之前的流程一样，保持有地板，寻路目标，Agent，并可以正常寻路。</p>
<p>1.利用<strong>Graph Update Scene</strong>划分一片区域，并为区域添加一个Tag，命名为Grass（Tag的名称可以在A*组件的面板中修改。）</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/Image 0011552296107.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011552296107.png" alt="Image 0011552296107.png"></a></p>
<p>2.添加两个agent，并附加Seeker脚本。修改Seeker的Tag属性，一个Agent将tag的Traversable取消勾选，另一个保持勾选。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/Image 0011552547742.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011552547742.png" alt="Image 0011552547742.png"></a></p>
<p>3.运行游戏，两个Agent会规划出不同的路径。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/Image 0011552548056.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011552548056.png" alt="Image 0011552548056.png"></a></p>
<p>也可以对每个Agent的每个Tag设置不同的惩罚值，可以实现开头说的场景。</p>
<hr>
<p>NavMesh下有问题</p>
<p>公共惩罚值和个人惩罚值的计算关系</p>
<p>能做的：</p>
<p>自定义区域的惩罚值</p>
<p>自定义区域为不可走</p>
<p>讲某区域更改为a可走b不可走</p>
<p>将某区域更改为a的惩罚值高，b的低</p>
<p>GraphUpdateScene是什么</p>
<h1 id="实时更新图"><a href="#实时更新图" class="headerlink" title="实时更新图"></a>实时更新图</h1><p>对于实时更新，不同场景有不同的需求，比如可能只更改了一部分，需要更新一部分地图。如果更改了整张地图则需要更新全部。还有可能需要加载/保存地图（具体介绍不在本章）等等。不同的需求需要不同的功能，下面的表列出了开发时会遇到的场景，以及对应的解决策略。</p>
<table>
<thead>
<tr>
<th>需求</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>重新计算整张图</td>
<td>阅读重新计算整张图</td>
</tr>
<tr>
<td>精准的设置哪些节点可走，哪些不可以</td>
<td>阅读直接使用图数据或应用于回合制游戏章节</td>
</tr>
<tr>
<td>在某些物体移动或创建销毁时更新图</td>
<td>阅读重计算部分图或<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/dynamicgridobstacle.html">DynamicGridObstacle</a>类或<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/navmeshcutting.html">Navmesh Cutting</a>章节</td>
</tr>
<tr>
<td>修改某单个节点的属性</td>
<td>阅读直接使用图数据或GraphUpdateScene</td>
</tr>
<tr>
<td>动态加载或卸载地图</td>
<td>阅读保存和加载地图</td>
</tr>
<tr>
<td>创建一小块图在角色周围</td>
<td>阅读<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/proceduralgridmover.html">ProceduralGridMover</a>类</td>
</tr>
<tr>
<td>创建新节点并使用代码连接他们</td>
<td>See <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/pointgraph.html#AddNode">PointGraph.AddNode</a> and <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/writinggraphgenerators.html">Writing Graph Generators</a></td>
</tr>
<tr>
<td>使图的一部分成本变高</td>
<td>See <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdates.html#smaller-updates">Recalculating parts of graphs</a>, <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdates.html#direct">Using direct access to graph data</a> and <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdatescene.html">GraphUpdateScene</a></td>
</tr>
<tr>
<td>阻止一些单位穿过某个节点，但是其他节点可以穿过</td>
<td>See <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/tags.html">Working with tags</a>, <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdates.html#smaller-updates">Recalculating parts of graphs</a>, <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdatescene.html">GraphUpdateScene</a> and <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdates.html#direct">Using direct access to graph data</a></td>
</tr>
<tr>
<td>移动物体的寻路（如一艘船）</td>
<td>See the example scene called ‘Moving’ (pro version only). This is not that well documented at the moment.</td>
</tr>
<tr>
<td>添加一个障碍物，但首先确定障碍物没有困住或覆盖任何其他单位（TD游戏）</td>
<td>See <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdates.html#blocking">Check for blocking placements</a></td>
</tr>
</tbody>
</table>
<h2 id="需要更新的内容"><a href="#需要更新的内容" class="headerlink" title="需要更新的内容"></a>需要更新的内容</h2><p>当需要更新图时，通常会需要做两件事情中的一件。</p>
<p>你可能希望使用与最初生成图时相同的设置重新计算图形，但如果为了更新一部分区域而重新计算了整个图似乎很浪费（<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/astarpath.html#Scan">AstarPath.Scan</a>），比如，玩家可能只是TD游戏中放置了一座新塔。</p>
<p>或者只想要更改现有图的某些设置。例如，更改某些节点上的tag或代价。</p>
<p>可以对除了NavMesh之外的图重新计算一小部分，navmesh只有完全重新计算才有意义。使用脚本和GraphUpdateScene组件执行此操作，将名为“updatePhysics”的字段设置为true。</p>
<p>Grid 图会正常工作，只需指定边界，它就会为你完成所有操作。但是，考虑到侵蚀等问题，它可能会重新计算一个比指定边界略大的区域。</p>
<p>Recast  图只能全部重新计算。因此，使用较小的tile尺寸可以缩短重新计算的时间。但是如果太小，Recast图会退化为Grid图。如果使用多线程，则会将大部分重新计算放置到单独的线程中，以避免过多地影响FPS。</p>
<p>点图将重新计算通过边界的所有连接。但是，它不会寻找以GameObject形式新添加的新节点，为此你需要使用  <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/astarpath.html#Scan">AstarPath.Scan</a>.</p>
<p>如想更改节点的属性，有一些东西可供你修改</p>
<p>你可以更改node的tag以实现不同单位行走不同区域，也可以修改节点的惩罚值</p>
<p>可以更改节点上的惩罚。这用于使某些节点比其他节点更难/更慢地遍历，以便代理在其他节点之前更喜欢某些路径。但是有一些限制。您不能指定负惩罚，因为使用的算法无法处理（如果可能，系统会慢得多）。然而，常见的技巧是设置非常大的初始惩罚（可以在图形设置中完成），然后从该高值减少惩罚。但请注意，由于必须搜索更多节点，因此这将使路径寻找更慢。所需的惩罚值非常高。没有真正的“惩罚单位”，但罚款1000大致相当于一个世界旅行单位。</p>
<blockquote>
<p>You can change the penalty on the nodes. This is used to make some nodes harder/slower to traverse compared the other nodes so that an agent will prefer some paths before others. There are some limitations though. You cannot specify negative penalties since the algorithms used cannot handle that (and if they could, the system would be a lot slower). However a common trick is to set a very large initial penalty (which can be done in the graph settings) and then decrease the penalty from that high value. Note however that this will make pathfinding slower overall since it has to search more nodes. The penalty values that are required are quite high. There is no real “penalty unit” however a penalty of 1000 corresponds roughly to one world unit of travel.</p>
</blockquote>
<p>也可以直接修改节点的可步行性。 因此，您可以使某些边界内的所有节点都可以步行或全部无法行走。</p>
<p>有关如何使用GraphUpdateScene组件的信息。 查看该课程的文档。 GraphUpdateScene组件设置几乎将1到1映射到GraphUpdateObject，在使用脚本更新图形时使用GraphUpdateObject。 因此，即使您只是使用脚本，我也建议您阅读该页面。</p>
<hr>
<h2 id="重新计算整张图"><a href="#重新计算整张图" class="headerlink" title="重新计算整张图"></a>重新计算整张图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Recalculate all graphs</span><br><span class="line">AstarPath.active.Scan();</span><br><span class="line"></span><br><span class="line">// Recalculate only the first grid graph</span><br><span class="line">var graphToScan = AstarPath.active.data.gridGraph;</span><br><span class="line">AstarPath.active.Scan(graphToScan);</span><br><span class="line"></span><br><span class="line">// Recalculate only the first and third graphs</span><br><span class="line">var graphsToScan = new [] &#123; AstarPath.active.data.graphs[0], AstarPath.active.data.graphs[2] &#125;;</span><br><span class="line">AstarPath.active.Scan(graphsToScan);</span><br></pre></td></tr></table></figure>
<p>协程加载 但不能保证良好的FPS，但至少可以显示加载屏幕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IEnumerator Start () &#123;</span><br><span class="line">foreach (Progress progress in AstarPath.active.ScanAsync()) &#123;</span><br><span class="line">Debug.Log(&quot;Scanning... &quot; + progress.description + &quot; - &quot; + (progress.progress*100).ToString(&quot;0&quot;) + &quot;%&quot;);</span><br><span class="line">yield return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下这俩</p>
<p><a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/astarpath.html#Scan">AstarPath.Scan</a></p>
<p><a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/astarpath.html#ScanAsync">AstarPath.ScanAsync</a></p>
<h2 id="重新计算部分图"><a href="#重新计算部分图" class="headerlink" title="重新计算部分图"></a>重新计算部分图</h2><p>可以使用GraphUpdateScene组件或使用脚本,调用AstarPath类中的方法完成部分图更新，脚本通过使用Bounds对象或Pathfinding.GraphUpdateObject（就是GraphUpdateScene组件，实际上是在后台就是这么运行的）。</p>
<blockquote>
<p>Smaller graph updates can either be done using the GraphUpdateScene component which can be edited in the Unity inspector or using scripting which is done by calling a method in the AstarPath class with either a Bounds object or a Pathfinding.GraphUpdateObject (which is what the GraphUpdateScene component actually does in the background).</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bounds bounds = GetComponent&lt;Collider&gt;().bounds;</span><br><span class="line">AstarPath.active.UpdateGraphs(bounds);</span><br><span class="line">// using Pathfinding; //At top of script</span><br><span class="line"></span><br><span class="line">// As an example, use the bounding box from the attached collider</span><br><span class="line">Bounds bounds = GetComponent&lt;Collider&gt;().bounds;</span><br><span class="line">var guo = new GraphUpdateObject(bounds);</span><br><span class="line"></span><br><span class="line">// Set some settings</span><br><span class="line">guo.updatePhysics = true;</span><br><span class="line">AstarPath.active.UpdateGraphs(guo);</span><br></pre></td></tr></table></figure>
<p>然后，该方法将任务放入队列中，以便在下一个路径计算之前执行。它必须放在一个队列中，因为如果它直接执行会干扰寻路，特别是多线程开启的情况下，会导致无法直接看到图形的更新，所以它将始终在下一次寻路计算开始之前更新。</p>
<blockquote>
<p>The method will then put the task in a queue to be carried out before the next path calculation. It has to be put in a queue because if it carried out directly, it might interfere with pathfinding, especially if multithreading is on, and cause all kinds of errors. This means that you might not see an update of the graph directly, but it will always be updated before the next pathfinding calculation starts (almost always, see AstarPath.limitGraphUpdates ).</p>
</blockquote>
<p>Recast图也可以使用<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/navmeshcutting.html">navmesh cutting</a>伪更新，<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/navmeshcutting.html">navmesh cutting</a>可以使障碍物在Navmesh中切出一个洞，但无法添加更多的Navmesh平面。See <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/navmeshcut.html">Pathfinding.NavmeshCut</a>，比重新计算整张图快的多，但是有更有限。</p>
<p>如果在Unity的Editor中编辑修改已知的图形，那么使用GraphUpdateScene组件是最方便简单的，使用组件你可以轻松更改特定区域的tag而无需任何代码。 但是，如果需要在游戏中动态执行，则使用代码更新图会更方便。 例如，在塔防游戏中新放置的建筑物的更新部分表操作。</p>
<h2 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h2><p>需要创建GraphUpdateObject并设置所需的参数，然后调用AstarPath.UpdateGraphs方法，将更新任务添加至队列中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// using Pathfinding; //At top of script</span><br><span class="line"></span><br><span class="line">// As an example, use the bounding box from the attached collider</span><br><span class="line">Bounds bounds = GetComponent&lt;Collider&gt;().bounds;</span><br><span class="line">var guo = new GraphUpdateObject(bounds);</span><br><span class="line"></span><br><span class="line">// Set some settings</span><br><span class="line">guo.updatePhysics = true;</span><br><span class="line">AstarPath.active.UpdateGraphs(guo);</span><br></pre></td></tr></table></figure>
<p>bounds变量是UnityEngine.Bounds对象，它定义了一个轴对齐的框，用于更新图形，通常你会想围绕着新创建的对象更新图，通常情况下，更新部分图都是围绕新创建的对象的周围进行更新的，所以在示例中，Bounds取自新对象附加的collider</p>
<p>但是要确保该对象可以被图识别，对于Grid图应该确保对象的图层包含在碰撞检测图层（collision testing mask）或者高度检测图层（ height teting mask）中。</p>
<p>如果在使用网格图或者点图时，不需要重新计算所有节点的参数，可以将updatePhysics 设置为 false以避免不必要的计算</p>
<p>（我的理解是如果局部计算的话，需要将这个选项关闭以避免不必要的计算）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guo.updatePhysics = false;</span><br></pre></td></tr></table></figure>
<p>For details about exactly what fields to set, take a look at the class documentation for the <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateobject.html">GraphUpdateObject </a>.</p>
<h3 id="直接使用图数据"><a href="#直接使用图数据" class="headerlink" title="直接使用图数据"></a>直接使用图数据</h3><p>有时可能需要直接对图数据进行操作。</p>
<p><a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/accessingdata.html">Accessing graph data</a> for information about how to access graph data.</p>
<p><a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/usingnodes.html#node-properties">Node properties</a> and <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphnode.html">Pathfinding.GraphNode</a> for information about what properties a node has.</p>
<p>下面是一个更改网格图中所有节点并使用perlin噪声来决定节点是否应该可以行走的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AstarPath.active.AddWorkItem(new AstarWorkItem(ctx =&gt; &#123;</span><br><span class="line">var gg = AstarPath.active.data.gridGraph;</span><br><span class="line">for (int z = 0; z &lt; gg.depth; z++) &#123;</span><br><span class="line">for (int x = 0; x &lt; gg.width; x++) &#123;</span><br><span class="line">var node = gg.GetNode(x, z);</span><br><span class="line">// This example uses perlin noise to generate the map</span><br><span class="line">node.Walkable = Mathf.PerlinNoise(x * 0.087f, z * 0.087f) &gt; 0.4f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Recalculate all grid connections</span><br><span class="line">// This is required because we have updated the walkability of some nodes</span><br><span class="line">gg.GetNodes(node =&gt; gg.CalculateConnections((GridNodeBase)node));</span><br><span class="line"></span><br><span class="line">// Update the &apos;area&apos; information in the graph.</span><br><span class="line">// This is required because we have updated the connectivity of the graph</span><br><span class="line">ctx.QueueFloodFill();</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>经过修改后的图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding下/Image 0011552639822.png"><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（下）/Image 0011552639822.png" alt="Image 0011552639822.png"></a></p>
<p>只有在安全的情况下才能修改图表数据。路径查找可能随时在运行，因此必须先暂停路径寻找线程，然后更新数据。最简单的方法是使用<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/astarpath.html#AddWorkItem">AstarPath.AddWorkItem</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AstarPath.active.AddWorkItem(() =&gt; &#123;</span><br><span class="line">// Safe to update graphs here</span><br><span class="line">var node = AstarPath.active.GetNearest(transform.position).node;</span><br><span class="line">node.position = (Int3)transform.position;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>更改图数据后要及时更新图。如果更改了任何节点的Walkable或连接，则需要更新Area的信息，系统通过Area来确定哪些节点可以到达哪些其他节点，而这些节点又用于快速确定路径是否可行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AstarPath.active.AddWorkItem(new AstarWorkItem(ctx =&gt; &#123;</span><br><span class="line">var node = AstarPath.active.GetNearest(transform.position).node;</span><br><span class="line">node.Walkable = false;</span><br><span class="line">ctx.QueueFloodFill();</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>QueueFloodFill()是根据性能进行批处理的，因此在连续更新的多个图更新时不需要多次调用QueueFloodFill()。如果需要Area的信息是最新的，则应该调用<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/iworkitemcontext.html#EnsureValidFloodFill">ctx.EnsureValidFloodFill</a>方法。但是通常开发中不会用到。</p>
<blockquote>
<p>The flood fill calls are batched for performance so that multiple graph updates which are executed directly after each other do not have to run the flood fill more than once. If your work item requires that the area information is up to date you should call the ctx.EnsureValidFloodFill method first. Usually this is not something that work items require however.</p>
</blockquote>
<p>如果修改了walkability，需要重新计算节点之间的链接。对于Grid图来说非常重要，可以使用<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/gridgraph.html#CalculateConnections5">GridGraph.CalculateConnections</a>方法。注意，这需要在你更改了walkability的节点以及与其相邻的节点上调用，因为他们可能必须更改其连接以添加或删除该节点作为连接。</p>
<p>AddWorkItem方法也可以以更高级的方式使用。例如，它允许您在必要时将计算分布在多个帧上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AstarPath.active.AddWorkItem(new AstarWorkItem(</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">    // Called once, right before the</span><br><span class="line">    // first call to the method below</span><br><span class="line">&#125;,</span><br><span class="line">        force =&gt; &#123;</span><br><span class="line">    // Called every frame until complete.</span><br><span class="line">    // Signal that the work item is</span><br><span class="line">    // complete by returning true.</span><br><span class="line">    // The &quot;force&quot; parameter will</span><br><span class="line">    // be true if the work item is</span><br><span class="line">    // required to complete immediately.</span><br><span class="line">    // In that case this method should</span><br><span class="line">    // block and return true when done.</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">        ));</span><br></pre></td></tr></table></figure>
<p>debug记得写一下</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>当使用GraphUpdateObject进行实时更新时， 所有可以更新的内置的图都会循环调用自身的UpdateArea 方法。</p>
<p>图将每一个需要被更新或受影响的节点发送给<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateobject.html#Apply">Pathfinding.GraphUpdateObject.Apply </a>， Apply方法会更改惩罚值，walkablity或者其他指定的参数，图也可以使用特定的更新逻辑，如GridGraph(see <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdates.html#gridgraphs">GridGraph specific details</a>)。你不需要明白这些更新方法的不同，这些方法的具体细节的了解适合想使用源码的人。</p>
<blockquote>
<p>When updating is carried out using a GraphUpdateObject, all graphs will be looped over and those which can be updated (all built in ones) will have their UpdateArea function called (i.e be updated).<br>Each node is updated by the graphs calling <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateobject.html#Apply">Pathfinding.GraphUpdateObject.Apply</a> sending each affected node to it, the Apply function will then change penalty, walkability or other parameters specified. Graphs can also use custom updating logic, such as the GridGraph (see <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdates.html#gridgraphs">GridGraph specific details</a>). You do not have to understand all different function calls to be able to use it, those are mostly for people who want to mess around with the source code.</p>
</blockquote>
<h3 id="Gird图的特殊细节"><a href="#Gird图的特殊细节" class="headerlink" title="Gird图的特殊细节"></a>Gird图的特殊细节</h3><p><a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateobject.html#updatePhysics">updatePhysics</a>是更新Gird图时非常重要的属性，如果设置为true，所有被影响的节点都会重新计算他们的高度，然后检查自身是否可走。当更新Grid图时，最好保持为true。</p>
<p>当更新Grid图时，GraphUpdateObject的Apply方法会被更新范围内的所有节点调用，节点会检查<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateobject.html#updatePhysics">updatePhysics</a>变量，如果<a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateobject.html#updatePhysics">updatePhysics</a>设置为true（默认值是true），则更新区域会根据Collision Testing设置的直径扩张，并且在其中的每个节点都会做碰撞检测，如果是false，则只有更新区域内的节点会调用Apply方法，并不会做其他事情。</p>
<blockquote>
<p>The updatePhysics variable matters a lot when updating grid graphs. If it is set to true, all nodes affected will have their height recalculated and then checked if they are still walkable. You usually want to leave this to true when updating a grid graph.</p>
<p>When updating a GridGraph, the GraphUpdateObject’s Apply function (which changed walkability, tags and penalties) will be called for each node inside the bounds, it will check the updatePhysics variable, if it is true (which is the default value), the area will be expanded by the diameter of the specified in the Collision Testing settings and every node inside the area will be checked for collisions. If it is false, however, only the Apply function will be called for the nodes inside the area (not expanded) and nothing else will be done.</p>
</blockquote>
<h3 id="基于Navmesh的图"><a href="#基于Navmesh的图" class="headerlink" title="基于Navmesh的图"></a>基于Navmesh的图</h3><p>基于navmesh的图（Navmesh和RecastGraph）只支持更新已存在的节点的惩罚，walkablity等以更新整个图，GraphUpdateObjects 不能添加新的节点（更新整个图除外），GraphUpdateObject 会更新所有交叉接触的节点/多边形，或者在GUO范围内的所有节点。对于recast也可以通过Nacmesh cut快速更新图。</p>
<blockquote>
<p>Navmesh based graphs (NavMeshGraph and RecastGraph) only have support for updating penalty, walkability and similar on already existing nodes or for recast graphs, to completely recalculate whole tiles. New nodes cannot be created using GraphUpdateObjects (unless recalculating whole tiles). The GraphUpdateObject will affect all nodes/triangles which intersect or are contained by the GUO’s bounds.<br>For recast graphs you can also use <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/navmeshcut.html">navmesh cutting </a>to update the graph in a fast way.</p>
</blockquote>
<h3 id="点图（PointGraphs）"><a href="#点图（PointGraphs）" class="headerlink" title="点图（PointGraphs）"></a>点图（PointGraphs）</h3><p>点图的更新会调用边界内的所有节点的Apply方法，GraphUpdateObject.updatePhysics如果设置为true，它还会重新计算经过更新区域的所有链接点。</p>
<h2 id="Graph-Update-Object"><a href="#Graph-Update-Object" class="headerlink" title="Graph Update Object"></a>Graph Update Object</h2><p>The GraphUpdateObject contains some basic variables on how to update each node. See documentation for the <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateobject.html">Pathfinding.GraphUpdateObject</a> for more info.</p>
<h4 id="从GraphUpdateObject继承"><a href="#从GraphUpdateObject继承" class="headerlink" title="从GraphUpdateObject继承"></a>从GraphUpdateObject继承</h4><p>GraphUpdateObject可以被继承，覆写某些方法。下面是一个例子，执行父类Apply方法的同时移动节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using Pathfinding;</span><br><span class="line"></span><br><span class="line">public class MyGUO : GraphUpdateObject &#123;</span><br><span class="line">public Vector3 offset = Vector3.up;</span><br><span class="line">public override void Apply (GraphNode node) &#123;</span><br><span class="line">// Keep the base functionality</span><br><span class="line">base.Apply(node);</span><br><span class="line">// The position of a node is an Int3, so we need to cast the offset</span><br><span class="line">node.position += (Int3)offset;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Start () &#123;</span><br><span class="line">    MyGUO guo = new MyGUO();</span><br><span class="line"></span><br><span class="line">    guo.offset = Vector3.up*2;</span><br><span class="line">    guo.bounds = new Bounds(Vector3.zero, Vector3.one*10);</span><br><span class="line">    AstarPath.active.UpdateGraphs(guo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检查是否阻塞（塔防）"><a href="#检查是否阻塞（塔防）" class="headerlink" title="检查是否阻塞（塔防）"></a>检查是否阻塞（塔防）</h2><p>在塔防游戏中很重要的一点是，玩家放置的塔没有使出兵点和目标点直接堵塞，插件为此提供了对应的API。</p>
<p><a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateutilities.html#UpdateGraphsNoBlock">Pathfinding.GraphUpdateUtilities.UpdateGraphsNoBlock</a>方法会检查给定的graph update object是否会引起两个或更多的点引起堵塞，然而该方法会比常规更新图速度要慢，所以你可能不会经常使用它。</p>
<p>举个例子，当玩家再塔防游戏中放置一个防御塔的时候，你可以初始化防御塔，然后调用UpdateGraphsNoBlock方法检查新添加的防御塔是否会阻挡路径，如果是则立即移除防御塔并提示玩家选择的位置不符合规则。你也可以传递节点列表给UpdateGraphsNoBlock方法，这样不仅可以确定初始点和目标点之间没有堵塞，并且在单位行走时可以放置防御塔的情况下，所有单位都能到达目标。</p>
<blockquote>
<p>The <a href="https://arongranberg.com/astar/documentation/4_1_16_7f164ebc/graphupdateutilities.html#UpdateGraphsNoBlock">Pathfinding.GraphUpdateUtilities.UpdateGraphsNoBlock</a> method can be used to first check if a given graph update object will cause the path between two or more points to become blocked. This is however slower than a normal graph update so you probably don’t want to use it too often.</p>
<p>For example when a player in a tower defence game places a tower, you could instantiate it, then call the UpdateGraphsNoBlock method to check if the newly placed tower will block the path. If it did then remove the tower immediately and notify the player that the choosen position was not valid. You can pass a list of nodes to the UpdateGraphsNoBlock method so you could for example make sure that not only is the path from the start to the goal not blocked, but also that all units can still reach the goal (if it is possible to place towers when enemies are walking around).</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var guo = new GraphUpdateObject(tower.GetComponent&lt;Collider&gt;().bounds);</span><br><span class="line">var spawnPointNode = AstarPath.active.GetNearest(spawnPoint.position).node;</span><br><span class="line">var goalNode = AstarPath.active.GetNearest(goalPoint.position).node;</span><br><span class="line"></span><br><span class="line">if (GraphUpdateUtilities.UpdateGraphsNoBlock(guo, spawnPointNode, goalNode, false)) &#123;</span><br><span class="line">    // Valid tower position</span><br><span class="line">    // Since the last parameter (which is called &quot;alwaysRevert&quot;) in the method call was false</span><br><span class="line">    // The graph is now updated and the game can just continue</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Invalid tower position. It blocks the path between the spawn point and the goal</span><br><span class="line">    // The effect on the graph has been reverted</span><br><span class="line">    Destroy(tower);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="保存和加载图表"><a href="#保存和加载图表" class="headerlink" title="保存和加载图表"></a>保存和加载图表</h1><p> 图的设置通过Unity的序列化来保存，但图没有通过序列化保存和加载，而是被保存至一个字节数组中，通过数组完成了保存和加载。</p>
<p>可以A* inspector面板中可以看到Save&amp;Load选项。</p>
<p>[需要一张图片]</p>
<h2 id="图的计算缓存"><a href="#图的计算缓存" class="headerlink" title="图的计算缓存"></a>图的计算缓存</h2><p>通常你希望游戏启动时重新计算图，但有的时候，尤其是使用RecastGraph或者在移动设备上开发，游戏开始时的延迟会非常烦。</p>
<p>打开Save&amp;Load面板，点击Generate Cache来创建缓存。它将会询问你是否保存之前重新扫描图。现在游戏启动时会加载缓存读取图的节点信息和其他参数，不需要另外的计算时间。</p>
<p>[需要一张图片]</p>
<h2 id="将图保存至文件并读取"><a href="#将图保存至文件并读取" class="headerlink" title="将图保存至文件并读取"></a>将图保存至文件并读取</h2><p>您可能还希望将图表保存到稍后可以加载的文件中。您甚至可以在运行时从服务器加载它。</p>
<p>如果想保存你的图，点击Save to file 按钮，你可以只保存配置参数或者保存配置参数和节点数据。如果只保存设置配置参数，则在图被加载后，你需要重新计算他在任何角色使用图进行导航之前。你可以使用以下代码重新计算所有的图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AstarPath.active.Scan();</span><br></pre></td></tr></table></figure>
<p>如果要再次加载图形，只需按“从文件加载”按钮并找到该文件。请注意，这将替换您当前的图表。</p>
<p>问题：只保存设置，还如何加载图形？？保存的设置是什么？？？</p>
<h2 id="使用代码进行保存和加载"><a href="#使用代码进行保存和加载" class="headerlink" title="使用代码进行保存和加载"></a>使用代码进行保存和加载</h2><p>如果需要实时加载或保存图，则需要在代码里进行操作。</p>
<p><code>SerializeGraphs()</code>方法会将图的参数序列化为数组，默认情况下包含节点信息（假设序列化之前保存过图形）。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = AstarPath.active.data.SerializeGraphs();</span><br></pre></td></tr></table></figure>
<p>可以近一步配置</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> settings = <span class="keyword">new</span> Pathfinding.Serialization.SerializeSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only save settings</span></span><br><span class="line">settings.nodes = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = AstarPath.active.data.SerializeGraphs(settings);</span><br></pre></td></tr></table></figure>
<p>加载保存的数据：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AstarPath.active.data.DeserializeGraphs(bytes);</span><br></pre></td></tr></table></figure>
<p>如果只加载了设置，你可能需要调用Scan方法在加载设置后：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">AstarPath.active.data.DeserializeGraphs(bytes);</span><br><span class="line">AstarPath.active.Scan();</span><br></pre></td></tr></table></figure>
<p>如果不是替换当前图，可以使用附加的方式加载图：</p>
<blockquote>
<p>Instead of replacing the currently loaded graphs, you can additively load graphs using</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AstarPath.active.data.DeserializeGraphsAdditive(bytes);</span><br></pre></td></tr></table></figure>
<p>使用以下方法卸载图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data = AstarPath.active.data;</span><br><span class="line">var myGraph = data.gridGraph;</span><br><span class="line">data.RemoveGraph(myGraph);</span><br></pre></td></tr></table></figure>
<h3 id="Including-Data-in-a-TextAsset"><a href="#Including-Data-in-a-TextAsset" class="headerlink" title="Including Data in a TextAsset"></a>Including Data in a TextAsset</h3><p>图表数据可以被包含在TextAsset中，当你将数据保存为文件，把文件重命名为入“myGraph.bytes”，然后将它放入你的Unity工程中，这样会告诉Unity将文件视作二进制文件。如果使用.txt的后缀会使出现问题，因为Unity会尝试用text读取文件。一些操作系统会隐藏扩展名，所以如果Unity无法识别.bytes请检查文件后缀是否真的是bytes。zip（或者其他）后缀名可能会被隐藏。<strong>然后，您可以通过在变量访问.bytes字段来加载text asse的图形，访问.bytes文件。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Graph data can be included in textassets for easier inclusion in the build. When you have saved the data to a file, rename that file to something like &quot;myGraph.bytes&quot; and place it in your Unity Project. This will tell Unity to handle it as binary information. With an extension like .txt the data would get corrupted because Unity would try to read it as text. Some operating systems like to hide the extension, so if Unity doesn&apos;t seem to recognize the file with the .bytes extension make sure it really has a .bytes extension, the .zip (or other) extension might just be hidden. Then you can load the graph from a text asset by referencing it in a variable, and accessing the .bytes field.</span><br></pre></td></tr></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>所有的参数设置都会被序列化为JSON，可以很好的保持向前或向后兼容。下面提到的所有文件都会被压缩进单独的zip文件，缩小尺寸，使数据更容易处理。这也意味着你可以打开zip文件进行手动处理。</p>
<p>【需要一章图片】</p>
<p><strong>meta</strong></p>
<p>meta.json文件会在所有的序列化中出现，A meta.json file is present in all serializations. This file contains information which is not connected to a specific graph, or is needed to load the other graphs.</p>
<ul>
<li>Version number for the system</li>
<li>Number of graphs which are saved</li>
<li>GUID values for each graph, to identify them</li>
<li>Type of each graph</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;3.0.9.5&quot;,</span><br><span class="line">    </span><br><span class="line">    &quot;graphs&quot;: 1,</span><br><span class="line">    </span><br><span class="line">    &quot;guids&quot;: </span><br><span class="line">        [</span><br><span class="line">            &quot;0d83c93fc4928934-8362a8662ec4fb9d&quot;</span><br><span class="line">        ],</span><br><span class="line">    </span><br><span class="line">    &quot;typeNames&quot;: </span><br><span class="line">        [</span><br><span class="line">            &quot;Pathfinding.GridGraph&quot;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Graph-Settings"><a href="#Graph-Settings" class="headerlink" title="Graph Settings"></a>Graph Settings</h3><p>每个图的配置参数会被保存为”graph#.json”，#代表图的编号。下面是一个grid图的参数序列化的例子（删除了一些参数以保持代码不会很长）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;aspectRatio&quot;:1,</span><br><span class="line">   &quot;rotation&quot;:&#123;</span><br><span class="line">      &quot;x&quot;:0,</span><br><span class="line">      &quot;y&quot;:0,</span><br><span class="line">      &quot;z&quot;:0</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;center&quot;:&#123;</span><br><span class="line">      &quot;x&quot;:0,</span><br><span class="line">      &quot;y&quot;:-0.1,</span><br><span class="line">      &quot;z&quot;:0</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;unclampedSize&quot;:&#123;</span><br><span class="line">      &quot;x&quot;:100,</span><br><span class="line">      &quot;y&quot;:100</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;nodeSize&quot;:1,</span><br><span class="line">   &quot;maxClimb&quot;:0.4,</span><br><span class="line">   &quot;maxClimbAxis&quot;:1,</span><br><span class="line">   &quot;maxSlope&quot;:90,</span><br><span class="line">   &quot;erodeIterations&quot;:0,</span><br><span class="line">   &quot;autoLinkGrids&quot;:false,</span><br><span class="line">   &quot;autoLinkDistLimit&quot;:10,</span><br><span class="line">   &quot;neighbours&quot;:&quot;Eight&quot;,</span><br><span class="line">   &quot;cutCorners&quot;:true,</span><br><span class="line">   &quot;penaltyPositionOffset&quot;:0,</span><br><span class="line">   &quot;penaltyPosition&quot;:false,</span><br><span class="line">   &quot;penaltyPositionFactor&quot;:1,</span><br><span class="line">   &quot;penaltyAngle&quot;:false,</span><br><span class="line">   &quot;penaltyAngleFactor&quot;:100,</span><br><span class="line">   &quot;open&quot;:true,</span><br><span class="line">   &quot;infoScreenOpen&quot;:false</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点信息使用json来保存会占用很多空间，所以被替代为使用二进制文件写入。每个图类型都有自己的序列化保存节点代码。这由每个图上的SerializeExtraInfo和DeserializeExtraInfo方法处理。</p>
<h1 id="多种Agent类型"><a href="#多种Agent类型" class="headerlink" title="多种Agent类型"></a>多种Agent类型</h1><p> 不同尺寸的Agent通常有不同的寻路结果，最简单的方法是创建多个图，每一个图对应一种Agent。如果拥有很多代理，您可能希望将它们分组为具有大量图形将增加内存使用量并且扫描将花费更长时间。</p>
<h1 id="编辑器寻路"><a href="#编辑器寻路" class="headerlink" title="编辑器寻路"></a>编辑器寻路</h1><h1 id="GraphUpdateScene-组件"><a href="#GraphUpdateScene-组件" class="headerlink" title="GraphUpdateScene 组件"></a>GraphUpdateScene 组件</h1><h1 id="Accessing-graph-data"><a href="#Accessing-graph-data" class="headerlink" title="Accessing graph data"></a>Accessing graph data</h1><h1 id="应用于回合制游戏"><a href="#应用于回合制游戏" class="headerlink" title="应用于回合制游戏"></a>应用于回合制游戏</h1><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1>]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity插件：AStarPathfinding寻路系统（上）</title>
    <url>/2019/12/11/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>本文为AStarPathfinding插件的进阶内容，如果需要简单的使用寻路功能可以看上和中。</p>
<p>AI漫游以及扩展系统暂时没有做介绍，感兴趣的可以去官网看。</p>
<a id="more"></a>
<p>本篇为AStarPathfinding寻路系统的上部分，主要介绍插件的组件以及工作原理，和一个简单的Demo。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>除阅读热身章节外，需要了解寻路的基础知识才能阅读以下内容：</p>
<ol>
<li>游戏寻路基本原理</li>
<li><a href="http://dongbeigtl.top/2019/01/02/寻路常用的图/">寻路常用的几种图介绍</a></li>
<li><a href="http://dongbeigtl.top/2018/12/27/导航网格等寻路工作原理/">Unity的寻路系统</a></li>
</ol>
<p>如果只是想了解该插件的基础功能，可以直接跳至热身章节阅读。</p>
<p>以下的讲解内容，一部分是翻译自文档，翻译的部分会给出原文参考。英语好的同学可以直接看官方文档，文档包括寻路常用的几种图的介绍和优劣对比，以及一套寻路系统的工作原理是怎样的，写的非常详细，<a href="https://www.arongranberg.com/astar/docs/beginner.html">官网地址</a></p>
<p>此外官方还有一个入门的<a href="https://youtu.be/5QT5Czfe0YE">视频</a>，需要梯子看。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>APathfinding是比较主流的Unity寻路插件，分付费（100刀）和免费版。支持五种图：Grid Graph，Navmesh Graph，Point Graph，Recast Graph（付费），Layered Grid Graph（付费）。同时支持自动生成Navmesh（付费），自带RVO避障系统（付费）。目前Unity寻路插件用的比较多的就是该插件，功能齐全，可调节估价公式等等等，总之是一款非常强大的插件。</p>
<h1 id="准备，简单的Demo"><a href="#准备，简单的Demo" class="headerlink" title="准备，简单的Demo"></a>准备，简单的Demo</h1><p>下面的Demo是一个简单的寻路，将准备好的插件包导入新建项目中然后完成下面的操作：</p>
<p><strong>（1）</strong>准备工作：场景中添加Plane（一块地板），障碍物。为Plane添加一个Layer（我的命名是Ground）。添加几个障碍物，为所有的障碍物添加Layer（Obs），注意障碍物要添加Box Collider组件*。新建一个空物体，并为空物体添加<strong>Astar Path</strong>组件。添加一个游戏人物命名为hero，一个球体命名为target用于表示hero要去的目标。场景内现在应该有：地板，障碍物，游戏人物，以及target，挂载了Astar Path的空物体。</p>
<p><strong>（2）</strong>生成导航网格<strong>：</strong>准备完成后，在Astar Path中添加<strong>Grid Graph</strong>，并设置网格图的长宽以足够覆盖整个Plane。将Collison Testing中的<strong>Obstacle Layer</strong> Mask设置为障碍物所在的图层（Obs）。将<strong>Height Tesing</strong>中的Mask设置为Plane所在的图层（Ground）。<br><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（上）/97475890.jpg" alt="img"></p>
<p>设置完成后点击Scan，效果如图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545907201.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545907201.png" alt="Image 0011545907201.png"></a></p>
<p>(3)让hero可以寻路：添加Seeker，Character Controler组件。新建一个名为MineAstarAI的脚本，并填入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using Pathfinding;</span><br><span class="line"></span><br><span class="line">public void Start () &#123;</span><br><span class="line">// Get the seeker component attached to this GameObject</span><br><span class="line">var seeker = GetComponent&lt;Seeker&gt;();</span><br><span class="line"></span><br><span class="line">// Start a new path request from the current position to a position 10 units forward.</span><br><span class="line">// When the path has been calculated, it will be returned to the function OnPathComplete unless it was canceled by another path request</span><br><span class="line">seeker.StartPath (transform.position, transform.position+transform.forward*10, OnPathComplete);</span><br><span class="line"></span><br><span class="line">// Note that the path is NOT calculated at this stage</span><br><span class="line">// It has just been queued for calculation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void OnPathComplete (Path p) &#123;</span><br><span class="line">// We got our path back</span><br><span class="line">if (p.error) &#123;</span><br><span class="line">// Nooo, a valid path couldn&apos;t be found</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// Yay, now we can get a Vector3 representation of the path</span><br><span class="line">// from p.vectorPath</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Target Position拖入Target。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545908704.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545908704.png" alt="Image 0011545908704.png"></a></p>
<p>（4）运行，Scene窗口会显示寻路的路径：<br><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545908795.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545908795.png" alt="Image 0011545908795.png"></a></p>
<p>若没显示路径（绿线），检查seeker脚本中的Draw Gizmos选项是否勾选。</p>
<hr>
<h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><p><strong>概览</strong></p>
<p>主要组件有这几种，它们负责运作整套寻路系统。</p>
<ol>
<li><strong>Astarpath.cs</strong>：插件的核心脚本，是寻路系统的核心，所有对寻路的调整都要修改该组件才能完成。</li>
<li><strong>Seeker.cs：</strong>：负责寻路调用，但不是必须。</li>
<li><strong>AIPath，RichAI，AILerp</strong>：AI移动脚本，可以用这三个完成寻路移动或自己写一个。</li>
<li><strong>修饰脚本 SimpleSmoothModifier等等</strong>：对已生成的路径进行修饰，平滑，简化路径。</li>
</ol>
<h2 id="1-Astarpath组件"><a href="#1-Astarpath组件" class="headerlink" title="1.Astarpath组件"></a>1.Astarpath组件</h2><p>Astarpath组件添加在object上以后会显示如下面板：<br><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545895426.png" alt="img"></p>
<p>组件面板</p>
<p><strong>Scan 按钮</strong>用于扫描更新图，在游戏启动时完成（除非缓存启动<strong>，更多关于另一部分的启动</strong>），并且一些图在有改动时会自动执行扫描，不会导致任何延迟。</p>
<blockquote>
<p>The Scan button is for updating the graphs, this is also done on startup (unless the startup is cached, more about that in another part) and some graphs will do it automatically when changing the graph settings and the scanning won’t cause any lag.</p>
</blockquote>
<p>比较重要的是Graphs，Settings。About是官网导航，版本检查问题反馈等等，就不做介绍了，重点介绍一下<strong>Graphs</strong>和Settings，Save和Optimization。</p>
<h3 id="Settings面板"><a href="#Settings面板" class="headerlink" title="Settings面板"></a>Settings面板</h3><p><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545898556.png" alt="img"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Thread Count[1]</td>
<td>寻路使用的线程数，None表示协程运行，Automatic自动根据配置调整线程。此功能为付费功能（WebGL 上无法使用此功能）</td>
</tr>
<tr>
<td>Max Nearest Node Distance</td>
<td>可搜索的临近点最大距离，如果请求不可到达点的路径，则会返回该点在该值范围内的最近节点。</td>
</tr>
<tr>
<td>Heuristic[2]</td>
<td>使用哪种估价公式</td>
</tr>
<tr>
<td>Heuristic Scale[3]</td>
<td>启发式规模</td>
</tr>
<tr>
<td>Advanced</td>
<td></td>
</tr>
<tr>
<td>Heuristic Optimization[4]</td>
<td>启发式优化（不知道怎么用）</td>
</tr>
<tr>
<td>Batch Graph Updates[5]</td>
<td>批处理更新图</td>
</tr>
<tr>
<td>Prioritize Graphs[5]</td>
<td>图的优先级</td>
</tr>
<tr>
<td>Full Get Nearest Node Search[6]</td>
<td>对所有图执行完整GetNearest搜索</td>
</tr>
<tr>
<td>Scan on Awake</td>
<td>在执行Awake时生成图</td>
</tr>
<tr>
<td>Path Logging</td>
<td>Log产生的消息数量（None/Normal/Heavy/InGame（和Heavy一样多，但在游戏中使用UI输出log）/OnlyErrors）</td>
</tr>
<tr>
<td>Graph Coloring</td>
<td>根据不同的属性对图进行可视化（G/H/F/Penalty/Areas）</td>
</tr>
<tr>
<td>Show Search Tree</td>
<td>如果勾选将会将节点的父节点可视化。（此功能目前还不完整）</td>
</tr>
<tr>
<td>Show Unwalkable Nodes</td>
<td>显示不可走的节点</td>
</tr>
<tr>
<td>Smooth Transitions[7]</td>
<td>在打开和关闭时动画下拉菜单</td>
</tr>
</tbody>
</table>
<p>[1]Thread Count：推荐使用Automatic，因为不同用户间配置的不同，会导致性能的浪费或导致游戏无法以正常帧数运行。Automatic会检查当前机器的配置来确定线程数，稳定运行。另外需要的注意，如果场景中只有一个（或很少）需要寻路的角色（代理），应该只使用一个线程。因为多线程计算路径适用于计算不同路径以提升吞吐量，<strong>但是多线程并不会使单个路径的计算速度变快。</strong></p>
<p>[2]不同的估价公式：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546845961.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546845961.png" alt="Image 0011546845961.png"></a></p>
<p>估价公式的作用请看寻路原理文档以及网上查阅资料。</p>
<p>[3]Heuristic Scale：如果使用小于1的值，则寻路处理时会搜索更多节点（更慢）。 如果使用0，则路径查找算法将简化为dijkstra算法。 相当于将Heuristic选项设置为None。 如果使用大于1的值，则路径查找通常会更快，但因为搜索了更少的节点，所以路径可能不再是最佳路径（即最短路径）。</p>
<p>[4]Heuristic Optimization：</p>
<p>[5]Batch Graph Updates：图形更新将批处理并执行较少（由graphUpdateBatchingInterval指定更新）。</p>
<p>[6]Prioritize Graphs：图表将根据他们在检查员中的顺序进行优先排序。 将选择具有比优先级图限制更近的节点的第一个图，而不是搜索所有图。</p>
<p>[7]Smooth Transitions：</p>
<h3 id="SaveAndLoad面板"><a href="#SaveAndLoad面板" class="headerlink" title="SaveAndLoad面板"></a>SaveAndLoad面板</h3><p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545903520.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545903520.png" alt="Image 0011545903520.png"></a></p>
<p>此面板用于读取和保存图的信息。通过读取缓存数据避免在游戏中进行大量的图生成计算。</p>
<h3 id="Optimization面板"><a href="#Optimization面板" class="headerlink" title="Optimization面板"></a>Optimization面板</h3><p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545903671.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545903671.png" alt="Image 0011545903671.png"></a></p>
<p>禁用或使用面板中的某些功能来提升性能。</p>
<hr>
<h2 id="2-图"><a href="#2-图" class="headerlink" title="2.图"></a>2.图</h2><p>点击Graphs后会提示选择其中一种图来进行下一步的操作，这里拿Grid来做讲解，这几种图是干吗的在前言的文章有介绍。</p>
<p><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545896172.png" alt="img"></p>
<p>组件面板</p>
<p><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545896182.png" alt="img"></p>
<p>点击i按钮进行编辑</p>
<p>下面是这五种图的属性介绍。</p>
<p>[su_accordion][su_spoiler title=”Grid和Layered Grid Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””]</p>
<p>Grid和Layered Grid差别不大，合在一起说</p>
<p>Layered Grid是插件的付费功能，和Grid图的区别是它支持重叠区域的网格图。它在某些方面有点受限，它只支持4个邻居而不是8，并且比网格图使用更多的内存。但是当你需要一个重叠区域的网格图时它很有用。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shape[1]</td>
<td>生成图的形状</td>
</tr>
<tr>
<td>2D</td>
<td>勾选后将适用于2D</td>
</tr>
<tr>
<td>Width</td>
<td>调整生成的图宽度</td>
</tr>
<tr>
<td>Depth</td>
<td>调整生成的图长度</td>
</tr>
<tr>
<td>Node size</td>
<td>节点大小</td>
</tr>
<tr>
<td>Center</td>
<td>确定中心点</td>
</tr>
<tr>
<td>Rotation</td>
<td>图的角度</td>
</tr>
<tr>
<td>——————————</td>
<td></td>
</tr>
<tr>
<td>Connections</td>
<td>存储的邻接点数量4/8</td>
</tr>
<tr>
<td>Cut Corners[2]</td>
<td>是否剪切边角</td>
</tr>
<tr>
<td>Max Climb</td>
<td>最大攀爬高度</td>
</tr>
<tr>
<td>Max Slope</td>
<td>最大攀爬角度</td>
</tr>
<tr>
<td>Erosion iterations[3]</td>
<td>侵蚀范围</td>
</tr>
<tr>
<td>——————————</td>
<td></td>
</tr>
<tr>
<td>Use 2D physics</td>
<td>使用2D物理系统检测碰撞</td>
</tr>
<tr>
<td>Colloder type</td>
<td>碰撞体类型</td>
</tr>
<tr>
<td>Dimaeter</td>
<td></td>
</tr>
<tr>
<td>Height/Length</td>
<td></td>
</tr>
<tr>
<td>Offset</td>
<td></td>
</tr>
<tr>
<td>Obstacle Layer Mask</td>
<td>障碍物所在图层</td>
</tr>
<tr>
<td>——————————</td>
<td></td>
</tr>
<tr>
<td>Ray length[4]</td>
<td>检测射线高度</td>
</tr>
<tr>
<td>Mask</td>
<td>地板所在图层</td>
</tr>
<tr>
<td>Thick Raycast[5]</td>
<td></td>
</tr>
<tr>
<td>Advanced</td>
<td></td>
</tr>
<tr>
<td>Unwalkable when no ground</td>
<td></td>
</tr>
<tr>
<td>Use Jump point Search[6]</td>
<td>使用跳跃点搜索</td>
</tr>
</tbody>
</table>
<p><strong>[1]Shape:</strong>Grid Graph有很多种，如网格图等等</p>
<p><strong>[2]Cut Corners:</strong></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/cutCorners.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/cutCorners.png" alt="cutCorners.png"></a></p>
<p><strong>[3]Erosion iterations：</strong></p>
<p>通过调整Erosion iterations实现侵蚀的效果，根据值的不同侵蚀的程度也不同：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/erosion.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/erosion.png" alt="erosion.png"></a></p>
<p>分别为值是0，1，2时的效果</p>
<p>过多的侵蚀迭代次数会降低运行时（Graph UpdateObject）中的图形更新速度。</p>
<p><strong>[4]Ray length：</strong></p>
<p><strong>[5]Thick Raycast：</strong></p>
<p><strong>[6]Use Jump point Search：</strong></p>
<p>[/su_spoiler] [/su_accordion]</p>
<p>[su_accordion][su_spoiler title=”Navmesh Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””]</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545905039.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545905039.png" alt="Image 0011545905039.png"></a></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source Mesh</td>
<td>生成的navmesh资源</td>
</tr>
<tr>
<td>Offset</td>
<td>偏移量</td>
</tr>
<tr>
<td>Rotation</td>
<td>旋转角度</td>
</tr>
<tr>
<td>Scale</td>
<td>缩放</td>
</tr>
<tr>
<td>Nearest Node queries in XZ space[1]</td>
<td>仅在XZ空间中执行最近的节点搜索。</td>
</tr>
<tr>
<td>Recalulate Normals[2]</td>
<td>确定如何计算法线</td>
</tr>
<tr>
<td>Initial Penalty[3]</td>
<td>节点默认代价</td>
</tr>
</tbody>
</table>
<p><strong>[1]Nearest Node queries in XZ space</strong></p>
<p><strong>[2]Recalulate Normals</strong></p>
<p><strong>[3]Initial Penalty</strong></p>
<p>[/su_spoiler] [/su_accordion]</p>
<p>[su_accordion][su_spoiler title=”Point Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””]</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545905044.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545905044.png" alt="Image 0011545905044.png"></a></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Root</td>
<td>指定的根节点</td>
</tr>
<tr>
<td>Recursive</td>
<td>是否遍历根节点下的全部节点</td>
</tr>
<tr>
<td>Tag</td>
<td>指定路点的Tag</td>
</tr>
<tr>
<td>Max Distance</td>
<td>两路点最大距离，0无限大</td>
</tr>
<tr>
<td>Max Distance()[1]</td>
<td>两路点最大距离，分轴计算</td>
</tr>
<tr>
<td>Raycast</td>
<td>使用raycast来检查连接</td>
</tr>
<tr>
<td>Use 2D Physics</td>
<td>使用2D物理系统</td>
</tr>
<tr>
<td>Thick Raycast</td>
<td></td>
</tr>
<tr>
<td>Mask</td>
<td>用于射线检测的图层</td>
</tr>
<tr>
<td>Optimize For Sparse Graph[2]</td>
<td>优化稀疏图</td>
</tr>
<tr>
<td>Initial Penty</td>
<td>默认惩罚值</td>
</tr>
</tbody>
</table>
<p>[1]Max Distance()：与Max Distance不同，该属性可以分不同的方向来控制最大距离。</p>
<p>[2]Optimize For Sparse Graph：</p>
<p>[/su_spoiler] [/su_accordion]</p>
<p>[su_accordion][su_spoiler title=”Recast Graph” open=”no” style=”default” icon=”plus” anchor=”” class=””]</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545905050.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545905050.png" alt="Image 0011545905050.png"></a></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cell Size</td>
<td>多边形大小</td>
</tr>
<tr>
<td>Use Tiles</td>
<td>是否使用Tiles</td>
</tr>
<tr>
<td>Tile Size</td>
<td>Tile大小</td>
</tr>
<tr>
<td>Min Region Size</td>
<td>最小区域大小</td>
</tr>
<tr>
<td>Walkable Height</td>
<td>可行走高度</td>
</tr>
<tr>
<td>Walkable Climb</td>
<td>可攀爬高度</td>
</tr>
<tr>
<td>Character Radius</td>
<td>角色半径</td>
</tr>
<tr>
<td>Max Slope</td>
<td>最大攀爬角度</td>
</tr>
<tr>
<td>Max Border Edge Lenght[1]</td>
<td>最大细分边缘长度</td>
</tr>
<tr>
<td>Max Edge Error</td>
<td></td>
</tr>
<tr>
<td>Rasterize Terrain</td>
<td></td>
</tr>
<tr>
<td>Rasteruze Tress</td>
<td></td>
</tr>
<tr>
<td>Collider Deta</td>
<td></td>
</tr>
<tr>
<td>Terrain Sample</td>
<td></td>
</tr>
<tr>
<td>Rasterize meshes</td>
<td></td>
</tr>
<tr>
<td>Rasterize Collider</td>
<td></td>
</tr>
<tr>
<td>Center</td>
<td>中心点位置</td>
</tr>
<tr>
<td>Size</td>
<td>尺寸大小</td>
</tr>
<tr>
<td>Rotation</td>
<td>角度</td>
</tr>
<tr>
<td>LayerMask</td>
<td></td>
</tr>
<tr>
<td>TagMask</td>
<td></td>
</tr>
<tr>
<td>Relevant Graph s</td>
<td></td>
</tr>
<tr>
<td>Nearest node</td>
<td></td>
</tr>
<tr>
<td>Initial Penalty</td>
</tr>
</tbody>
</table>
<p>[/su_spoiler] [/su_accordion]</p>
<hr>
<h2 id="3-Seeker组件"><a href="#3-Seeker组件" class="headerlink" title="3.Seeker组件"></a>3.Seeker组件</h2><p>Seeker附加在请求寻路的GameObject上，通过调用Seeker.StartPath（）来请求寻路。同时Seeker还可以使用Modifiers组件使路径变得更加圆滑<strong>，</strong>简单。（需要注意的是Seeker会自动调用Modifiers）</p>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Start () &#123;</span><br><span class="line">// Get a reference to the Seeker component we added earlier</span><br><span class="line">Seeker seeker = GetComponent&lt;Seeker&gt;();</span><br><span class="line"></span><br><span class="line">// Start to calculate a new path to the targetPosition object, return the result to the OnPathComplete method.</span><br><span class="line">// Path requests are asynchronous, so when the OnPathComplete method is called depends on how long it</span><br><span class="line">// takes to calculate the path. Usually it is called the next frame.</span><br><span class="line">seeker.StartPath(transform.position, targetPosition.position, OnPathComplete);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void OnPathComplete (Path p) &#123;</span><br><span class="line">Debug.Log(&quot;Yay, we got a path back. Did it have an error? &quot; + p.error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以不填写回调参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Set the path callback, this should be done once</span><br><span class="line">seeker.pathCallback += OnPathComplete;</span><br><span class="line"></span><br><span class="line">// Now we can skip the callback function parameter</span><br><span class="line">seeker.StartPath (transform.position, transform.position+transform.forward*10);</span><br></pre></td></tr></table></figure>
<p>注意第三个参数是委托，记得销毁时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void OnDisable () &#123;</span><br><span class="line">seeker.pathCallback -= OnPathComplete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Seeker组件旨在处理游戏中单个角色的寻路请求。所以，它一次只处理一个路径请求，如果正在计算路径时再次调用StartPath，它会记录一条日志，指出先前的路径计算已中止。</p>
<p><strong>注意Seeker一次只能进行一次寻路调用，如果在前一个路径完成之前请求新路径，则前一个路径请求将被取消。</strong>并且StartPath调用之后<strong>并不</strong>会立即计算路径。StartPath调用仅目标点放入队列中。这样做是因为当许多单位同时请求计算路径时，可以在几帧上展开寻路计算以避免FPS下降。如果已启用多线程，还可以在其他线程计算路径。如果需要立即计算路径。可以使用Pathfinding.Path.BlockUntilCalculated方法。</p>
<p>原文：</p>
<blockquote>
<p>A common mistake is to assume that the path is already calculated right after the StartPath call. This is however incorrect. The StartPath call will only put the path in a queue. This is done because when many units are calculating their paths at the same time, it is desriable to spread out the path calculations over several frames to avoid FPS drops. We can also calculate the paths in other threads if <a href="https://www.arongranberg.com/astar/docs/astarpath.html#threadCount">multithreading</a> has been enabled. There are of course cases where you need to calculate the path immediately. Then you can use the <a href="https://www.arongranberg.com/astar/docs/path.html#BlockUntilCalculated">Pathfinding.Path.BlockUntilCalculated</a>method.</p>
</blockquote>
<p>Seeker并不是必须要挂载的，但是用它寻路会更简单。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546850497.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546850497.png" alt="Image 0011546850497.png"></a></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Draw Gizmos</td>
<td>显示寻路路线</td>
</tr>
<tr>
<td>Detailed Gizmos</td>
<td>显示被简化，平滑前的路径</td>
</tr>
<tr>
<td>Start End Modifier[1]</td>
<td>用于调整路径的起点和终点位置。</td>
</tr>
<tr>
<td>Start Point Snapping</td>
<td>起点的位置</td>
</tr>
<tr>
<td>End Point Snapping</td>
<td>终点的位置</td>
</tr>
<tr>
<td>Add Points</td>
<td>添加</td>
</tr>
<tr>
<td>Traversable Graphs</td>
</tr>
</tbody>
</table>
<p>[1]Start End Modifier:</p>
<h2 id="4-AIPath，RichAI，AILerp组件"><a href="#4-AIPath，RichAI，AILerp组件" class="headerlink" title="4.AIPath，RichAI，AILerp组件"></a>4.AIPath，RichAI，AILerp组件</h2><p>插件提供了三个用于寻路移动脚本AIPath，RichAI，AILerp，这三个插件是可选的，可以不使用这些插件，用自己写的完成路径查找、移动功能。但这三个脚本功能齐全，拿来直接用也是没有问题的。要注意的是它们适用的场景各不相同，下面是官方的简介。</p>
<p><strong>AIPath：</strong></p>
<ul>
<li>适用于所有图的全能移动脚本。</li>
<li>可以响应物理系统，并可以生成圆滑的路径。</li>
<li>支持本地躲避系统。</li>
<li>支持3D，2D。</li>
</ul>
<p><strong>RichAI：</strong></p>
<ul>
<li>专为navmesh / recast图设计，不适用于任何其他图类型。</li>
<li>在navmesh下寻路能力比AIPath好，<strong>更好的处理路径，并且路径更加圆滑。</strong></li>
<li>更好的支持off-mesh，与AIPath相比。</li>
<li>支持本地躲避系统。</li>
<li>支持3D（XZ平面中的移动），但不支持2D。</li>
</ul>
<p>注意<strong>RichAi不支持大部分的modifiers，除</strong> funnel modifier外。</p>
<blockquote>
<p>The RichAI script is specially written for movement on navmesh graphs. It enforces that the agent stays on the navmesh at all times. As opposed to other movement scripts in this project, it does not have support for path modifiers. This is because it does not follow a list of waypoints, instead it follows a list of nodes. This has the advantage that the character can be pushed around by some amount and it will still move correctly without a path recalculation.</p>
</blockquote>
<p>（richiai不按照路点查询，在哪写了其他脚本按照路点查询） 这样的好处是什么关于RichAi的设置那段没看懂</p>
<p><strong>AILerp：</strong></p>
<ul>
<li>线性插值的沿路径移动，不支持物理系统。</li>
<li>完全遵循路径，无任何偏差。</li>
<li>由于以上两点，AILerp完全不支持本地躲避系统。</li>
<li>到目前为止最快的移动脚本，因为移动本身更简单。如果在游戏中需要物理模拟，应当使用其他脚本。</li>
<li>支持3D，2D游戏中的移动。</li>
</ul>
<p>[su_accordion][su_spoiler title=”原文” open=”no” style=”default” icon=”plus” anchor=”” class=””]</p>
<blockquote>
<p><strong>AIPath</strong></p>
<ul>
<li>Good all-around movement script which works on all graph types.</li>
<li>Follows paths smoothly and responds to physics.</li>
<li>Works well with local avoidance.</li>
<li>Supports movement in 3D games as well as 2D games.</li>
</ul>
<p><strong>RichAI</strong></p>
<ul>
<li>Designed specifically for navmesh/recast graphs and does not work with any other graph types.</li>
<li>Better than the AIPath script at following paths on navmesh based graphs, it can handle getting pushed of its path better and usually follows the path more smoothly.</li>
<li>Has better support for off-mesh compared to AIPath.</li>
<li>Works well with local avoidance.</li>
<li>Supports movement in 3D games (movement in the XZ plane), but not 2D.</li>
</ul>
<p><strong>AILerp</strong></p>
<ul>
<li>Uses linear interpolation to move along the path (which is why ‘lerp’, which stands for linear interpolation, is in the name), does not use physics in any way.</li>
<li>Follows the path exactly, without any deviations whatsoever.</li>
<li>Due to the above points it does not make sense to use it with local avoidance, and thus it does not support it.</li>
<li>By far the fastest of the movement scripts, because the movement in itself is much simpler, but keep in mind that if you need any kind of physical realism in the game, you should usually use one of the other movement scripts.</li>
<li>Supports movement in 3D games as well as 2D games.</li>
</ul>
</blockquote>
<p>[/su_spoiler] [/su_accordion]</p>
<p>总之，如果使用的是navmesh：使用RichAI脚本，否则使用AIPath或AILerp，具体取决于游戏所需的移动方式，具体在游戏中的表现看下面的演示章节。</p>
<p>脚本中会用到的一些属性：</p>
<ul>
<li>destination：需要移动到的目标点。</li>
<li>reachedDestination：如果已到达目标的，则值为ture</li>
<li>Velocity：代理的速度</li>
<li>desiredVelocity：代理期望的移动速度*。</li>
</ul>
<p>原文：</p>
<blockquote>
<ul>
<li>destination: Position in the world that this agent should move to.</li>
<li>reachedDestination: True if the ai has reached the #destination.</li>
<li>velocity: Actual velocity that the agent is moving with.</li>
<li>desiredVelocity: Velocity that this agent wants to move with.</li>
</ul>
</blockquote>
<h2 id="5-Modifiers组件"><a href="#5-Modifiers组件" class="headerlink" title="5.Modifiers组件"></a>5.Modifiers组件</h2><p>Modifiers是一些小组件，如SimpleSmoothModifier，RaycastModifier，FunnelModifier，和Seeker挂在同一个GameObject上。在Seeker返回路径给调用者之前，对路径<strong>自动（</strong>需手动修改或调用<strong>）</strong>进行圆滑或简化处理。</p>
<p>例如，下图中，Raycast Modifier删除了路径中不必要的节点，使路径更短。SimpleSmoothModifier使路径更圆滑，看起来更自然。</p>
<p>下面是几种最常见的Modifier的比较：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/modifier_comparison_grid.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/modifier_comparison_grid.png" alt="modifier_comparison_grid.png"></a></p>
<p>关于这些Modifier的具体功能，看下面章节。</p>
<p>需要注意，Modifiers通常不考虑世界几何图形或图形，因此小心使用太多平滑，可能会导致路径穿过不可行走的区域。圆滑路径一定要注意将参数调大，不然会卡死，如图：<br><img src="/2019/12/11/Unity插件：AStarPathfinding寻路系统/Unity插件：AStarPathfinding寻路系统（上）/84506670.jpg" alt="img"></p>
<p><strong>只有Seeker可以调用Modifieer吗</strong></p>
<hr>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="使用Modifiers组件"><a href="#使用Modifiers组件" class="headerlink" title="使用Modifiers组件"></a>使用Modifiers组件</h2><p>Modifiers组件一共有以下几种：</p>
<ol>
<li>SimpleSmoothModifier</li>
<li>RaycastModifier</li>
<li>FunnelModifier</li>
<li>RadiusModifier</li>
<li>StartEndModifier</li>
<li>AlternativePath</li>
</ol>
<p>重点介绍一下SimpleSmoothModifier，FunnelModifier，Raycast Modifier。</p>
<h3 id="SimpleSmoothModifier"><a href="#SimpleSmoothModifier" class="headerlink" title="SimpleSmoothModifier"></a>SimpleSmoothModifier</h3><p>SimpleSmooth的功能是平滑路径，可以通过细分路径并使定点靠近彼此来实现平滑（Simple模式），也可以使用贝塞尔曲线（Bezier 模式）来实现。下图是开启SimpleSmooth前后的对比。注意，因为在平滑时不考虑几何世界，所以<strong>平滑路径会稍微削减拐点</strong>。</p>
<blockquote>
<p>The simple smooth modifier is a modifier to smooth the path. It can do that either by just subdividing it and moving the vertices closer to each other or use splines, namely the Bezier curve.<br>Below are two images showing a path with the smooth modifier turned off first and then on. Note that the smoothed path cuts the corners a bit, this can be a problem with the smooth modifier since it does not take world geometry into account when smoothing.</p>
</blockquote>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/smoothModifier_off.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/smoothModifier_off.png" alt="smoothModifier_off.png"></a></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/smoothModifier_on.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/smoothModifier_on.png" alt="smoothModifier_on.png"></a></p>
<p>SimpleSmooth的类型有如下几种：</p>
<h4 id="1-SimpleSmooth"><a href="#1-SimpleSmooth" class="headerlink" title="1.SimpleSmooth"></a>1.SimpleSmooth</h4><p>通过细分路径，使顶点互相靠近实现平滑。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545992300.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545992300.png" alt="Image 0011545992300.png"></a></p>
<table>
<thead>
<tr>
<th>Uniform Length</th>
<th>是否将所有线划分为相等长度的线段。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Max Segment Length</td>
<td>分割线段最大长度</td>
</tr>
<tr>
<td>Iterations</td>
<td>平滑处理迭代次数</td>
</tr>
<tr>
<td>Strength</td>
<td>每次平滑处理的强度，0.5最佳</td>
</tr>
</tbody>
</table>
<p>Uniform Length会将路径裁剪成每段相等线段，线段的最大长度取决于Max Segment Length，Max Segment Length越大路径越简单，同时也容易<strong>穿过不可走区域。</strong>我描述的可能不太清晰<strong>，</strong>看下面的例子或者自己尝试调节下参数很容易明白这两个属性的意义。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545993237.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545993237.png" alt="Image 0011545993237.png"></a></p>
<p>未开启SimpleSmooth</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545993249.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545993249.png" alt="Image 0011545993249.png"></a></p>
<p>开启SimpleSmooth，但Uniform Length未开启。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545993261.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545993261.png" alt="Image 0011545993261.png"></a></p>
<p>开启Uniform Length</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545994656.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545994656.png" alt="Image 0011545994656.png"></a></p>
<p>Max Segment Length = 20</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545994680.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545994680.png" alt="Image 0011545994680.png"></a></p>
<p>Max Segment Length = 100</p>
<h4 id="2-Bezier"><a href="#2-Bezier" class="headerlink" title="2.Bezier"></a>2.Bezier</h4><p>通过贝塞尔曲线实现平滑，注意贝塞尔曲线处理过的路径总会通过所有的顶点（看下面的图就明白什么意思了），所以注意不要拐弯拐的太过。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545992326.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545992326.png" alt="Image 0011545992326.png"></a></p>
<table>
<thead>
<tr>
<th>Subdvisions</th>
<th>细分次数，设置为0时和未处理没什么区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bezier Tangent Length</td>
<td>贝塞尔曲线“切线”的长度系数。</td>
</tr>
</tbody>
</table>
<p>Bezier Tangent Length值要注意，如图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545996463.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545996463.png" alt="Image 0011545996463.png"></a></p>
<p>Bezier Tangent Length = 0</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545996473.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545996473.png" alt="Image 0011545996473.png"></a></p>
<p>Bezier Tangent Length = 0.5</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545996558.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545996558.png" alt="Image 0011545996558.png"></a></p>
<p>Bezier Tangent Length =3（挺好看的）</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545996502.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545996502.png" alt="Image 0011545996502.png"></a></p>
<p>Bezier Tangent Length =10，曲线的曲率已经大的看不到了。</p>
<p>关于贝塞尔曲线，自行查阅资料。</p>
<h4 id="3-OffSet"><a href="#3-OffSet" class="headerlink" title="3.OffSet"></a>3.OffSet</h4><p>通过向外偏移路径，减少拐点角度来实现平滑，注意offset的值过大会非常乱。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545992330.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545992330.png" alt="Image 0011545992330.png"></a></p>
<table>
<thead>
<tr>
<th>Iterations</th>
<th>平滑处理迭代次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>offset</td>
<td>偏移量</td>
</tr>
</tbody>
</table>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545999588.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545999588.png" alt="Image 0011545999588.png"></a></p>
<p>offset = 2，可以看到该模式下致力于减少拐角处的角度实现平滑。</p>
<h4 id="4-Curved-Non-Uniform"><a href="#4-Curved-Non-Uniform" class="headerlink" title="4.Curved Non Uniform"></a>4.Curved Non Uniform</h4><p>这个没什么好说的，平滑处理时曲线曲率是不相等的。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011545992334.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011545992334.png" alt="Image 0011545992334.png"></a></p>
<p>Factor：弧度系数</p>
<h3 id="FunnelModifier"><a href="#FunnelModifier" class="headerlink" title="FunnelModifier"></a>FunnelModifier</h3><p>FunnelModifier使用漏斗算法，快速准确的对路径进行简化。但在Grid的中优化的效果可能不尽人意，因为它只简化了路径队列中节点内的路径。在RaycastModifier中效果会好一些。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546001697.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546001697.png" alt="Image 0011546001697.png"></a></p>
<p>Unwrap：开启后将在XY以及更复杂的空间支持简化路径。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/funnel_unwrap_illustration.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/funnel_unwrap_illustration.png" alt="funnel_unwrap_illustration.png"></a></p>
<h5 id="splitAtEveryPortal：每当通过一个节点就插入一个节点。"><a href="#splitAtEveryPortal：每当通过一个节点就插入一个节点。" class="headerlink" title="splitAtEveryPortal：每当通过一个节点就插入一个节点。"></a>splitAtEveryPortal：每当通过一个节点就插入一个节点。</h5><p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/funnel_split_at_every_portal.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/funnel_split_at_every_portal.png" alt="funnel_split_at_every_portal.png"></a></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011550462938.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011550462938.png" alt="Image 0011550462938.png"></a></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011550462920.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011550462920.png" alt="Image 0011550462920.png"></a></p>
<p>Grid图中简化效果</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011550461435.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011550461435.png" alt="Image 0011550461435.png"></a></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011550461454.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011550461454.png" alt="Image 0011550461454.png"></a></p>
<p>NavMesh下简化效果</p>
<p>官方文档：<a href="https://www.arongranberg.com/astar/docs/funnelmodifier.html">https://www.arongranberg.com/astar/docs/funnelmodifier.html</a></p>
<h3 id="Raycast-Modifier"><a href="#Raycast-Modifier" class="headerlink" title="Raycast Modifier"></a>Raycast Modifier</h3><p>Raycast Modifier将尝试使用光线检测（linecasting）从路径中删除尽可能多的节点。可以使用图的内置光线检测，也可以用Unity的Physics.Raycast完成光线检测。该组件主要应用于grid graphs 和 layered grid graphs。point graphs也可以使用Raycast Modifier，但point graphs并没有内置的光线检测系统，所以需要使用Unity的Physics.Raycast实现光线检测。</p>
<p>navmesh/recast图最好使用FunnelModifier。</p>
<p>在grid图中，Raycast Modifier和FunnelModifier可以同时使用。但混合使用可能不会简化出最优的路径，甚至可能带来不好的结果。当两者都被使用时，通常路径会紧密的贴在图的边界，而错失了简化路径的机会，并且混合使用时FunnelModifier会先运行简化路径，然后将简化结果传给Raycast Modifier进一步优化。</p>
<p>Raycast Modifier简化路径有几个级别，最高质量的计算速度明显慢于最低质量（大约十倍），下面是不同级别的区别：</p>
<ol>
<li>Low：使用一次贪心算法</li>
<li>Medium：使用贪心算法迭代两次</li>
<li>High：使用动态规划迭代一次</li>
<li>Highest：使用动态规划迭代三次</li>
</ol>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/raycast_modifier_quality.gif"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/raycast_modifier_quality.gif" alt="raycast_modifier_quality.gif"></a></p>
<h2 id="手动编写寻路"><a href="#手动编写寻路" class="headerlink" title="手动编写寻路"></a>手动编写寻路</h2><p>虽然可以使用插件自带的组件来完成寻路移动，但是手写可以理解插件的工作原理。</p>
<p>上面的热身已经写过一个简单的寻路调用了，下面把它强化一下：<strong>（备注没写）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">// Note this line, if it is left out, the script won&apos;t know that the class &apos;Path&apos; exists and it will throw compiler errors</span><br><span class="line">// This line should always be present at the top of scripts which use pathfinding</span><br><span class="line">using Pathfinding;</span><br><span class="line"></span><br><span class="line">public class AstarAI : MonoBehaviour &#123;</span><br><span class="line">public Transform targetPosition;</span><br><span class="line"></span><br><span class="line">private Seeker seeker;</span><br><span class="line">private CharacterController controller;</span><br><span class="line"></span><br><span class="line">public Path path;</span><br><span class="line"></span><br><span class="line">public float speed = 2;</span><br><span class="line"></span><br><span class="line">public float nextWaypointDistance = 3;</span><br><span class="line"></span><br><span class="line">private int currentWaypoint = 0;</span><br><span class="line"></span><br><span class="line">public bool reachedEndOfPath;</span><br><span class="line"></span><br><span class="line">public void Start () &#123;</span><br><span class="line">seeker = GetComponent&lt;Seeker&gt;();</span><br><span class="line">// If you are writing a 2D game you can remove this line</span><br><span class="line">// and use the alternative way to move sugggested further below.</span><br><span class="line">controller = GetComponent&lt;CharacterController&gt;();</span><br><span class="line"></span><br><span class="line">// Start a new path to the targetPosition, call the the OnPathComplete function</span><br><span class="line">// when the path has been calculated (which may take a few frames depending on the complexity)</span><br><span class="line">seeker.StartPath(transform.position, targetPosition.position, OnPathComplete);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void OnPathComplete (Path p) &#123;</span><br><span class="line">Debug.Log(&quot;A path was calculated. Did it fail with an error? &quot; + p.error);</span><br><span class="line"></span><br><span class="line">if (!p.error) &#123;</span><br><span class="line">path = p;</span><br><span class="line">// Reset the waypoint counter so that we start to move towards the first point in the path</span><br><span class="line">currentWaypoint = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Update () &#123;</span><br><span class="line">if (path == null) &#123;</span><br><span class="line">// We have no path to follow yet, so don&apos;t do anything</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check in a loop if we are close enough to the current waypoint to switch to the next one.</span><br><span class="line">// We do this in a loop because many waypoints might be close to each other and we may reach</span><br><span class="line">// several of them in the same frame.</span><br><span class="line">reachedEndOfPath = false;</span><br><span class="line">// The distance to the next waypoint in the path</span><br><span class="line">float distanceToWaypoint;</span><br><span class="line">while (true) &#123;</span><br><span class="line">// If you want maximum performance you can check the squared distance instead to get rid of a</span><br><span class="line">// square root calculation. But that is outside the scope of this tutorial.</span><br><span class="line">distanceToWaypoint = Vector3.Distance(transform.position, path.vectorPath[currentWaypoint]);</span><br><span class="line">if (distanceToWaypoint &lt; nextWaypointDistance) &#123;</span><br><span class="line">// Check if there is another waypoint or if we have reached the end of the path</span><br><span class="line">if (currentWaypoint + 1 &lt; path.vectorPath.Count) &#123;</span><br><span class="line">currentWaypoint++;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// Set a status variable to indicate that the agent has reached the end of the path.</span><br><span class="line">// You can use this to trigger some special code if your game requires that.</span><br><span class="line">reachedEndOfPath = true;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Slow down smoothly upon approaching the end of the path</span><br><span class="line">// This value will smoothly go from 1 to 0 as the agent approaches the last waypoint in the path.</span><br><span class="line">var speedFactor = reachedEndOfPath ? Mathf.Sqrt(distanceToWaypoint/nextWaypointDistance) : 1f;</span><br><span class="line"></span><br><span class="line">// Direction to the next waypoint</span><br><span class="line">// Normalize it so that it has a length of 1 world unit</span><br><span class="line">Vector3 dir = (path.vectorPath[currentWaypoint] - transform.position).normalized;</span><br><span class="line">// Multiply the direction by our desired speed to get a velocity</span><br><span class="line">Vector3 velocity = dir * speed * speedFactor;</span><br><span class="line"></span><br><span class="line">// Move the agent using the CharacterController component</span><br><span class="line">// Note that SimpleMove takes a velocity in meters/second, so we should not multiply by Time.deltaTime</span><br><span class="line">controller.SimpleMove(velocity);</span><br><span class="line"></span><br><span class="line">// If you are writing a 2D game you may want to remove the CharacterController and instead use e.g transform.Translate</span><br><span class="line">// transform.position += velocity * Time.deltaTime;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用节点"><a href="#使用节点" class="headerlink" title="使用节点"></a>使用节点</h2><h3 id="查找靠近位置的节点"><a href="#查找靠近位置的节点" class="headerlink" title="查找靠近位置的节点"></a>查找靠近位置的节点</h3><p>有时需要查找离目标点最近的点，使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 找到距离GameObject最近的点</span><br><span class="line">GraphNode node = AstarPath.active.GetNearest(transform.position).node;</span><br><span class="line">if (node.Walkable) &#123;</span><br><span class="line">// 该点可走</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者只想获得离目标节点最近的可行走节点（Walkable），需要用到NNConstraint类，作为限定条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GraphNode node = AstarPath.active.GetNearest(transform.position, NNConstraint.Default).node;</span><br></pre></td></tr></table></figure>
<p>NNConstraint是用于设置返回节点的条件的类，NNConstraint.Default是寻路的条件，也就是说该条件下计算出的节点都是Walkable。</p>
<p>如果想获得在更多限定条件下，距离目标节点最近的点。可以自行设置限定条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var constraint = NNConstraint.None;</span><br><span class="line"></span><br><span class="line">// Constrain the search to walkable nodes only</span><br><span class="line">constraint.constrainWalkability = true;</span><br><span class="line">constraint.walkable = true;</span><br><span class="line"></span><br><span class="line">// Constrain the search to only nodes with tag 3 or tag 5</span><br><span class="line">// The &apos;tags&apos; field is a bitmask</span><br><span class="line">constraint.constrainTags = true;</span><br><span class="line">constraint.tags = (1 &lt;&lt; 3) | (1 &lt;&lt; 5);</span><br><span class="line"></span><br><span class="line">var info = AstarPath.active.GetNearest(transform.position, constraint);</span><br><span class="line">var node = info.node;</span><br><span class="line">var closestPoint = info.position;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，搜寻最近节点的距离受制与Max Nearest Node Distance属性（在A* Inspector -&gt; Settings -&gt; Max Nearest Node Distance可以设置）。也就是说如果最近的点距离目标节点的距离超过 Max Nearest Node Distance，GetNearest方法会返回Null值。</p>
<p>GetNearest方法返回了一个<a href="https://arongranberg.com/astar/docs/nninfo.html">NNInfo</a>对象，<a href="https://arongranberg.com/astar/docs/nninfo.html">NNInfo</a>中包括两个属性，一是<a href="https://arongranberg.com/astar/docs/graphnode.html">GraphNode</a>类型的，距离最近的节点信息node。二是<a href="https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</a>类型的，node的位置信息position。在Grid图中每个节点都被视为正方形，所以position就是正方形。在navmesh中，position就是最近的三角形的中心点（因为NavMesh的节点是每个三角形的中心点）。</p>
<p>所以同样的地图，Grid和NavMesh查找最近的点会有一些不同：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546422437.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546422437.png" alt="Image 0011546422437.png"></a></p>
<p>在NavMesh中，红色方块是距离白色小球最近的位置。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546422596.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546422596.png" alt="Image 0011546422596.png"></a></p>
<p>在Grid中，最近的节点位置就是最近的方块位置。</p>
<h3 id="节点连接"><a href="#节点连接" class="headerlink" title="节点连接"></a>节点连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GraphNode node = ...;</span><br><span class="line">// Draw a line to all nodes that this node is connected to</span><br><span class="line">node.GetConnections(otherNode =&gt; &#123;</span><br><span class="line">Debug.DrawLine((Vector3)node.position, (Vector3)otherNode.position);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>GraphNode node = …;什么意思</strong></p>
<p>GetConnections需要一个委托，通过委托来取得与节点相连的点。</p>
<h3 id="节点的属性"><a href="#节点的属性" class="headerlink" title="节点的属性"></a>节点的属性</h3><p>node.postion是int类型的，不能直接使用（一千倍），可以转换后使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GraphNode node = ...;</span><br><span class="line">Vector3 v3position = (Vector3)node.position;</span><br><span class="line">node.position = (Int3)v3position;</span><br></pre></td></tr></table></figure>
<p>node还包含一些比较有用的信息，如tag，walkable。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool walkable = node.Walkable;</span><br><span class="line">uint tag = node.Tag;</span><br><span class="line">uint penalty = node.Penalty;</span><br></pre></td></tr></table></figure>
<p>获取一个节点所在表面的随机点：</p>
<p>Vector3 randomPoint = node.RandomPointOnSurface();（获取某位置的三角形）</p>
<h3 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3><p>通过Scene场景不同颜色的区域可以判断哪些区域是连通的，可以到达，如图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546437009.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546437009.png" alt="Image 0011546437009.png"></a></p>
<p>绿色和蓝色是两个区域且不连通</p>
<p>寻路系统通过计算图的连通分量来预先计算哪些节点可从哪些节点到达。不连通的两个区域（节点）会被标记为不同的颜色。每个节点的Area字段都设置为其连接组件的索引。如果2个节点具有相同的区域，则意味着它们之间存在有效路径。您也可以使用PathUtilities.IsPathPossible方法进行检查。计算这些区域或连接组件的过程被称为“洪水填充”。</p>
<p>通过代码判断两点之间的可达性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var node1 = AstarPath.active.GetNearest(somePoint1);</span><br><span class="line">var node2 = AstarPath.active.GetNearest(somePoint2);</span><br><span class="line">if (PathUtilities.IsPathPossible(node1, node2)) &#123;</span><br><span class="line">// There is a valid path between the nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径查找"><a href="#路径查找" class="headerlink" title="路径查找"></a>路径查找</h2><p>前面以及介绍过了，Seeker并不是立即执行寻路计算的，若想立即计算，需要调用Pathfinding.Path.BlockUntilCalculated方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 立即计算路径   </span><br><span class="line"></span><br><span class="line">Path p = seeker.StartPath (transform.position, transform.position + Vector3.forward * 10);</span><br><span class="line">p.BlockUntilCalculated();</span><br></pre></td></tr></table></figure>
<p>也可以使用协程等待路径计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IEnumerator Start () &#123;</span><br><span class="line">var path = seeker.StartPath (transform.position, transform.position+transform.forward*10, OnPathComplete);</span><br><span class="line">// Wait... (may take some time depending on how complex the path is)</span><br><span class="line">// The rest of the game will continue to run while waiting</span><br><span class="line">yield return StartCoroutine (path.WaitForPath());</span><br><span class="line">// The path is calculated now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以创建自己的路径对象，而不是使用seeker的方法，并能够在计算路径对象之前更改其设置。代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Create a new path object, the last parameter is a callback function</span><br><span class="line">// but it will be used internally by the seeker, so we will set it to null here</span><br><span class="line">// Paths are created using the static Construct call because then it can use</span><br><span class="line">// pooled paths instead of creating a new path object all the time</span><br><span class="line">// which is a nice way to avoid frequent GC spikes.</span><br><span class="line">var p = ABPath.Construct (transform.position, transform.position+transform.forward*10, null);</span><br><span class="line"></span><br><span class="line">// By default, a search for the closest walkable nodes to the start and end nodes will be carried out</span><br><span class="line">// but for example in a turn based game, you might not want it to search for the closest walkable node, but return an error if the target point</span><br><span class="line">// was at an unwalkable node. Setting the NNConstraint to None will disable the nearest walkable node search</span><br><span class="line">p.nnConstraint = NNConstraint.None;</span><br><span class="line"></span><br><span class="line">// Start the path by sending it to the Seeker</span><br><span class="line">seeker.StartPath (p, OnPathComplete);</span><br></pre></td></tr></table></figure>
<h3 id="多目标路径"><a href="#多目标路径" class="headerlink" title="多目标路径"></a>多目标路径</h3><h3 id="直接使用AstarPath类"><a href="#直接使用AstarPath类" class="headerlink" title="直接使用AstarPath类"></a>直接使用AstarPath类</h3><p>如果需要对路径进行更多控制，可以直接调用<a href="https://www.arongranberg.com/astar/docs/astarpath.html">AstarPath</a>组件。<a href="https://www.arongranberg.com/astar/docs/astarpath.html">AstarPath</a>组件的主要功能是<a href="https://www.arongranberg.com/astar/docs/astarpath.html#StartPath">AstarPath.StartPath</a>。如果要同时计算大量路径。搜索者适用于一次只有一个活动路径的代理，如果您尝试同时请求多个路径，它将只计算最后一个路径并取消其余路径。</p>
<p>注：使用<a href="https://www.arongranberg.com/astar/docs/astarpath.html#StartPath">AstarPath.StartPath</a>计算的路径不会进行后处理。但是，您可以在计算路径后使用附加到特定搜索器的修改器对其进行后处理，从而调用<a href="https://www.arongranberg.com/astar/docs/seeker.html#PostProcess">Seeker.PostProcess</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// There must be an AstarPath instance in the scene</span><br><span class="line">if (AstarPath.active == null) return;</span><br><span class="line"></span><br><span class="line">// We can calculate multiple paths asynchronously</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">// As there is not Seeker to keep track of the callbacks, we now need to specify the callback every time again</span><br><span class="line">var p = ABPath.Construct(transform.position, transform.position+transform.forward*i*10, OnPathComplete);</span><br><span class="line"></span><br><span class="line">// Start the path by calling the AstarPath component directly</span><br><span class="line">// AstarPath.active is the active AstarPath instance in the scene</span><br><span class="line">AstarPath.StartPath (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NavMesh生成"><a href="#NavMesh生成" class="headerlink" title="NavMesh生成"></a>NavMesh生成</h2><p>生成NavMesh有两种方法，一是通过一些软件手动生成（<a href="https://www.blender.org/">Blender</a> 等等），二是使用 Recast Graph自动生成（付费）。</p>
<p>手动生成就不做介绍了，可以看文档：<a href="https://arongranberg.com/astar/docs/createnavmesh.html">https://arongranberg.com/astar/docs/createnavmesh.html</a></p>
<p>关于NavMesh的生成原理：</p>
<p>Recast Graph是付费版才有的图，功能强大，可以自动识别到地板以及障碍信息，使用Recast Graph生成Navmesh分为如下几步：</p>
<p>1.在Astar面板点击创建Recast Graph</p>
<p>2.点击Snap Bounds To Scene按钮</p>
<p>Snap Bounds To Scene会自动识别场景中的轮廓，如图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546500422.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546500422.png" alt="Image 0011546500422.png"></a></p>
<p>白色的边框就是被识别出的轮廓</p>
<p>3.调整参数</p>
<p>Recast Graph生成NavMesh时，面板上的Width和Depth是无法直接修改的。必须要通过控制Cell（每个体素的大小）的大小来调节Width和Depth。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546500981.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546500981.png" alt="Image 0011546500981.png"></a></p>
<p>可以按图中设置为0.1</p>
<p>同时还有一个很关键的属性，<strong>tiles。</strong>recast graph使用tiles将图划分成一个个正方形区域。tile值的大小没有最佳，一般维持在 64至256。将Use tiles选项设置为Dont Use Tiles可以禁止使用tiles划分地图，但是Tiles有几个好处：</p>
<ol>
<li>可以并行扫描不同的图块，使扫描更快。</li>
<li>可以实时更新recast graph中的各个tiles，比更新整个图更快。</li>
<li>navmesh切割以逐个图块为基础进行操作，并且更新图形的较小部分更快。</li>
<li>可以分解非常大的多边形，从而降低寻路选择次优路径的风险（连接）。</li>
</ol>
<p>原文：</p>
<ol>
<li>It makes it possible to scan the different tiles in parallel which can make the scan a lot faster.</li>
<li>You can update individual tiles in a recast graph during runtime, which is faster than updating the whole graph.</li>
<li>navmesh cutting operates on a tile by tile basis and updating a smaller part of the graph is faster.</li>
<li>It breaks up very large polygons which reduces the risk of very suboptimal paths (more about this in Using navmeshes).</li>
</ol>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546501191.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546501191.png" alt="Image 0011546501191.png"></a></p>
<p>不适用Tiles</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546501197.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546501197.png" alt="Image 0011546501197.png"></a></p>
<p>使用Tiles</p>
<p>4.将代理物体从NavMesh中分离：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/Image 0011546503590.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/Image%200011546503590.png" alt="Image 0011546503590.png"></a></p>
<p>5.设置好参数后，点击扫描。注意点击Show Outline’ 和 ‘Show Surface’选项以便观察生成的NavMesh。</p>
<p><strong>细节</strong></p>
<p>recast graph的分辨率（width/depth）会很明显的影响navmesh，如图：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/cell_size.gif"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/cell_size.gif" alt="cell_size.gif"></a></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/Unity插件：AStarPathfinding寻路系统/recast_resolution.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/Unity%E6%8F%92%E4%BB%B6%EF%BC%9AAStarPathfinding%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/recast_resolution.png" alt="recast_resolution.png"></a></p>
<p>（有一个不可走的）</p>
<p>注意：（光栅化）分辨率对图的生成时间有很大影响，对运行时的性能没有直接影响（在游戏中完整更新一次图除外），但会微弱的影响性能，因为高分辨率意味着地图也会有更多的细节。</p>
<p>原文：</p>
<blockquote>
<p>Rasterization resolution has a great effect on the time it takes to generate a recast graph, but it has no direct impact on the runtime performance of it (except of course, full graph updates). Indirectly it can affect it slightly since a large resolution can add more detail to the graph.</p>
</blockquote>
<p>一张很大的NavMesh扫描的时间会很长，可以使用缓存来节省性能，连接：。</p>
<hr>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1>]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityiOSSDK接入</title>
    <url>/2019/12/11/UnityIosSDK%E6%8E%A5%E5%85%A5/UnityIosSDK%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<p>iOS的SDK接入流程</p>
<a id="more"></a>
<h1 id="一-导出Xcode工程"><a href="#一-导出Xcode工程" class="headerlink" title="一 导出Xcode工程"></a>一 导出Xcode工程</h1><h2 id="1-1修改cs文件配置plist"><a href="#1-1修改cs文件配置plist" class="headerlink" title="1.1修改cs文件配置plist"></a>1.1修改cs文件配置plist</h2><p>修改 <code>IOSPostprocessBuild.cs</code> ，目的是在此提前配置好接下来导出的Xcode工程Custom iOS Target Properties的一些设置，如果不在此填配置参数则需要在Xcode中设置。</p>
<p>文件目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\workspace\cq1_g\branch_release\client\cq1_g\Assets\Editor\Game</span><br></pre></td></tr></table></figure>
<p>（1）在<code>ModifyProj</code>方法中添加此SDK需要接入的额外.framework库，有一些通用的库已经在方法中配置好了，但如果需要对特定SDK添加额外的framework库。其中“YXM”为自定义的<strong>宏</strong>名称，添加格式下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyProj</span>(<span class="params"><span class="keyword">string</span> pathToBuildProject, XcodeBuilderItem xcodeBuilderItem</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">   	<span class="comment">//通用的framework库</span></span><br><span class="line">   	....</span><br><span class="line">	<span class="keyword">switch</span> (scriptDefine) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"YXM"</span>:	<span class="comment">// 游戏猫平台</span></span><br><span class="line">		UnityEngine.Debug.Log (<span class="string">"游戏猫平台 modify："</span> + scriptDefine);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加登录SDK framework</span></span><br><span class="line">		_pbxProj.AddFrameworkToProject(_targetGuid, <span class="string">"SystemConfiguration.framework"</span>, <span class="literal">true</span>);</span><br><span class="line">		_pbxProj.AddFrameworkToProject (_targetGuid, <span class="string">"JavaScriptCore.framework"</span>, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>（2）在<code>SetPlist</code>方法中填写SDK需要的Xcode设置：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetPlist</span>(<span class="params"><span class="keyword">string</span> pathToBuildProject, XcodeBuilderItem xcodeBuilderItem</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      <span class="comment">//通用的plist设置</span></span><br><span class="line">      ...</span><br><span class="line">	<span class="keyword">switch</span> (scriptDefine) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"DACHEN_B2_IOS"</span>: <span class="comment">//平台名</span></span><br><span class="line">		UnityEngine.Debug.Log (<span class="string">"755sy (大臣B2)plist："</span> + scriptDefine);</span><br><span class="line">		_rootDic.SetString(<span class="string">"NSCameraUsageDescription"</span>, <span class="string">"需要使用您的相机照相"</span>);</span><br><span class="line">		_rootDic.SetString(<span class="string">"CFBundleDevelopmentRegion"</span>, <span class="string">"zh_CN"</span>);</span><br><span class="line"></span><br><span class="line">		PlistElementArray LSApplicationQueriesSchemesB2 = _rootDic.CreateArray (<span class="string">"LSApplicationQueriesSchemes"</span>);</span><br><span class="line">		LSApplicationQueriesSchemesB2.AddString (<span class="string">"weixin"</span>);</span><br><span class="line">		LSApplicationQueriesSchemesB2.AddString (<span class="string">"alipay"</span>);</span><br><span class="line">		LSApplicationQueriesSchemesB2.AddString (<span class="string">"openedvv"</span>);</span><br><span class="line">		LSApplicationQueriesSchemesB2.AddString (<span class="string">"alipayqr"</span>);</span><br><span class="line">		LSApplicationQueriesSchemesB2.AddString (<span class="string">"wechat"</span>);</span><br><span class="line"></span><br><span class="line">		PlistElementArray dachenB2URLTypes = _rootDic.CreateArray (<span class="string">"CFBundleURLTypes"</span>);</span><br><span class="line">		PlistElementDict dcb2item0_1 = dachenB2URLTypes.AddDict ();</span><br><span class="line">		PlistElementArray dcb2urlSchemes = dcb2item0_1.CreateArray (<span class="string">"CFBundleURLSchemes"</span>);</span><br><span class="line">		dcb2urlSchemes.AddString (<span class="string">"miaolevv5228"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2修改iOS配置表"><a href="#1-2修改iOS配置表" class="headerlink" title="1.2修改iOS配置表"></a>1.2修改iOS配置表</h2><p>打开<code>D:\workspace\cq1_g\branch_release\tool\客户端打包\iOS打包配置表</code>，对准备接入SDK的包进行一些设置：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-26 下午2.59.05.png" alt="屏幕快照 2019-04-26 下午2.59.05"></p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-26 下午2.59.15.png" alt="屏幕快照 2019-04-26 下午2.59.15"></p>
<p><strong>一些需要配置的字段介绍：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">包名</td>
<td style="text-align:center">包名由SDK方提供，如ios.zhbdsb.com，如未提供按命名规则自行填写。</td>
</tr>
<tr>
<td style="text-align:center">名称</td>
<td style="text-align:center">由SDK方提供</td>
</tr>
<tr>
<td style="text-align:center">xcode工程名称</td>
<td style="text-align:center">自行按照命名规则填写，游戏名_平台 _渠道名(ltzj_ios_ly)</td>
</tr>
<tr>
<td style="text-align:center"><strong>宏</strong></td>
<td style="text-align:center">在1.1章配置的特定frame库和plist时设置的宏。</td>
</tr>
<tr>
<td style="text-align:center">拷贝文件</td>
<td style="text-align:center">需要拷贝到Xcode工程的文件，一般需要UnityAppController.mm</td>
</tr>
<tr>
<td style="text-align:center">目标系统版本</td>
<td style="text-align:center">iOS设备的系统版本</td>
</tr>
<tr>
<td style="text-align:center">产品名称</td>
<td style="text-align:center">渠道方名称拼音缩写</td>
</tr>
<tr>
<td style="text-align:center">Version</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Bundle</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Platid(必须和渠道表一致)</td>
</tr>
</tbody>
</table>
<h2 id="1-3修改打包列表"><a href="#1-3修改打包列表" class="headerlink" title="1.3修改打包列表"></a>1.3修改打包列表</h2><p>打开<code>D:\workspace\cq1_g\branch_release\tool\客户端打包\打包列表</code>，修改为1.2表中的包名：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/{73BB6E7C-8A63-7DA5-926F-17722EE41046}-1556419503341.png" alt="{73BB6E7C-8A63-7DA5-926F-17722EE41046}"></p>
<h2 id="1-4修改资源"><a href="#1-4修改资源" class="headerlink" title="1.4修改资源"></a>1.4修改资源</h2><p>打开<code>D:\workspace\cq1_g\branch_release\client\cq1_g\BuildSetting\Package</code>文件夹，复制一份接过iOSSDK的包文件夹。修改文件夹中的内容为SDK中提供的文件、图标。</p>
<p>（1）将XcodeFiles\SDK中的内容替换为渠道方提供的.framework.bundle。</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556438971.png" alt="Image 0011556438971"></p>
<p>（2）在Resource文件夹下放入加载图片、闪屏</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556439083.png" alt="Image 0011556439083"></p>
<p>（3）在Icon文件夹下放入游戏图标，命名是固定的，注意修改。</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556439496.png" alt="Image 0011556439496"></p>
<p>（4）在Plugins/IOS文件夹下放入如下四个文件，这两组文件接SDK时会用到：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556439148.png" alt="Image 0011556439148"></p>
<h2 id="1-5导出Xcode工程"><a href="#1-5导出Xcode工程" class="headerlink" title="1.5导出Xcode工程"></a>1.5导出Xcode工程</h2><p>点击BuildProject导出Xcode工程文件。</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-28 下午3.13.09.png" alt="屏幕快照 2019-04-28 下午3.13.09"></p>
<h1 id="二-接入SDK"><a href="#二-接入SDK" class="headerlink" title="二 接入SDK"></a>二 接入SDK</h1><h2 id="2-1修改项目配置"><a href="#2-1修改项目配置" class="headerlink" title="2.1修改项目配置"></a>2.1修改项目配置</h2><p>（1）勾选Automatically manage signing，自动管理证书。准备打包ipa时再调整为提供的证书。</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556439643.png" alt="Image 0011556439643"></p>
<p>（2）检查Custom iOS Target Properties中的配置是否和SDK文档中对应，1.1章节配置的plist会显示在此：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556440666.png" alt="Image 0011556440666"></p>
<p>（3）如果提示内购报错，将内购关闭（下图的in-APP Purchase）：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556441292.png" alt="Image 0011556441292"></p>
<p>（4）检查framework是否添加至工程。</p>
<h2 id="2-2根据文档接入SDK"><a href="#2-2根据文档接入SDK" class="headerlink" title="2.2根据文档接入SDK"></a>2.2根据文档接入SDK</h2><p>（1）UnityAppDelegate中接入初始化，apple id，横竖屏等参数。</p>
<p>（2）在ViewController中接入支付、登陆、上传角色信息等接口。充值和上传角色需要传入的数组（param）会在Lua脚本中配置。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;NiuNiuGame/NiuNiuGameHeader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// ************************** 添加事件 ************************** //</span></span><br><span class="line">- (<span class="keyword">void</span>) addEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//捕获登录消息</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                        selector:<span class="keyword">@selector</span>(loginNotificationResult:)</span><br><span class="line">                                                 name:<span class="built_in">NSdkGameLoginNotification</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//捕获注销消息</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             			          selector:<span class="keyword">@selector</span>(LogoutNotificationResult:)</span><br><span class="line">                                                 name:<span class="built_in">NSdkGAMELogoutNotification</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//充值回调</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(PayNotificationResult:)</span><br><span class="line">                                                 name:<span class="built_in">NSdkGAMEMaiNotification</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ************************** 登录 ************************** //</span></span><br><span class="line">- (<span class="keyword">void</span>) loginAction:(<span class="built_in">NSString</span>*)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([[NiuNiuGame sharedInstance] isLogined]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(![[NiuNiuGame sharedInstance] isShowLoginView])&#123;</span><br><span class="line">        [[NiuNiuGame sharedInstance] login];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> mark - 捕获登录消息</span></span><br><span class="line"><span class="comment">//捕获登录消息</span></span><br><span class="line">- (<span class="keyword">void</span>)loginNotificationResult:(<span class="built_in">NSNotification</span> *) notif</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([[NiuNiuGame sharedInstance] isLogined]) &#123;</span><br><span class="line">        </span><br><span class="line">         [[NiuNiuGame sharedInstance]showLogo];</span><br><span class="line">        <span class="comment">// 登录成功后的操作</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *userinfo = [notif userInfo];</span><br><span class="line">        <span class="comment">// 获取用户usertoken</span></span><br><span class="line">        <span class="built_in">NSString</span> *usertoken = [userinfo objectForKey:<span class="string">@"usertoken"</span>];</span><br><span class="line">        <span class="comment">// 获取用户id</span></span><br><span class="line">        <span class="built_in">NSString</span> *userid = [userinfo objectForKey:<span class="string">@"userid"</span>];</span><br><span class="line">        <span class="comment">// appid</span></span><br><span class="line">        <span class="built_in">NSString</span> *appid = <span class="string">@"1116"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"登录成功"</span>);</span><br><span class="line">        <span class="built_in">NSString</span> *info =[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"app_id=%@&amp;user_id=%@&amp;token=%@"</span>,appid,userid,usertoken];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--LoginInfo--%@"</span>, info);</span><br><span class="line">        UnitySendMessage(<span class="string">"SDKBack"</span>, <span class="string">"LoginBack"</span>, info.UTF8String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ************************ 切换账号 ************************ //</span></span><br><span class="line">- (<span class="keyword">void</span>) changeAccountAction:(<span class="built_in">NSString</span>*)param</span><br><span class="line">&#123;</span><br><span class="line">    [[NiuNiuGame sharedInstance] logout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> mark - 捕获登出消息</span></span><br><span class="line">- (<span class="keyword">void</span>)LogoutNotificationResult:(<span class="built_in">NSNotification</span> *) notif &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"注销成功"</span>);</span><br><span class="line">    UnitySendMessage(<span class="string">"SDKBack"</span>, <span class="string">"LoginBack"</span>, <span class="string">"Logout"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ************************ 支付 ************************** //</span></span><br><span class="line"><span class="comment">//param数组在lua中配置</span></span><br><span class="line">- (<span class="keyword">void</span>) rechargeAction:(<span class="built_in">NSString</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = [param componentsSeparatedByString:<span class="string">@"|"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---recharge ：%@"</span>,[<span class="keyword">self</span> descriptionWithLocale:array]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[NiuNiuGame sharedInstance] isLogined]) &#123;</span><br><span class="line">    [[NiuNiuGame sharedInstance] doSDKMaiWithSpxxId: array[<span class="number">0</span>]   <span class="comment">//牛牛的后台商品ID</span></span><br><span class="line">                                             Spxxjg:[array[<span class="number">1</span>] intValue]   <span class="comment">//单份价格</span></span><br><span class="line">                                           Multiple:[array[<span class="number">2</span>] intValue]  <span class="comment">//购买份数</span></span><br><span class="line">                                          ExtraData:array[<span class="number">5</span>]   <span class="comment">//额外参数</span></span><br><span class="line">                                            SpxxDdh:array[<span class="number">4</span>] <span class="comment">//[self getOrderid]   //厂商的订单号</span></span><br><span class="line">                                           APItemId:array[<span class="number">0</span>] ];<span class="comment">// 苹果的内购ID  （iOS包不走内购的话就先填成商品ID）</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> mark - 捕获付款消息</span></span><br><span class="line"><span class="comment">//捕获付款消息</span></span><br><span class="line">- (<span class="keyword">void</span>)PayNotificationResult:(<span class="built_in">NSNotification</span> *) notif</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *payinfo = [notif userInfo];</span><br><span class="line">    <span class="built_in">NSString</span> * result = [payinfo objectForKey:<span class="string">@"result"</span>];</span><br><span class="line">    <span class="comment">// 获取支付结果描述</span></span><br><span class="line">    <span class="built_in">NSString</span> *desc = [payinfo objectForKey:<span class="string">@"desc"</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>([result isEqualToString:<span class="string">@"success"</span>])&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"支付成功"</span>);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获取厂商订单号</span></span><br><span class="line">        <span class="built_in">NSString</span> *cporderid = [payinfo objectForKey:<span class="string">@"cporderid"</span>];</span><br><span class="line">        <span class="comment">// 获取SDK订单号</span></span><br><span class="line">        <span class="built_in">NSString</span> *sdkorderid = [payinfo objectForKey:<span class="string">@"sdkorderid"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> * logresult = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@%@%@%@"</span>,</span><br><span class="line">                                <span class="string">@"-捕获付款信息成功回调-\n--------------------------\n"</span>,</span><br><span class="line">                                desc,</span><br><span class="line">                                <span class="string">@"\n厂商订单号：\n"</span>,</span><br><span class="line">                                cporderid,</span><br><span class="line">                                <span class="string">@"\nSDK 订单号\n"</span>,</span><br><span class="line">                                sdkorderid];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, logresult);</span><br><span class="line">        UnitySendMessage(<span class="string">"SDKBack"</span>, <span class="string">"RechargeBack"</span>,<span class="string">"Success"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span> * logresult2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@%@"</span>,</span><br><span class="line">                                 <span class="string">@"-捕获付款信息失败回调-\n--------------------------\n"</span>,</span><br><span class="line">                                 <span class="string">@"购买失败 【"</span>,</span><br><span class="line">                                 desc,</span><br><span class="line">                                 <span class="string">@"】"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, logresult2);</span><br><span class="line">        UnitySendMessage(<span class="string">"SDKBack"</span>, <span class="string">"RechargeBack"</span>,<span class="string">"Failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************** 提交用户角色信息 ********************* //</span></span><br><span class="line"><span class="comment">//param数组在lua中配置</span></span><br><span class="line">- (<span class="keyword">void</span>) userDataAction:(<span class="built_in">NSString</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array = [param componentsSeparatedByString:<span class="string">@"|"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---userdata ：%@"</span>,[<span class="keyword">self</span> descriptionWithLocale:array]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进入游戏</span></span><br><span class="line">    <span class="keyword">if</span>([array[<span class="number">0</span>] intValue] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"登陆上传角色信息"</span>);</span><br><span class="line">        [[NiuNiuGame sharedInstance]setServId:array[<span class="number">1</span>]          <span class="comment">//区服ID</span></span><br><span class="line">                                     ServName:array[<span class="number">2</span>]          <span class="comment">//区服名称</span></span><br><span class="line">                                       RoleId:array[<span class="number">3</span>]          <span class="comment">//角色ID</span></span><br><span class="line">                                     RoleName:array[<span class="number">4</span>]          <span class="comment">//角色名称</span></span><br><span class="line">                                    RoleGrade:[array[<span class="number">5</span>] intValue]];       <span class="comment">//等级 int 型</span></span><br><span class="line">    &#125;<span class="comment">//升级</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>([array[<span class="number">0</span>] intValue] == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"升级上传角色信息"</span>);</span><br><span class="line">        [[NiuNiuGame sharedInstance] setRoleId:array[<span class="number">1</span>]          <span class="comment">//角色ID</span></span><br><span class="line">                                     RoleGrade:[array[<span class="number">2</span>] intValue]];        <span class="comment">//最新等级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h1 id="三-Lua中配置SDk"><a href="#三-Lua中配置SDk" class="headerlink" title="三 Lua中配置SDk"></a>三 Lua中配置SDk</h1><h2 id="3-1配置渠道信息表"><a href="#3-1配置渠道信息表" class="headerlink" title="3.1配置渠道信息表"></a>3.1配置渠道信息表</h2><p>在项目下的<code>渠道信息表</code>中配置包的参数，和1.2章节中的<code>iOS配置表</code>保持一致。</p>
<h2 id="3-2添加对应SDK的Lua脚本"><a href="#3-2添加对应SDK的Lua脚本" class="headerlink" title="3.2添加对应SDK的Lua脚本"></a>3.2添加对应SDK的Lua脚本</h2><p>在<code>D:\workspace\cq1_g\branch_release\client\cq1_g\Assets\_GameData\Lua\Game\Game\SDK</code>文件夹下按命名规则（渠道名+平台+SDK 一律大写）新建脚本。</p>
<p>在2.2中的方法中使用的param数组，要从lua中组织好数据传过去才能使用：</p>
<p>.mm充值方法传入入的数组：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LYLYHDIOSSDK:OnRecharge</span><span class="params">()</span></span></span><br><span class="line">    self.rechargeParam = <span class="string">""</span> .. self.rechargeCfg.ID</span><br><span class="line">    self.rechargeParam = self.rechargeParam .. <span class="string">"|"</span> .. self.rechargeCfg.NeedCNY * <span class="number">100</span></span><br><span class="line">    self.rechargeParam = self.rechargeParam .. <span class="string">"|"</span> .. <span class="string">"1"</span></span><br><span class="line">    self.rechargeParam = self.rechargeParam .. <span class="string">"|"</span> .. <span class="string">"1460762673"</span></span><br><span class="line">    self.rechargeParam = self.rechargeParam .. <span class="string">"|"</span>  .. self.rechargeOrderID</span><br><span class="line">    self.rechargeParam = self.rechargeParam .. <span class="string">"|"</span> .. encodeBase64(self.rechargeCustomInfo)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>角色信息上传，1为登陆上传角色信息，2为升级上传角色信息。<code>HanleEnterGame</code>和<code>HandleLevelUp</code>方法为升级和登陆时需要进行的一些操作：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LYLYHDIOSSDK:HanleEnterGame</span><span class="params">()</span></span></span><br><span class="line">    self.sendDataType = <span class="string">"EnterGame"</span></span><br><span class="line">    self:SendUserData()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LYLYHDIOSSDK:HandleLevelUp</span><span class="params">()</span></span></span><br><span class="line">    self.sendDataType = <span class="string">"LevelUp"</span></span><br><span class="line">    self:SendUserData()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LYLYHDIOSSDK:OnUserData</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> self.sendDataType == <span class="string">"EnterGame"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> serverName = GameModels.login.selectServerName</span><br><span class="line">        <span class="keyword">if</span> serverName == <span class="string">""</span> <span class="keyword">then</span></span><br><span class="line">            serverName = <span class="string">"无"</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        self.userdataParam = <span class="string">""</span> .. <span class="string">"1"</span></span><br><span class="line">        self.userdataParam = self.userdataParam .. <span class="string">"|"</span> .. GameModels.login.serverTag</span><br><span class="line">        self.userdataParam = self.userdataParam .. <span class="string">"|"</span> .. serverName</span><br><span class="line">        self.userdataParam = self.userdataParam .. <span class="string">"|"</span> .. GameModels.role.myRole:Get_roleID()</span><br><span class="line">        self.userdataParam = self.userdataParam .. <span class="string">"|"</span> .. GameModels.role.myRole:Get_name()</span><br><span class="line">        self.userdataParam = self.userdataParam .. <span class="string">"|"</span> .. GameModels.role.myRole:Get_level()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        self.userdataParam = <span class="string">""</span> .. <span class="string">"2"</span></span><br><span class="line">        self.userdataParam = self.userdataParam .. <span class="string">"|"</span> .. GameModels.role.myRole:Get_roleID()</span><br><span class="line">        self.userdataParam = self.userdataParam .. <span class="string">"|"</span> .. GameModels.role.myRole:Get_level()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果需要调用其它方法，可以在BaseSDK.lua中查找并在SDK脚本中重写。</p>
<h2 id="3-3添加新引入的SDK平台-（PlatformSDK-lua）"><a href="#3-3添加新引入的SDK平台-（PlatformSDK-lua）" class="headerlink" title="3.3添加新引入的SDK平台 （PlatformSDK.lua）"></a>3.3添加新引入的SDK平台 （PlatformSDK.lua）</h2><p>找到SDK目录下的PlatformSDK.lua，添加如下代码，导入3.2写的SDK脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">require</span> <span class="string">"Game/SDK/Platform/LYLYHDIOSSDK"</span></span><br><span class="line">...</span><br><span class="line">PlatformSDK[<span class="number">116</span>] = LYLYHDIOSSDK.new()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="四-出包"><a href="#四-出包" class="headerlink" title="四 出包"></a>四 出包</h1><h2 id="4-1准备热更包"><a href="#4-1准备热更包" class="headerlink" title="4.1准备热更包"></a>4.1准备热更包</h2><p>（1）使用cmd mstsc远程连接打包用的电脑，修改版本号文件夹（测试稳定后更为正式版本号）。</p>
<p>（2）打开生成热更包工具，生成热更文件。全部生成（lua，数据表，UI）约需要一个小时。</p>
<h2 id="4-2-热更测试"><a href="#4-2-热更测试" class="headerlink" title="4.2 热更测试"></a>4.2 热更测试</h2><p>通知运维上传热更包，对接入SDK的功能模块进行测试。在测试支付时可向渠道方询问是否有账号可以用来进行支付的测试。或者配置一个临时的商品数据进行调试。</p>
<h2 id="4-3出包"><a href="#4-3出包" class="headerlink" title="4.3出包"></a>4.3出包</h2><p>（1）测试无误后将SDK提供证书安装好。再次运行游戏测试。安装SDK提供的证书（双击打开添加至钥匙串，密码由渠道方提供），然后在Xcode中打出ipa包：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-28 下午3.16.52.png" alt="屏幕快照 2019-04-28 下午3.16.52"></p>
<p>点击Distribute App：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-28 下午3.47.00.png" alt="屏幕快照 2019-04-28 下午3.47.00"></p>
<p>根据需求选择对应的包：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-28 下午3.47.09.png" alt="屏幕快照 2019-04-28 下午3.47.09"></p>
<p>选择ipa包运行的设备：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-28 下午3.47.54.png" alt="屏幕快照 2019-04-28 下午3.47.54"></p>
<p>配置证书：</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/屏幕快照 2019-04-28 下午3.48.31.png" alt="屏幕快照 2019-04-28 下午3.48.31"></p>
<p>（2）检查ipa包是否正常，确认无误后交付给渠道方。</p>
<h1 id="五-常见错误"><a href="#五-常见错误" class="headerlink" title="五 常见错误"></a>五 常见错误</h1><p>出现其他错误及时补充。</p>
<h3 id="5-1未引入库引发的错误"><a href="#5-1未引入库引发的错误" class="headerlink" title="5.1未引入库引发的错误"></a>5.1未引入库引发的错误</h3><p>5.1.1 Undefined symbol：_OBJC_ClASS_ __$_SKMutablePayment/SKProductsRequest/SKPaymentQueue</p>
<p><img src="/2019/12/11/UnityIosSDK接入/UnityIosSDK接入/Image 0011556248919.png" alt="Image 0011556248919"></p>
<p>解决办法：缺少StoreKit.framework（内购需要），添加至项目即可。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>iOS</tag>
        <tag>Lua</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity NavMesh和寻路插件使用</title>
    <url>/2019/12/11/Unity%20NavMesh%E5%92%8C%E5%AF%BB%E8%B7%AF%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/Unity%20NavMesh%E5%92%8C%E5%AF%BB%E8%B7%AF%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>该文档主要是介绍Unity的导航系统和寻路插件使用，不同场景下寻路的工作流程，以及工作原理，没有涉及太多API讲解以及如何与其他组件的集成开发。</p>
<p>目录下包含一个简单的演示Demo，里面包括我作为练习写的几个Scene以及官方提供的实例，需要使用寻路导航系统的场景非常多，这些场景中彼此又具有较大的差异，如寻路时动态躲避障碍物，追逐某移动中的角色寻路，Demo中没有包含实际游戏中的全部情况，想了解更多可以去下载官网Demo，或看一些更专业的教程，下载地址和教程以及我学习时查询的资料的链接会在附录中给出。</p>
<p>文档若出现错误，请及时指正。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>备注</strong></p>
<hr>
<p>2018.12.10 Unity的NavMesh应用于简单的静态动态场景的使用方法介绍，以及A*插件的部分使用方法介绍。<br>2018.12.14 Unity的NavMesh的工作原理概述，navgation系统中各个组件面板介绍。<br>2018.12.18 介绍Unity的NavMesh中的实时局部Bake场景，自动离网链接场景的简单使用。<br>2018.12.19 增加寻路代价实现demo</p>
<h2 id="Unity的导航系统"><a href="#Unity的导航系统" class="headerlink" title="Unity的导航系统"></a>Unity的导航系统</h2><p>Unity的导航系统主要有四个部分：<strong>NavMesh</strong>，<strong>NavMesh Agent</strong>，<strong>Off-Mesh Link</strong>，<strong>NavMesh Obstacle</strong>。</p>
<p><strong>NavMesh</strong>（ Navigation Mesh的缩写）导航网格，是一种<strong>数据结构</strong>，并将游戏中物体结构关系转化为带有信息的网格，通过网格进行计算自动寻路的路径。NavMesh数据可以通过烘焙(Bake)产生。</p>
<p><strong>NavMesh Agent</strong>导航网格代理，简称代理。是Unity导航系统的核心<strong>组件</strong>，用来存放代理周游NavMesh的路径信息的平台。角色导航避障的移动是通过<strong>代理</strong>(NavMesh Agent)实现的，也就是说除非使用其他的寻路算法，否则想让某一个物体具有寻路导航的功能，就必须要为他配置一个代理。该组件一般添加在需要寻路的角色上。</p>
<p><strong>Off-Mesh Link</strong>离网链接，该<strong>组件</strong>主要用于连接两个不连通的跳跃点，如跳过沟渠或者开门等场景。该组件一般添加在跳跃点上。</p>
<p><strong>NavMesh Obstacle</strong>导航网格障碍，该<strong>组件</strong>主要用于移动障碍。代理可以自动躲避添加了该组件的障碍物（动态和静态）。该组件一般添加在静止或移动的障碍物上。</p>
<p>导航系统的基本流程大概流程，比如一个RPG游戏的某个副本场景：</p>
<ol>
<li>为障碍物添加NavMesh Obstacle，根据实际情况对NavMesh Obstacle组件进行设置；</li>
<li>为传送点，跳跃点添加Off-Mesh Link；</li>
<li>烘焙副本场景，生成Navmesh；</li>
<li>为角色添加NavMesh Agent并指定参数；</li>
<li>角色寻路，代理根据生成好的NavMesh以及地图中的障碍物信息进行计算最佳路径。</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr>
<h4 id="NavMesh的生成"><a href="#NavMesh的生成" class="headerlink" title="NavMesh的生成"></a>NavMesh的生成</h4><p>我的理解（翻译）：</p>
<p>导航系统需要一种数据结构来存储游戏场景中的<strong>可行走区域</strong>。，可行走区域的定义是场景中<strong>代理</strong>可以站立和移动的区域。 同时，在Unity中，代理被视为圆柱体，并以圆柱的体积参数来参与计算。 <strong>可行走区域</strong>通过场景中测试代理可以站立的位置自动生成可供代理移动的，由多个多边形组成的平面（下图蓝色部分），平面置于游戏的地板（或几何体平面）之上，同时平面存储了有哪些多边形彼此相邻的信息，该表面称为导航网格（简称NavMesh）。NavMesh是可行走区域的<strong>近似值</strong>。</p>
<p>官方手册的原文：</p>
<blockquote>
<p>The navigation system needs its own data to represent the walkable areas in a game scene. The walkable areas define the places in the scene where the agent can stand and move. In Unity the agents are described as cylinders. The walkable area is built automatically from the geometry in the scene by testing the locations where the agent can stand. Then the locations are connected to a surface laying on top of the scene geometry. This surface is called the navigation mesh (NavMesh for short).<br>we store information about which polygons are neighbours to each other. This allows us to reason about the whole walkable area.</p>
<p>Another thing to keep in mind is that the NavMesh is an approximation of the walkable surface.This can be seen for example in the stairs which are represented as a flat surface, while the source surface has steps</p>
</blockquote>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/31495094.jpg" alt="@"></p>
<p>生成的蓝色NavMesh平面</p>
<p>在烘焙（Bake）后，会在场景同级目录生成一个文件夹：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/70165612.jpg" alt="文件夹"></p>
<p>文件夹</p>
<p>原文链接：</p>
<hr>
<h4 id="NavMesh生成的多边形"><a href="#NavMesh生成的多边形" class="headerlink" title="NavMesh生成的多边形"></a>NavMesh生成的多边形</h4><p>NavMesh生成的是凸多边形，凸多边形中任意两点可以以直线相连。</p>
<p>原文：</p>
<blockquote>
<p>The NavMesh stores this surface as convex polygons. Convex polygons are a useful representation, since we know that there are no obstructions between any two points inside a polygon. In addition to the polygon boundaries,</p>
</blockquote>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/96097041.jpg" alt="@"></p>
<p>AB两点无法通过直线相连</p>
<p>原文链接:</p>
<hr>
<h4 id="NavMesh-Agent如何找到路径"><a href="#NavMesh-Agent如何找到路径" class="headerlink" title="NavMesh Agent如何找到路径"></a>NavMesh Agent如何找到路径</h4><p>要查找场景中两个位置之间的路径，首先需要将起始位置和目标位置<strong>映射</strong>到附近的多边形上。 然后从起始位置开始搜索，访问所有临近多边形，直到到达目标位置。 根据被访问过的多边形，可以得到一个从起始位置到目标位置的多边形序列。，该序列被称为corridor。Unity寻找路径使用的算法是A *。</p>
<p>原文</p>
<blockquote>
<p>To find path between two locations in the scene, we first need to map the start and destination locations to their nearest polygons. Then we start searching from the start location, visiting all the neighbours until we reach the destination polygon. Tracing the visited polygons allows us to find the sequence of polygons which will lead from the start to the destination. A common algorithm to find the path is A* (pronounced “A star”), which is what Unity uses.</p>
<p>The sequence of polygons which describe the path from the start to the destination polygon is called a corridor. The agent will reach the destination by always steering towards the next visible corner of the corridor.</p>
</blockquote>
<p>关于为什么序列中储存的是多边形序列而不是路线线段：</p>
<blockquote>
<p>If you have a simple game where only one agent moves in the scene, it is fine to find all the corners of the corridor in one swoop and animate the character to move along the line segments connecting the corners.</p>
</blockquote>
<p>如果使用线段作为corridor，当场景内有多个角色在寻路时，角色之间要在互相避让彼此的同时并寻路，这样就会造成寻路路径和计算出的造成偏差。尝试使用由线段组成的路径来纠正这种偏差很快变得非常困难且容易出错。</p>
<hr>
<h4 id="障碍躲避"><a href="#障碍躲避" class="headerlink" title="障碍躲避"></a>障碍躲避</h4><p>躲避障碍是基于下一个区域的位置，并计算出到达目的地所需的期望方向和速度来完成转向。个人理解即角色遇到障碍时只考虑并计算，如何到达避开障碍物拐点需要的速度和方向。</p>
<p>原文：</p>
<blockquote>
<p>The steering logic takes the position of the next corner and based on that figures out a desired direction and speed (or velocity) needed to reach the destination. Using the desired velocity to move the agent can lead to collision with other agents.</p>
</blockquote>
<p>避障时选择了新的速度，这个速度由期望的方向和防止之后与其他寻路实体以及导航网格边缘碰撞来权衡的。 Unity目前使用RVO算法来预测和防止角色与障碍物碰撞。</p>
<hr>
<h4 id="Moving-the-Agent"><a href="#Moving-the-Agent" class="headerlink" title="Moving the Agent"></a>Moving the Agent</h4><p>在转向和避障之后，会得出最终的速度。在Unity里，寻路实体使用一个动力学的模型来模拟，通过计算加速度来使移动更自然和平滑。</p>
<hr>
<h4 id="Global-and-Local负责的工作"><a href="#Global-and-Local负责的工作" class="headerlink" title="Global and Local负责的工作"></a>Global and Local负责的工作</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/94681976.jpg" alt="img"></p>
<p>Global 的工作是在场景世界中寻找corridor。 在场景世界各地寻找计算corridor很耗费性能。</p>
<p>Local 的工作是通过线性存储的多边形导航关系路线corridor，来计算如何到达下一个拐点同时避开其他正在移动的物体。</p>
<p>打个比方，从家到公司，Globel负责计算这段路的行进路线，比如坐先公交-地铁-最后步行，但途中我如何刷卡进地铁，怎么过马路就是Local的工作了。Global负责宏观的路线规划，Local负责微观的细节处理。</p>
<p>原文：</p>
<blockquote>
<p>Global navigation is used to find the corridor across the world. Finding a path across the world is a costly operation requiring quite a lot of processing power and memory.</p>
<p>The linear list of polygons describing the path is a flexible data structure for steering, and it can be locally adjusted as the agent’s position moves. Local navigation tries to figure out how to efficiently move towards the next corner without colliding with other agents or moving objects.</p>
</blockquote>
<hr>
<h3 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍*"></a>组件介绍*</h3><hr>
<h4 id="1-Nav-Mesh-Agent"><a href="#1-Nav-Mesh-Agent" class="headerlink" title="1.Nav Mesh Agent"></a>1.Nav Mesh Agent</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/99046946.jpg" alt="@Nav Mesh Agent| cente"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Agent Type</td>
<td>代理类型，可以选择不同的代理类型</td>
</tr>
<tr>
<td>Base Offset</td>
<td>基本偏移，物体实际的锚点和代理锚点的偏移量。[1]</td>
</tr>
<tr>
<td><strong>Steering</strong></td>
<td></td>
</tr>
<tr>
<td>speed</td>
<td>速度，前往目的地的最大移动速度。</td>
</tr>
<tr>
<td>Angular Speed</td>
<td>角速度，最大的转角速度，角度/秒</td>
</tr>
<tr>
<td>Acceleration</td>
<td>加速度，最大加速度</td>
</tr>
<tr>
<td>Stopping Distance</td>
<td>停止距离，代理距离目的地小于该值时停止。[2]</td>
</tr>
<tr>
<td>Auto Braking</td>
<td>制动距离，当物体和目的地小于制动距离时，开始减速。[2]</td>
</tr>
<tr>
<td><strong>Obstacle Avoidance</strong></td>
<td></td>
</tr>
<tr>
<td>Radius</td>
<td>代理半径，该半径参数只用于寻路时使用，使用时最好比实际值大一些。[3]</td>
</tr>
<tr>
<td>Height</td>
<td>代理高度</td>
</tr>
<tr>
<td>Quality</td>
<td>避障精度，如果场景内存在大量的代理，可以通过降低精度来节省CPU消耗[4]</td>
</tr>
<tr>
<td>Priority</td>
<td>躲避优先级，当代理表现为逃避时，优先级低的代理将会被忽略。该值的范围从0到99:最重要=0，最不重要=99，默认=50。[5]</td>
</tr>
<tr>
<td><strong>Path Finding</strong></td>
<td></td>
</tr>
<tr>
<td>Auto Traverse Off MeshLink</td>
<td>自动生成离网链接，如果使用动画或某种特定方式穿过离网链接点，则应关闭此功能。[6]</td>
</tr>
<tr>
<td>Auto Repath</td>
<td>当前路径变成无效时该代理是否尝试获取新路径</td>
</tr>
<tr>
<td>Area Mask</td>
<td>代理在查找路径时会考虑的区域类型</td>
</tr>
</tbody>
</table>
<p>[1]</p>
<p>[4]又名躲避精度。通过降低该值的方式可降低CPU开销，但如果寻路物体的躲避精度为none时，虽然寻路实体依然会绕开障碍物，但寻路实体之间不会发生碰撞（寻路实体会粘合在一起）</p>
<hr>
<h4 id="2-Nav-Mesh-Obstacle"><a href="#2-Nav-Mesh-Obstacle" class="headerlink" title="2.Nav Mesh Obstacle"></a>2.Nav Mesh Obstacle</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/42872518.jpg" alt="@Nav Mesh Obstaclet"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shape</td>
<td>物体形状,盒子/胶囊体</td>
</tr>
<tr>
<td>Center</td>
<td>障碍的中心点，在对象的自身空间测量。</td>
</tr>
<tr>
<td>Size</td>
<td>障碍的大小，在对象的自身空间测量。</td>
</tr>
<tr>
<td>Carve</td>
<td>挖洞，是否打开在导航网格挖洞的模式。[1]</td>
</tr>
<tr>
<td>Move Threshold</td>
<td>移动距离阈值，物体移动距离超过阈值后将更新导航网格，导航网格将障碍物运动状态视为移动。</td>
</tr>
<tr>
<td>Time To Stationary</td>
<td>时间阈值，超过该值，刷新导航网格</td>
</tr>
<tr>
<td>Carve Only Stationary</td>
<td>勾选后，障碍物只在静止时挖洞</td>
</tr>
</tbody>
</table>
<p><strong>[1]</strong> 关于Carve:</p>
<p>障碍物有两种，一种是开启了Carve，一种是未开启，代理会根据障碍物的类型做出不同的反应：</p>
<p>Obstructing模式（关闭Carve）:障碍物没有开启Carve时，它只是一个带碰撞器的普通障碍物。导航过程中，代理会尽量避免与障碍物碰撞。但如果两者距离较近，还是会发生碰撞。因为障碍物躲避非常基础，并且是基于一个短半径来计算（模糊运算），所以当障碍物过多时会出现找不到路的情况。这个模式多用于动态障碍物，如汽车或游戏角色。</p>
<blockquote>
<p>When Carve is not enabled, the default behavior of the Nav Mesh Obstacle is similar to that of a Collider. Nav Mesh Agents try to avoid collisions with the Nav Mesh Obstacle, and when close, they collide with the Nav Mesh Obstacle. Obstacle avoidance behaviour is very basic, and has a short radius. As such, the Nav Mesh Agent might not be able to find its way around in an environment cluttered with Nav Mesh Obstacles. This mode is best used in cases where the obstacle is constantly moving (for example, a vehicle or player character).</p>
</blockquote>
<p>Carving模式（开启Carve）：Carve被勾选时，静止的障碍物所在的网格会出现一个空洞，表示不可通行，只有当这个障碍物正在移动时才会变成Obstructing模式。NavMesh会记录空洞的相关信息，并引导寻路实体绕开障碍物或者当路径被封锁时启动重新寻路。用烂车和木箱设置关卡障碍时切记要勾选镂空属性，当且仅当这些障碍物受到其他外力和固定游戏事件时，如爆炸，才能被移开。</p>
<blockquote>
<p>When Carve is enabled, the obstacle carves a hole in the NavMesh when stationary. When moving, the obstacle is an obstruction. When a hole is carved into the NavMesh, the pathfinder is able to navigate the Nav Mesh Agent around locations cluttered with obstacles, or find another route if the current path gets blocked by an obstacle. It’s good practice to turn on carving for Nav Mesh Obstacles that generally block navigation but can be moved by the player or other game events like explosions (for example, crates or barrels).</p>
</blockquote>
<p>两种障碍物的类型决定了计算的方式，Obstructing模式由Local负责处理，Carving模式由Global负责处理（代表着CPU开销更大）。</p>
<p>移动的障碍物应该尽量避免使用Carving模式，因为Carve产生的洞会影响NavMesh，同时Global的计算量也会增加，使CPU和内存开销变大。</p>
<hr>
<h4 id="3-Off-Mesh-Link"><a href="#3-Off-Mesh-Link" class="headerlink" title="3.Off Mesh Link"></a>3.Off Mesh Link</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/88655117.jpg" alt="@Off Mesh Link"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start</td>
<td>离网链接的（跳跃点）起始位置</td>
</tr>
<tr>
<td>End</td>
<td>离网链接的（跳跃点）终点位置</td>
</tr>
<tr>
<td>Cost Override</td>
<td>成本覆盖，如果值为正，则在计算处理路径请求时的路径成本时使用该值。值为负，则使用该区域的默认成本(Navigation面板中的Area中的Cost)</td>
</tr>
<tr>
<td>Bi Directional</td>
<td>勾选后可以双向移动，否则只能从Start到End。</td>
</tr>
<tr>
<td>Activated</td>
<td>勾选后角色寻路时将跳跃点也添加至计算范围，否则忽略。</td>
</tr>
<tr>
<td>Auto Upadate Positions</td>
<td>自动更新位置,若两端点位置有变化则自动此更新离网链接。</td>
</tr>
<tr>
<td>Navigation Area</td>
<td>跳跃点所属的区域。[2]</td>
</tr>
</tbody>
</table>
<p><em>注：offmeshlink可以使用任何带有Transform的游戏对象作为开始和结束标记。</em></p>
<hr>
<h4 id="4-Navigation面板（window栏-Navigation）"><a href="#4-Navigation面板（window栏-Navigation）" class="headerlink" title="4.Navigation面板（window栏-Navigation）"></a>4.Navigation面板（window栏-Navigation）</h4><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/84206917.jpg" alt="@Navigation-Agents面板"></p>
<p>Agents面板用于代理和代理之间的躲避，该页的参数不参与Bake，只用于处理代理与代理，代理与障碍之间的躲避。<br>在使用章节有关于该面板如何使用的介绍。</p>
<p>关于此Tab，unity社区的问答：<a href="https://answers.unity.com/questions/1376465/what-is-the-difference-between-configuration-of-ag.html">https://answers.unity.com/questions/1376465/what-is-the-difference-between-configuration-of-ag.html</a></p>
<hr>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/16669861.jpg" alt="@Navigation-Areas面板"></p>
<p>Areas代表烘焙网格所在的图层， 有29种自定义类型和3种内置类型：Walkable，Not Walkable和Jump。<br>\1. Walkable是通用区域类型，可以在该区域上行走。<br>\2. Not Walkable是阻止导航的区域类型。<br>\3. Jump是分配给自动生成的离网链接的区域类型。<br>另外，每个NavMesh代理都有一个Area Mask，用于指定代理可以移动的区域。<br>Cost是寻路的代价（成本），比如角色可以选择两条路，一条是过河，一条是草地。这两种寻路方式可能消耗的成本不一样。或是一扇门，人类可以通过但是其他怪物不能通过。都需要通过控制cost和area来实现。具体使用看下面的寻路导航章节。</p>
<hr>
<p>Bake页面根据面板参数对当前场景进行烘焙地图，生成NavMesh，注意为了减少CPU和内存消耗，在烘焙设置中只能指定一种尺寸，如果需要生成多种NavMesh，<strong>参考下面章节。</strong><br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/38863987.jpg" alt="@Navigation-Bake面板"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Agent Radius</td>
<td>代理的中心与墙壁等障碍物可接近的距离半径。</td>
</tr>
<tr>
<td>Agent Height</td>
<td>代理的中心与墙壁等障碍物可接近的距离高度。</td>
</tr>
<tr>
<td>Max Slope</td>
<td>最大坡度，代理可以爬坡的最大高度。</td>
</tr>
<tr>
<td>Step Height</td>
<td>台阶高度，代理可以攀爬的最大台阶高度。</td>
</tr>
<tr>
<td><strong>Generated Off Mesh Links</strong></td>
<td></td>
</tr>
<tr>
<td>Drop Height</td>
<td>离网链接中最大的下落高度。[1]</td>
</tr>
<tr>
<td>Jump Distance</td>
<td>离网链接中最大的下落距离。[2]</td>
</tr>
</tbody>
</table>
<p>进阶设置具体在<strong>高级烘培设置</strong>章节看。</p>
<hr>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/21458525.jpg" alt="@Navigation-Object面板"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Navigation Static</td>
<td>导航静态,表示该游戏对象是否参与导航网格的烘焙。</td>
</tr>
<tr>
<td>OffMeshLink Generation</td>
<td>生成离网链接，选中该复选框，可以自动根据Drop Height（下落高度）和Jump Distance（跳跃距离）的参数设置生成离网链接</td>
</tr>
<tr>
<td>NavigationArea</td>
<td>导航区域设置。在默认情况下分为Walkable（行走区域），Not Walkable（<strong>不可行走层，该层即使在Area Mask中选择可走，实际运行也无法行走</strong>）和Jump（跳跃层）。（具体可以在Areas面板中进行设置）</td>
</tr>
</tbody>
</table>
<hr>
<p>###其他</p>
<p>####代理的半径</p>
<p>通过上面的内容可以注意到，代理的半径和高度可以在两个位置更改，一是Nav Mesh Agent，另一个是在Navigation面板中。</p>
<p>Navigation面板中设置表示代理如何闪避和碰撞静态的游戏物体，为了减少内存和CPU的开销，只能指定一种半径大小。</p>
<p>Nav Mesh Agent的属性值代表代理如何与动态障碍物以及其他之间的碰撞。</p>
<p>一般情况下两个半径设置大小相同。</p>
<hr>
<p>####高级烘培设置<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/55686986.jpg" alt="@高级烘培设置"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Advanced</strong></td>
<td></td>
</tr>
<tr>
<td>Manual Voxel Size</td>
<td>手动更改体素大小，通常不需要调整体素大小，有两种情况可能需要这样做：构建较小的代理半径或更准确的 NavMesh。</td>
</tr>
<tr>
<td>Voxel Size</td>
<td>体素大小</td>
</tr>
<tr>
<td>Min Region Area</td>
<td>最小区域设置，小于该值的NavMesh区域将被删除。</td>
</tr>
<tr>
<td>Height Mesh</td>
<td>高度网格</td>
</tr>
</tbody>
</table>
<p>[1]<strong>Min Region Area</strong>不能完全的删除所以小于该值的多边形，因为会有下面这种情况：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/19669556.jpg" alt="@删除前">删除前</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/85524153.jpg" alt="@删除后">删除后</p>
<p>可以看到，图中四个正方体上的多边形区域被删掉了，但是小于正方体上多边形面积的，位于正方体中间的区域却没有被删除，这是因为如果移除该区域则可能无法访问或连通周围的区域。</p>
<p>[2]<strong>Manual Voxel Size</strong>允许手动更改烘培的精准度，NavMesh是通过体素化场景内的物体生成的。 在生成NavMesh算法的开始，场景被栅格化为体素，然后提取可行走的表面，并将可行走的表面变成NavMesh。 <strong>voxel size</strong>表示生成的NavMesh的准确程度。</p>
<p><strong>voxel size</strong>的默认精度始终是代理半径的1/3，也就是和代理半径保持着3倍的关系。这是Unity官方在精确度和烘焙速度之间的折衷方案。<strong>将体素大小减半会使内存使用量增加4倍</strong>，<strong>构建场景需要4倍的时间。</strong></p>
<p>原文：</p>
<blockquote>
<p>The default accuracy is set so that there are 3 voxels per agent radius, that is, the whole agent width is 6 voxels. This is a good trade off between accuracy and bake speed. Halving the voxel size will increase the memory usage by 4x and it will take 4x longer to build the scene.</p>
</blockquote>
<p>由于在默认情况下voxel size和代理半径表示为3倍关系，但可能会出现一种情况：需要较小的代理半径，但是不需要voxel size的值也跟随半径变小，可以使用以下办法：</p>
<ol>
<li>将“代理半径”设置为实际代理半径。</li>
<li>打开手动体素大小，这将采用当前体素大小并“冻结”。</li>
<li>设置较小的Agent Radius，因为已经开启了手动修改体素大小，所以大小不会改变。</li>
</ol>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/./Image 0011544708028.png" alt="@提示voxel size和代理半径关系的文本，较好的倍数是2-8倍| center|"></p>
<p>官方文档：<br><a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AdvancedSettings.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AdvancedSettings.html</a></p>
<hr>
<h4 id="寻路代价"><a href="#寻路代价" class="headerlink" title="寻路代价*"></a>寻路代价*</h4><p>通过cost可以定义通过该区域的困难程度(代价)，，成本更低的地方在寻路过程中优先级更高，cost可以控制角色寻路时偏好的区域。例如走草地要比走水路要快一些，就可以通过设置cost来实现。具体例子可以看<strong>演示章节</strong>。</p>
<p>在进一步了解之前，首先先了解一下A<em> 寻路的工作原理：Unity使用A</em>算法来寻找导航的最短路径，其核心数据结构为图。算法从离寻路实体最近的网格进行遍历，接着不停地访问相邻网格节点，直到搜寻到终点所在的网格区域(起点到终点的网格连线就是导航路径（此时未带入估价函数，即非最短路径）)。</p>
<p>因为导航网格是由一系列多边形组成的，所以寻路实体需要计算通过每块网格或者说节点的寻路代价。最短路径就是各节点连线的最低寻路代价。</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/56907644.jpg" alt="@图中黄色的点就是节点"></p>
<p>在两个节点之间移动的花费取决于行进距离以及当前所属区域的成本，即距离<em> 成本。 这意味着，如果一个区域的成本是2，那么寻路实体通过该区域的距离相对于普通区域的距离要大两倍。 A </em> 算法要求所有成本必须不小于1。</p>
<p>有时候可能会感觉在某些地方，寻路实体好像不会直接走最短路径。究其原因在于网格结点的放置位置。在空旷的地方有一个非常小的障碍物，这就会导致产生一大一小的网格。在这种情况下，网格结点可以放置在网格的任何地方，所以在我们看来，寻路实体好像并没有走最短路径。</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/22999412.jpg" alt="@看起来黄线并没有规划出最短路径"></p>
<p>当某区域网格有多种寻路代价时，寻路网格一般优先使用寻路代价最低的那种。当然也有例外，不可行区域的寻路代价虽然为1，但优先使用该种区域，用于阻挡寻路实体移动**。</p>
<p>官网文档：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AreasAndCosts.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-AreasAndCosts.html</a></p>
<p><em>注：图中的寻路路径绘图（黄线）的显示方法是在hierarchy面板点击寻路角色，在Scene场景勾选如上图几项即可。</em></p>
<hr>
<h4 id="自动生成离网链接"><a href="#自动生成离网链接" class="headerlink" title="自动生成离网链接"></a>自动生成离网链接</h4><p>有些时候我们需要自动生成离网格链接。链接的类型有两种：爬梯跳台式和跳跃跨栏式。</p>
<p><strong>跳台式</strong>一般运用于高低平台之间的转换（跳下某平台）<strong>跳跃跨栏式</strong>主要在跳跃过某个缺口。</p>
<p>具体流程：</p>
<ol>
<li><p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/34063515.jpg" alt="@勾选Generate Off-Mesh Links属性"> </p>
</li>
<li><p>在Bake面板设置两个参数：</p>
</li>
</ol>
<p>   解释：<br>   <strong>Drop Height：</strong>跳台式链接需要设置下落的高度。高度为0时，无法跳落。<br>   <strong>Jump-Across：</strong>可以跳跃的距离。跳跃的距离为0时，无法眺落。（最小值=寻路实体半径+始终点距离，且最小值要大于代理半径的二倍。）</p>
<ol start="3">
<li>设置完成后点击Bake：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/48909730.jpg" alt="@Bake后的效果，黑色的点代表可跳跃的点"></li>
</ol>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/65051244.jpg" alt="@没有黑圈代表离网链接没有构建成功"></p>
<p><em>注：生成的分离网格链接只能从上往下移动，如果需要从下往上则需要使用手动分离网格链接。</em></p>
<p>官网链接：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-BuildingOffMeshLinksAutomatically.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-BuildingOffMeshLinksAutomatically.html</a></p>
<hr>
<h4 id="离网链接与动画系统"><a href="#离网链接与动画系统" class="headerlink" title="离网链接与动画系统"></a>离网链接与动画系统</h4><p>可以注意到，当演示中的胶囊体/Cube通过离网链接时都是一瞬间完成的，但在实际游戏中，人物的攀爬和跳跃都是有动作的，如果需要在通过离网链接点的时候有人物动作，需要把人物的Auto Traverse Off Mesh Link选项关掉，然后写对应的控制人物状态的脚本，具体可以看：<br><a href="https://blog.csdn.net/elyxiao/article/details/51281602">https://blog.csdn.net/elyxiao/article/details/51281602</a> ，在文章最后作者介绍了如何在通过离网链接点时执行动画。</p>
<hr>
<h4 id="Hight-mesh"><a href="#Hight-mesh" class="headerlink" title="Hight mesh"></a>Hight mesh</h4><p>由于NavMesh是可行走空间的近似值，因此会忽略一些细节。例如，人物在通过楼梯时并不会出现上下颠簸的感觉，如果需要增加NavMesh的真实度，需要将<strong>Navigation-Bake-Advanced settings</strong>下的<strong>Hight mesh</strong>选项打开，当然开启Hight mesh会增加CPU和内存的开销，并且烘焙时间会变长。</p>
<p>原文：</p>
<blockquote>
<p>While navigating, the NavMesh Agent is constrained on the surface of the NavMesh. Since the NavMesh is an approximation of the walkable space, some features are evened out when the NavMesh is being built. For example, stairs may appear as a slope in the NavMesh. If your game requires accurate placement of the agent, you should enable Height Mesh building when you bake the NavMesh. The setting can be found under the Advanced settings in Navigation window. Note that building Height Mesh will take up memory and processing at runtime, and it will take a little longer to bake the NavMesh.</p>
</blockquote>
<p>官方文档：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/nav-HeightMesh.html">https://docs.unity3d.com/2017.4/Documentation/Manual/nav-HeightMesh.html</a></p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/32907915.jpg" alt="@开启前"></p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/48197356.jpg" alt="@开启后"></p>
<hr>
<h4 id="对障碍物的补充"><a href="#对障碍物的补充" class="headerlink" title="对障碍物的补充"></a>对障碍物的补充</h4><p>1.一个物体不能同时开启NavMeshAget和NavMeshObstacle,但是可以在运行时实时修改其开关。同时开启会产生角色躲避自己的冲突。如果再同时的开启的基础上启用Carve，会出现更多的异常行为。</p>
<hr>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>//</p>
<hr>
<h4 id="high-level-NavMesh-building-components"><a href="#high-level-NavMesh-building-components" class="headerlink" title="high-level NavMesh building components"></a>high-level NavMesh building components</h4><p>//</p>
<p>官方文档：<a href="https://docs.unity3d.com/2017.4/Documentation/Manual/NavMesh-BuildingComponents.html">https://docs.unity3d.com/2017.4/Documentation/Manual/NavMesh-BuildingComponents.html</a></p>
<hr>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>下面的几个例子是我作为熟悉导航系统练习写的，想看标准的演示可以点击Windows-Navigation-Bake面板中的蓝色文本下载官方Demo。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/43707615.jpg" alt="@点击蓝色链接可跳转至下载Demo网页"></p>
<p>链接：<a href="https://github.com/Unity-Technologies/NavMeshComponents">https://github.com/Unity-Technologies/NavMeshComponents</a></p>
<h4 id="静态场景："><a href="#静态场景：" class="headerlink" title="静态场景："></a>静态场景：</h4><p><strong>（1）</strong>首先将场景内的障碍物包括地板设置为Static（如图中的四面墙，黄色的cube以及绿色的地板）：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/24937663.jpg" alt="img"></p>
<p>注意NAvigation Static要确定被勾选：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/50847199.jpg" alt="img"></p>
<p><strong>（2）</strong> 打开Navigation面板（window-Navigation），点击Bake：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/./Image 007.png" alt="@|center| 350x0"></p>
<p>点击Bake后场景会显示可通过的区域：</p>
<p><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/67341465.jpg" alt="img"></p>
<p><strong>（3）</strong> 在需要寻路的物体(角色)上添加Nav Mesh Agent组件，并添加自定义的物体行走组件，通过调用NavMeshAgent中的SetDestination方法使物体寻路，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_agent.SetDestination(tar);</span><br></pre></td></tr></table></figure>
<p><strong>（4）</strong>效果如下（途中的路径红线显示要自己添加，具体角色的行走和绘图实现方式可以在Demo中找到对应脚本）：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/94816236.jpg" alt="img"></p>
<h4 id="动态场景："><a href="#动态场景：" class="headerlink" title="动态场景："></a>动态场景：</h4><p>NavMesh同时也支持动态规划路线，如果寻路过程中动态出现障碍可以重新规划路线，NavMesh对动态规划支持不好，相比插件的动态寻路，NavMesh差的很多。<br><strong>（1）</strong> 先按照静态场景的流程走一遍，注意活动的障碍物不要标记为Static：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/80234410.jpg" alt="img"></p>
<p><strong>（2）</strong> 在动态运动物体上添加 Nav Mesh Obstacle组件。</p>
<p><strong>（3）</strong>效果如下：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/52457988.jpg" alt="img"></p>
<p>如果发现角色寻路困难，会在动态障碍物前停滞，可以更改Agent Radius的值来修改障碍物的半径，通过调大障碍物的占地面积让角色行走更流畅，或修改代理的自身半径：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/97970624.jpg" alt="img"></p>
<h4 id="离网链接场景："><a href="#离网链接场景：" class="headerlink" title="离网链接场景："></a>离网链接场景：</h4><p>有的时候场景中会出现一些传送点，跳跃点，如果需要在寻路时将传送点也包括在寻路计算内，则需要添加Off-Mesh-Line组件。<br>1.准备两个cube，分别命名为Start和End。作为传送点：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/56354906.jpg" alt="@图中的两个白色的板子"><br>2.在Start的cube上添加Off-Mesh-Line组件，在Start和End属性添加对应的两个Cube（Start和End）：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/19088313.jpg" alt="img"><br>3.若添加成功则传送点上会出现黑色的线：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/61300703.jpg" alt="img"><br>4.可以看到现在代理在寻路时会将跳跃点计算在内：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/68085785.jpg" alt="img"></p>
<h4 id="区域寻路场景"><a href="#区域寻路场景" class="headerlink" title="区域寻路场景"></a>区域寻路场景</h4><p>有时可能会用不到Bake整个场景的地图，只生成局部的NavMesh就够了，比如RPG游戏中玩家在可见区域选路，其他地方被战争迷雾覆盖，无法自动前往。这时需要生成局部的NavMesh并实时刷新。<br>\1. 新建一个空物体，添加Local Nav Mesh Builder，Size为需要实时计算的NavMesh大小，并在Tracked位置填写需要使用局部网格的角色。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/72400628.jpg" alt="img"></p>
<ol>
<li>为场景内的障碍物，地形添加Nav Mesh Source Tag组件。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/42188782.jpg" alt="img"></li>
</ol>
<p>3.像其他场景一样为角色添加代理组件。</p>
<p>4.效果（不需要在Editor时Bake）：<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/319203.jpg" alt="img"></p>
<h4 id="有寻路代价的场景"><a href="#有寻路代价的场景" class="headerlink" title="有寻路代价的场景"></a>有寻路代价的场景</h4><p>如果想让干预代理决定两条路该走哪条，比如走沼泽会扣血而草地不会，可以为行走区域添加<strong>代价</strong><br>1.添加路径需要的代价，默认是1，小于1的区域表示代价比标准低，大于1代表比标准代价高。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/66303692.jpg" alt="@添加water,grass,ice三个自定义代价的区域"><br>2.将行走区域修改为对应图层<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/20822682.jpg" alt="@选中的地板设置为Water区域"><br>3.对应区域设置好后，点击Bake，如图。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/44968356.jpg" alt="@三个颜色的区域代表了不同的代价区域"><br>4.现在代理寻路时会考虑代价花费，倾向于花费低的路线。<br><img src="/2019/12/11/Unity NavMesh和寻路插件使用/Unity NavMesh和寻路插件使用/83227170.jpg" alt="img"></p>
<hr>
<hr>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>游戏寻路</tag>
        <tag>Untiy插件</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity下C#调用纯C动态链接库</title>
    <url>/2019/12/11/CandCSharpDll/CandCSharpDll/</url>
    <content><![CDATA[<p>链接库可以解决在项目中需要调用其他语言代码（如C/C++）的需求。库中保存了其他程序需要调用的方法。</p>
<p>注：C++下导出链接库和使用方法和C有区别</p>
<a id="more"></a>
<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-动态与静态链接库"><a href="#1-1-动态与静态链接库" class="headerlink" title="1.1 动态与静态链接库"></a>1.1 动态与静态链接库</h2><p>链接库分<strong>动态链接库</strong>（Dynamic-link library，简写DLL）以及<strong>静态链接库</strong>（Statically-linked library）。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>动态链接库：</strong>在程序编译时，动态库中的函数代码不复制到可执行文件中，待程序需要调用库中函数时再进行加载。</p>
<p><strong>静态链接库：程序编译时使用到的静态库会被打包到可执行文件中。</strong></p>
<p><strong>优势</strong>：</p>
<p>动态库只有在需要时才会加载，所以比静态库要节省内存，可扩展性强，同时减少了开发中的耦合度。</p>
<p>而静态库由于存在于执行文件中，所以代码的装载，执行速度要比动态库快。</p>
<p><strong>劣势：</strong></p>
<p>动态库的版本一旦出现异常，冲突，会引发DLL HELL问题。并且，动态库虽然节省内存，但调用方法的开销大，需要多次的间接访问才能调用到方法。</p>
<p>静态库生成的可执行文件体积较大，且代码无法共享。</p>
<h2 id="1-2-不同系统下的链接库格式"><a href="#1-2-不同系统下的链接库格式" class="headerlink" title="1.2 不同系统下的链接库格式"></a>1.2 不同系统下的链接库格式</h2><p><strong>Windows</strong>：.dll（动态库），.lib（静态库）</p>
<p><strong>Linux（以及基于Linux的Android）</strong>：.so(动态库，share object)，.a（静态库）</p>
<p><strong>Mac：</strong>.a、.framework（静态库），.tbd，.dylib，.framework（动态库）</p>
<p><em>注：在Mac（iOS）系统下包含动态库的应用程序<strong>无法在Apple Store通过审核上架</strong>。详情：IOS静态库和动态库</em></p>
<h2 id="1-3-P-Invoke"><a href="#1-3-P-Invoke" class="headerlink" title="1.3 P/Invoke"></a>1.3 P/Invoke</h2><blockquote>
<p>P/Invoke又名平台调用，是.NET CLR提供的，为了使开发者从托管代码(如题主的C#)调用动态连接库中的非托管代码（通常是C）而提供的一种服务。</p>
<p>在受控代码与非受控代码进行交互时会产生一个事务（transition） ，这通常发生在使用平台调用服务（Platform Invocation Services），即P/Invoke</p>
</blockquote>
<p>简单来说，就是P/Invoke为C#提供了调用其他语言代码的服务。</p>
<h2 id="1-4-MinGW和Cygwin"><a href="#1-4-MinGW和Cygwin" class="headerlink" title="1.4 MinGW和Cygwin"></a>1.4 MinGW和Cygwin</h2><p>在生成Android使用的链接库时，需要使用Linux的编译工具，若想在Windows环境下使用Linux的编译工具（gcc/g++），则需要一个平台进行转换，也就是MinGW或Cygwin。</p>
<p>MinGW（ Minimalistic GNU for Windows），可被视为是Windows版本下的GCC，把代码中的LInux方式调用替换为对应的Windows调用方式。其中Msys子项目提供了一些模拟Linux的Shell和基础工具。</p>
<p>Cygwin 是在Windows平台上运行的unix模拟环境，Cygwin更像一个平台，模拟了Linux的接口，提供了运行在它上面的程序使用。</p>
<blockquote>
<ul>
<li>MinGW生成的程序，究其本质<strong>调用的是Kernel.32导出的标准Windows系统API</strong>，在windows下Mingw的编译性能会高一些，编译速度也会快一些。</li>
<li>Cygwin更像一个平台，它<strong>相对完整地模拟了LInux</strong>，提供了一个接近2M的Cygwin1.dll的文件作为目标库，来模拟Linux系统的接口，但是相对来说编译的速度就要慢一些。如果想要在Windows上开发可以运行在LInux上的程序，应该选用Cygwin。</li>
</ul>
</blockquote>
<p>资料:<a href="https://www.cnblogs.com/zoe-mine/p/7056369.html">https://www.cnblogs.com/zoe-mine/p/7056369.html</a></p>
<p>MinGW和Cygwin的安装请自行查看资料</p>
<h1 id="二-Windows下的链接库调用"><a href="#二-Windows下的链接库调用" class="headerlink" title="二 Windows下的链接库调用"></a>二 Windows下的链接库调用</h1><h2 id="2-0-准备环境"><a href="#2-0-准备环境" class="headerlink" title="2.0 准备环境"></a>2.0 准备环境</h2><p>VS2015，<a href="http://www.dependencywalker.com/">Dependency Walker</a>（用于查看DLL中是否有写好的方法）</p>
<h2 id="2-1-DLL项目"><a href="#2-1-DLL项目" class="headerlink" title="2.1 DLL项目"></a>2.1 DLL项目</h2><h3 id="2-1-1建立DLL项目"><a href="#2-1-1建立DLL项目" class="headerlink" title="2.1.1建立DLL项目"></a>2.1.1建立DLL项目</h3><p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011554868057.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011554868057.png" alt="Image 0011554868057.png"></a></p>
<p>如果没有Win32，则需要下载模板</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011554869322.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011554869322.png" alt="Image 0011554869322.png"></a></p>
<h3 id="2-1-2文件介绍"><a href="#2-1-2文件介绍" class="headerlink" title="2.1.2文件介绍"></a>2.1.2文件介绍</h3><p>新建项目完成后，会有如下几个文件：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011554869544.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011554869544.png" alt="Image 0011554869544.png"></a></p>
<ul>
<li><p>（1）stdafx.h：用于包含标准系统包含的头文件，用户需要的其他标准头文件也写在这里。</p>
</li>
<li><p>（2）stdafx.cpp：和stdafx.h对应，用于对stdafx.h进行预编译处理所谓头文件预编译，把一个工程(Project)中使用的一些MFC标准头文件预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间,编译结果文件是projectname.pch,stdafx.cpp可以在C++项目中加快编译速度。如果不使用MFC可以将其删除。</p>
</li>
<li><p>（3） targetver.h：定义dll最高可以使用的windows版本</p>
</li>
<li><p>（4） <strong>dllmain.cpp：</strong>dll的程序入口点。</p>
</li>
<li><p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555668421.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555668421.png" alt="Image 0011555668421.png"></a></p>
</li>
<li><p>| DLL_PROCESS_ATTACH | 进程被调用，DLL被连接到当前进程并被初始化   |<br>| —————— | ——————————————- |<br>| DLL_THREAD_ATTACH  | 当前进程创建一个新线程，DLL在新线程内被调用 |<br>| DLL_PROCESS_DETACH | 调用DLL的进程被终止，DLL被卸载              |<br>| DLL_THREAD_DETACH  | 调用DLL的线程被终止，DLL被卸载              |</p>
</li>
</ul>
<h3 id="2-1-3-将DLL项目修改为C"><a href="#2-1-3-将DLL项目修改为C" class="headerlink" title="2.1.3 将DLL项目修改为C"></a>2.1.3 将DLL项目修改为C</h3><p>此时项目需要做一些操作，才能修改为纯C的DLL库。</p>
<p>（1）.将预编译头修改为：创建<strong>(/YC)</strong></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011554870532.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011554870532.png" alt="Image 0011554870532.png"></a></p>
<p>（2）.修改为：编译为C代码<strong>（/TC）</strong><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011554870620.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011554870620.png" alt="Image 0011554870620.png"></a></p>
<p>（3）.删除stdafx.cpp，将其他cpp文件后缀修改为.c。修改完如图（Ccallback，CFunction，Cstruct是我写好的.c，可忽略）：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555056920.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555056920.png" alt="Image 0011555056920.png"></a></p>
<h3 id="2-1-4-编写C代码"><a href="#2-1-4-编写C代码" class="headerlink" title="2.1.4 编写C代码"></a>2.1.4 编写C代码</h3><p>（1）编写方法，命名为CFunction.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFunction.cpp : 定义 DLL 应用程序的导出函数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">NoArgReturnSth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"NoArgReturnSth()调用:\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">99999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Sum(int a , int b)调用:\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">SetNumZero</span><span class="params">(<span class="keyword">int</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"int SetNumZero(int *a)调用：\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"int SetNumZero(int *a)调用,int a的内存位置：%d\n"</span>,a);</span><br><span class="line">  *a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"int sendMessage(char* msg)调用：\n"</span>);</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(;*(msg + i) != <span class="literal">NULL</span>;i++ )</span><br><span class="line">   &#123; </span><br><span class="line">    *(msg + i) = *(msg + i) - <span class="number">32</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）编写方法，命名为CStruct.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> osVersion;</span><br><span class="line">  <span class="keyword">int</span> majorVersion;</span><br><span class="line">  <span class="keyword">int</span> minorVersion;</span><br><span class="line">  <span class="keyword">int</span> buildNum;</span><br><span class="line">  <span class="keyword">int</span> platFormId;</span><br><span class="line">  <span class="keyword">char</span> szVersion[<span class="number">128</span>];</span><br><span class="line">&#125;OSINFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（传递结构体指针）</span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">SetVersionPtr</span><span class="params">(OSINFO *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> * str = <span class="string">"Hello DLL"</span>;</span><br><span class="line">  info-&gt;osVersion = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"测试内容%d\n"</span>, info-&gt;majorVersion);</span><br><span class="line">  <span class="built_in">strcpy</span>(info-&gt;szVersion, str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）编写方法，命名为Ccallback.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*pfCallBack)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b[])</span></span>;</span><br><span class="line"></span><br><span class="line">pfCallBack CallBackfun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetCB</span><span class="params">(<span class="keyword">int</span>(*pfCallBack)(<span class="keyword">int</span> a, <span class="keyword">char</span> b[]))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CallBackfun = pfCallBack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">callTheCB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">memset</span>(ch, <span class="string">'\0'</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(ch, <span class="string">"aabbcc"</span>);</span><br><span class="line">  CallBackfun(a, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：printf方法需要在stdafx.h文件中添加#include “stdio.h”。</p>
<h3 id="2-1-5-导出DLL"><a href="#2-1-5-导出DLL" class="headerlink" title="2.1.5 导出DLL"></a>2.1.5 导出DLL</h3><p>（1）编译，编译成功后在项目的Debug目录下会有如下几个文件，（我的项目名字叫CFunctionw，所以生成的叫CFunction）：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555058072.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555058072.png" alt="Image 0011555058072.png"></a></p>
<p>（2）检查DLL是否存在需调用的方法，下载<a href="http://www.dependencywalker.com/">Dependency Walker</a>，安装后打开CFunction.dll：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555058152.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555058152.png" alt="Image 0011555058152.png"></a></p>
<p>可以看到有写好的方法，至此，DLL编写完成。</p>
<h2 id="2-2-C-调用DLL库（简单的控制台Demo）"><a href="#2-2-C-调用DLL库（简单的控制台Demo）" class="headerlink" title="2.2 C#调用DLL库（简单的控制台Demo）"></a>2.2 C#调用DLL库（简单的控制台Demo）</h2><hr>
<p>（1）新建一个C#控制台项目。</p>
<p>（2）在Main方法中调用DLL：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    [StructLayout(LayoutKind.Sequential)]</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSINFO</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> osVersion;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> majorVersion;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> minorVersion;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> buildNum;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> platFormId;</span><br><span class="line">        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = <span class="number">128</span>)]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> szVersion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//定义一个委托，其返回类型和形参与方法体的返回类型形参一致</span></span><br><span class="line">        <span class="comment">//一定要加上这句，要不然C#中的回调函数只要被调用一次，程序就异常退出了</span></span><br><span class="line">        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> delegate <span class="keyword">int</span> <span class="title">callBackHandler</span><span class="params">(<span class="keyword">int</span> a, [MarshalAs(UnmanagedType.LPStr)]StringBuilder b)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">internal <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"------------------------------"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"DLL func execute:&#123;0&#125;"</span>, NoArgReturnSth());</span><br><span class="line">            Console.WriteLine(<span class="string">"------------------------------"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"DLL func execute:&#123;0&#125;"</span>, SUM(a,b));</span><br><span class="line">            Console.WriteLine(<span class="string">"------------------------------"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"修改前的a:&#123;0&#125;"</span>, a);</span><br><span class="line">            Console.WriteLine(<span class="string">"DLL func execute:&#123;0&#125;"</span>, SetNumZero(ref a));</span><br><span class="line">            Console.WriteLine(<span class="string">"修改后的a:&#123;0&#125;"</span>, a);</span><br><span class="line">            Console.WriteLine(<span class="string">"------------------------------"</span>);</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">2048</span>);</span><br><span class="line">            buf.Append(<span class="string">"helloworld"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"传入字符串:&#123;0&#125;"</span>, buf);</span><br><span class="line">            sendMessage(buf);</span><br><span class="line">            Console.WriteLine(<span class="string">"传出字符串:&#123;0&#125;"</span>, buf.ToString());</span><br><span class="line">            Console.WriteLine(<span class="string">"------------------------------"</span>);</span><br><span class="line">            initStruct();</span><br><span class="line">            Console.WriteLine(<span class="string">"------------------------------"</span>);</span><br><span class="line">            callBackHandler fun = <span class="keyword">new</span> callBackHandler(localFun);</span><br><span class="line">            SetCB(fun);</span><br><span class="line">            callTheCB();</span><br><span class="line">            Console.WriteLine(<span class="string">"------------------------------"</span>);</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//普通无参方法</span></span><br><span class="line">        [DllImport(<span class="string">"CFunction.dll"</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">NoArgReturnSth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参int方法</span></span><br><span class="line">        [DllImport(<span class="string">"CFunction.dll"</span>, EntryPoint = <span class="string">"Sum"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span>  <span class="keyword">int</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入int指针方法</span></span><br><span class="line">        [DllImport(<span class="string">"CFunction.dll"</span>, EntryPoint = <span class="string">"SetNumZero"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">SetNumZero</span><span class="params">(ref <span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入字符串指针方法</span></span><br><span class="line">        [DllImport(<span class="string">"CFunction.dll"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sendMessage</span><span class="params">(StringBuilder msg)</span></span>;</span><br><span class="line">        <span class="comment">//传入结构体方法</span></span><br><span class="line">        [DllImport(<span class="string">"CFunction.dll"</span>, EntryPoint = <span class="string">"SetVersionPtr"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">SetVersionPtr</span><span class="params">(ref OSINFO info)</span></span>;</span><br><span class="line">        <span class="comment">//结构体初始化，并调用DLL方法。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initStruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            IntPtr pv = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(OSINFO)));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Marshal.WriteInt32(pv, i * Marshal.SizeOf(typeof(Int32)), ((Int32)(i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            OSINFO entries = (OSINFO)Marshal.PtrToStructure(pv, typeof(OSINFO));</span><br><span class="line">            entries.majorVersion = <span class="number">999</span>;</span><br><span class="line">            <span class="keyword">if</span> (SetVersionPtr(ref entries) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"--osVersion:&#123;0&#125;"</span>, entries.osVersion);</span><br><span class="line">                Console.WriteLine(<span class="string">"--Major:&#123;0&#125;"</span>, entries.majorVersion);</span><br><span class="line">                Console.WriteLine(<span class="string">"--Minor:&#123;0&#125;"</span>, entries.minorVersion);</span><br><span class="line">                Console.WriteLine(<span class="string">"--BuildNum:&#123;0&#125;"</span>, entries.buildNum);</span><br><span class="line">                Console.WriteLine(<span class="string">"--szVersion:&#123;0&#125;"</span>, entries.szVersion);</span><br><span class="line">            &#125;</span><br><span class="line">            Marshal.FreeHGlobal(pv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//传入委托方法</span></span><br><span class="line">        [DllImport(<span class="string">"CFunction.dll"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">SetCB</span><span class="params">(callBackHandler fun1)</span></span>;</span><br><span class="line">        <span class="comment">//回调方法</span></span><br><span class="line">        [DllImport(<span class="string">"CFunction.dll"</span>, CallingConvention = CallingConvention.Cdecl)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">callTheCB</span><span class="params">()</span></span>;</span><br><span class="line">         <span class="comment">//本地委托方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">localFun</span><span class="params">(<span class="keyword">int</span> a, [MarshalAs(UnmanagedType.LPStr)] StringBuilder b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"回调:&#123;0&#125;"</span>, b.ToString());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CallingConvention = CallingConvention.Cdecl</strong></p>
<p>首先引入System.Runtime.InteropServices，然后导入DLL，格式为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"dllname.dll"</span>),EntryPoint = <span class="meta-string">"functionname"</span>,CallingConvention = CallingConvention.Cdecl,</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">functionname2</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>[DllImport(“CFunction.dll”)]用于导入DLL。EntryPoint 、CallingConvention 是两个较常用的属性，EntryPoint 用于指定DLL中的方法名，如果DLL和C#中声明的方法名相同，则该属性可忽略。CallingConvention用于指定由哪一方负责处理堆栈，值Cdecl为调用方清理堆栈。</p>
<p>如果不使用CallingConvention，会提示：<em>“C#调用C++DLL文件 报错调用导致堆栈不对称。原因可能是托管的 PInvoke 签名与非托管的目标签名不匹配”</em>的错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[UnmanagedFunctionPointer(CallingConvention.Cdecl)]</span><br></pre></td></tr></table></figure>
<p>UnmanagedFunctionPointe表示动态使用未托管的dll函数指针</p>
<blockquote>
<p>CallingConvention.Cdecl：C调用约定（即用<strong>cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。_cdecl是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用_stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀，是MFC缺省调用约定；<br>CallingConvention.StdDecl：</strong>stdcall调用约定相当于16位动态库中经常使用的PASCAL调用约定。在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为<strong>stdcall。除了</strong>pascal外，<strong>fortran和</strong>syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。_stdcall是Pascal程序的缺省调用方式，通常用于Win32Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上”@”和参数的字节数；</p>
</blockquote>
<p>还有一些其他的属性，详情看：<a href="https://blog.csdn.net/sdl2005lyx/article/details/6796037">平台调用P-INVOKE(一)–(基础篇)</a></p>
<p>注意C#和DLL中的方法的返回值，参数个数、类型、顺序必须一致。方法名可以不一致。</p>
<p>（3）运行代码，控制台会输出对应方法及其返回值：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555059881.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555059881.png" alt="Image 0011555059881.png"></a></p>
<p>注：将DLL和用于调试的控制的控制台项目放入同一解决方案内，修改DLL的生成路径可以简化调试过程，避免每次生成DLL在拷贝到Debug目录中。</p>
<h2 id="2-3在Unity下使用DLL"><a href="#2-3在Unity下使用DLL" class="headerlink" title="2.3在Unity下使用DLL"></a>2.3在Unity下使用DLL</h2><hr>
<p>（1）将DLL编译为64位，不然在Unity中会有关于32/64位的问题。为了测试方便，统一调整为64位。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555061641.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555061641.png" alt="Image 0011555061641.png"></a></p>
<p>（2）新建Unity项目，在Assets目录下新建Plugins文件夹，在Plugins文件夹下建立x86，x86_64文件夹。如图（忽略Android）：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555061782.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555061782.png" alt="Image 0011555061782.png"></a></p>
<p>之所以新建x86，x86_64文件夹是为了区分32/64位的DLL，直接拖到Plugins也可以。Plugins文件夹中若存在这两个文件夹，则dll必须放到两个文件夹中，否则会出现找不到dll的情况。（我的2017.4.16f1不存在这种情况。）</p>
<p>（3）修改DLL的属性，将属性修改为和图片一致</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555062363.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555062363.png" alt="Image 0011555062363.png"></a></p>
<p>（4）编写C#脚本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewBehaviourScript</span> :</span> MonoBehaviour &#123;</span><br><span class="line">    [DllImport(<span class="string">"CFunction"</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">NoArgReturnSth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = NoArgReturnSth();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GUI.Button(<span class="keyword">new</span> Rect(<span class="number">1</span>, <span class="number">1</span>, <span class="number">200</span>, <span class="number">100</span>), i.ToString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>csharpcsharp随便拖到一个GameObject上，运行：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555062503.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555062503.png" alt="Image 0011555062503.png"></a></p>
<h3 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h3><p>此报错只针对Windows，后面会有其他平台的异常信息。</p>
<p>（1）DllNotFoundException: 64位运行32位的DLL会报这个错。</p>
<p>（2）Failed to load ‘Assets/Plugins/xxx.dll’, expected x64 architecture, but was x86 architecture. You must recompile your plugin for x64 architecture.：DLL文件没有选择对应的CPU</p>
<p>（3）EntryPointNotFoundException：EntryPoint没写的情况下就是C#方法名字和DLL名字对不上，写了就是EntryPoint没写对。</p>
<h1 id="三-Android下的链接库调用"><a href="#三-Android下的链接库调用" class="headerlink" title="三 Android下的链接库调用"></a>三 Android下的链接库调用</h1><p>下面介绍三种我用的，在windows下生成.so的方法。</p>
<h2 id="3-1-通过NDK生成-so文件"><a href="#3-1-通过NDK生成-so文件" class="headerlink" title="3.1 通过NDK生成.so文件"></a>3.1 通过NDK生成.so文件</h2><h3 id="3-1-1-准备环境"><a href="#3-1-1-准备环境" class="headerlink" title="3.1.1 准备环境"></a>3.1.1 准备环境</h3><p>（1）配置好NDK，SDK，JDK以及环境变量。</p>
<p>（2）新建一个文件夹，将写好的.c，.h放入。新建Android.mk，Application.mk文件。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555065573.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555065573.png" alt="Image 0011555065573.png"></a></p>
<p><em>注：.c文件和.h文件的写法与DLL中稍有不同。</em></p>
<p>文件介绍：</p>
<p><a href="https://developer.android.com/ndk/guides/android_mk">https://developer.android.com/ndk/guides/android_mk</a></p>
<p><strong>Android.mk：</strong>Android提供的一种makefile文件，用于引导生成.so。</p>
<p><strong>Application.mk：</strong>androidNDK构建系统使用的一个可选构建文件，用于描述native模块。</p>
<h3 id="3-1-2-配置文件"><a href="#3-1-2-配置文件" class="headerlink" title="3.1.2 配置文件"></a>3.1.2 配置文件</h3><p>（3）配置<strong>Android.mk：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#指向一个编译脚本，由编译系统提供</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">#这个不太清楚 应该是处理器类型</span><br><span class="line">LOCAL_ARM_MODE  := arm</span><br><span class="line"></span><br><span class="line">#当前文件路径</span><br><span class="line">LOCAL_PATH      := $(NDK_PROJECT_PATH)</span><br><span class="line"></span><br><span class="line">#库名称</span><br><span class="line">LOCAL_MODULE    := libnative</span><br><span class="line"></span><br><span class="line"># 表示用于 <span class="selector-tag">C</span> 编译器的选项，<span class="selector-tag">Werror</span>将所有的警告当成错误进行处理</span><br><span class="line">LOCAL_CFLAGS    := -Werror</span><br><span class="line"></span><br><span class="line">#指定编译的源文件名称,</span><br><span class="line">LOCAL_SRC_FILES := NativeCode.c CFunction.c</span><br><span class="line"></span><br><span class="line">#允许打印<span class="selector-tag">Log</span></span><br><span class="line">LOCAL_LDLIBS    := -llog</span><br><span class="line"></span><br><span class="line">#告诉编译器生成<span class="selector-class">.so</span></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>（4）配置<strong>Application.mk</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#优化选项 可选release/debug</span><br><span class="line">APP_OPTIM        := release</span><br><span class="line"></span><br><span class="line">#选择需要支持的<span class="selector-tag">cpu</span></span><br><span class="line">APP_ABI          := armeabi</span><br><span class="line"></span><br><span class="line">#支持的最低<span class="selector-tag">Android</span>平台</span><br><span class="line">APP_PLATFORM     := android-16</span><br><span class="line"></span><br><span class="line">#指定执行脚本</span><br><span class="line">APP_BUILD_SCRIPT := Android.mk</span><br></pre></td></tr></table></figure>
<p>注：如果提示APP_PLATFORM版本过低，对应调高即可。</p>
<h3 id="3-1-3-编译"><a href="#3-1-3-编译" class="headerlink" title="3.1.3 编译"></a>3.1.3 编译</h3><p>（5）打开命令行，cd到文件目录编译。</p>
<p>编译指令：<code>ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk</code></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555068565.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555068565.png" alt="Image 0011555068565.png"></a></p>
<p>编译后目录内会产生两个文件夹libs和obj，在libs的armeabi-v7a文件夹下会有我们编译好的libnative.so。</p>
<h2 id="3-2-通过Cmake生成-so文件"><a href="#3-2-通过Cmake生成-so文件" class="headerlink" title="3.2 通过Cmake生成.so文件"></a>3.2 通过Cmake生成.so文件</h2><hr>
<h3 id="3-2-1-准备环境"><a href="#3-2-1-准备环境" class="headerlink" title="3.2.1 准备环境"></a>3.2.1 准备环境</h3><p>我是通过装Android Studio来安装的以下配置，但实际上编译用不到AS。</p>
<p>（1）在Android Studio安装好LLDB，CMake，NDK。（NDK如果之前装过可以自行配置），LLDB，CMake也可以在官网下载单独安装。</p>
<p>（2）打开settings查看SDK和NDK的所在位置：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555295955.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555295955.png" alt="Image 0011555295955.png"></a></p>
<p>打开位置，我的是C:\Users\usename\AppData\Local\Android\Sdk，然后找到如下文件夹：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555296277.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555296277.png" alt="Image 0011555296277.png"></a></p>
<p><strong>配置cmake和ninja的环境变量：</strong></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555296407.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555296407.png" alt="Image 0011555296407.png"></a></p>
<p><strong>验证是否配置成功：</strong></p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555296521.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555296521.png" alt="Image 0011555296521.png"></a></p>
<p>如图就是配置成功了。</p>
<p>（3）查看<strong>android.toolchain.cmake文件</strong>：在ndk所在的文件夹下，build-cmake-android.toolchain.cmake。该文件很重要，如果cmake目录下没有此文件，就去<a href="https://developer.android.com/ndk/guides/cmake.html下载。">https://developer.android.com/ndk/guides/cmake.html下载。</a></p>
<p>（4）准备代码：随便找个地方新建一个文件夹，新建build，include，src文件夹，将.c放入src，.h放入include：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555297411.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555297411.png" alt="Image 0011555297411.png"></a></p>
<p>（5）新建CMakeLists.txt，并输入如下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cmake_minimum_required</span>(<span class="selector-tag">VERSION</span> 3<span class="selector-class">.6</span>)</span><br><span class="line">file(GLOB native_srcs "$&#123;CMAKE_SOURCE_DIR&#125;/src/*.c")</span><br><span class="line">include_directories($&#123;CMAKE_SOURCE_DIR&#125;/include)</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#STATIC</span>表示编译结果为静态库<span class="selector-class">.a</span>,如果想为动态库<span class="selector-class">.so</span>,可改为<span class="selector-tag">SHARED</span></span><br><span class="line"></span><br><span class="line">add_library(Add SHARED $&#123;native_srcs&#125;) </span><br><span class="line"><span class="selector-tag">target_link_libraries</span>(<span class="selector-tag">Add</span>)</span><br></pre></td></tr></table></figure>
<p>（6）在build文件夹下新建批处理文件build.bat，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set toolchain=C:/Users/wenmai/AppData/Local/Android/Sdk/ndk-bundle/build/cmake/android.toolchain.cmake</span><br><span class="line">set android_ndk=C:/Users/wenmai/AppData/Local/Android/Sdk/ndk-bundle</span><br><span class="line">set build_type=Release</span><br><span class="line">set gernerator="Ninja"</span><br><span class="line">if not exist %1 md %1</span><br><span class="line">cd %1</span><br><span class="line">cmake ../.. -DCMAKE_TOOLCHAIN_FILE=%toolchain% -DANDROID_NDK=%android_ndk% -DCMAKE_BUILD_TYPE=%build_type% -DANDROID_ABI="%1" -DCMAKE_GENERATOR=%gernerator%</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure>
<p>cmake ../..的意思是使用cmake交叉编译当前工程，并将-DCMAKE_GENERATOR指向了ninja.exe。%1运行.bat要传的参数,需要传Android ABI名称，如：arm64-v8a,armeabi armeabi-v7a mips,mips64,x86,x86_64。</p>
<p>（7）打开命令行，cd到build目录，输入：build.bat armeabi-v7a：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555298228.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555298228.png" alt="Image 0011555298228.png"></a></p>
<p>可以在 armeabi-v7a目录下看到生成了libAdd.so文件。</p>
<p>如果出现如下图所示的错误，可以先仔细检查配置文件是否写对，并且build.bat传入的参数是否正确：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555153592.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555153592.png" alt="Image 0011555153592.png"></a></p>
<h2 id="3-3-使用Android-Studio生成-so"><a href="#3-3-使用Android-Studio生成-so" class="headerlink" title="3.3 使用Android Studio生成.so"></a>3.3 使用Android Studio生成.so</h2><p><em>注：Android Studio在最近的版本中弃用了使用gcc编译器，改为使用Clang代替。</em></p>
<p>下面利用AS和NDK来生成so，Cmake也可以使用此方法，文字不再做介绍。</p>
<h3 id="3-3-1-准备环境"><a href="#3-3-1-准备环境" class="headerlink" title="3.3.1 准备环境"></a>3.3.1 准备环境</h3><hr>
<p>（1）安装好Android Studio，确保可以正常运行。</p>
<p>（2）<a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555137646.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555137646.png" alt="Image 0011555137646.png"></a></p>
<p>界面位置：File-Settings-System Settings-Android-SDKTools</p>
<p>在AS中下载这些东西似乎需要翻墙，没有验证过。</p>
<p>文件介绍：</p>
<ul>
<li>CMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果您只计划使用 ndk-build，则不需要此组件。</li>
<li>LLDB：一种调试程序，Android Studio 使用它来调试原生代码。</li>
</ul>
<h3 id="3-3-2-项目配置"><a href="#3-3-2-项目配置" class="headerlink" title="3.3.2 项目配置"></a>3.3.2 项目配置</h3><p>（1）先新建一个项目，（我的叫FuckSO）。然后切换工程目录为Project，（默认是Android），然后打开Project Structure-SDK Location，确认ndk已经配置好。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Honeycam 2019-04-13 15-11-35.gif"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Honeycam%202019-04-13%2015-11-35.gif" alt="Honeycam 2019-04-13 15-11-35.gif"></a></p>
<p>（2）在gradle.properties中添加一句：<strong>android.useDeprecatedNdk=true</strong>。为了向后兼容</p>
<p>（3）在build.gradle文件下添加ndk，CMake节点：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555140513.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555140513.png" alt="Image 0011555140513.png"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 28</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &apos;com.example.hellojni&apos;</span><br><span class="line">        minSdkVersion 23</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;),</span><br><span class="line">                    &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            version &apos;3.10.2&apos;</span><br><span class="line">            path &quot;src/main/cpp/CMakeLists.txt&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flavorDimensions &apos;cpuArch&apos;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        arm7 &#123;</span><br><span class="line">            dimension &apos;cpuArch&apos;</span><br><span class="line">            ndk &#123;</span><br><span class="line">                abiFilter &apos;armeabi-v7a&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arm8 &#123;</span><br><span class="line">            dimension &apos;cpuArch&apos;</span><br><span class="line">            ndk &#123;</span><br><span class="line">                abiFilters &apos;arm64-v8a&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x86 &#123;</span><br><span class="line">            dimension &apos;cpuArch&apos;</span><br><span class="line">            ndk &#123;</span><br><span class="line">                abiFilter &apos;x86&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x86_64 &#123;</span><br><span class="line">            dimension &apos;cpuArch&apos;</span><br><span class="line">            ndk &#123;</span><br><span class="line">                abiFilter &apos;x86_64&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        universal &#123;</span><br><span class="line">            dimension &apos;cpuArch&apos;</span><br><span class="line">            // include all default ABIs. with NDK-r16,  it is:</span><br><span class="line">            //   armeabi-v7a, arm64-v8a, x86, x86_64</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">    implementation &apos;com.android.support.constraint:constraint-layout:1.1.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）（如果不需要在Android Studio中调试此步骤可以跳过）在java目录下新建一个类，<strong>CCodeHelper</strong>。在静态代码中加载.c文件，并定义一个方法用于链接.c中的方法。</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555141665.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555141665.png" alt="Image 0011555141665.png"></a></p>
<p>（5）在项目文件夹-app-src-main下新建cpp文件夹，并新建.c文件：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555141480.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555141480.png" alt="Image 0011555141480.png"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include  &lt;jni.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int  Java_com_example_fuckso_CCodeHelper_magicMethod()</span><br><span class="line">&#123;</span><br><span class="line">#if defined(__arm__)</span><br><span class="line">    #if defined(__ARM_ARCH_7A__)</span><br><span class="line">    #if defined(__ARM_NEON__)</span><br><span class="line">      #if defined(__ARM_PCS_VFP)</span><br><span class="line">        #define ABI &quot;armeabi-v7a/NEON (hard-float)&quot;</span><br><span class="line">      #else</span><br><span class="line">        #define ABI &quot;armeabi-v7a/NEON&quot;</span><br><span class="line">      #endif</span><br><span class="line">    #else</span><br><span class="line">      #if defined(__ARM_PCS_VFP)</span><br><span class="line">        #define ABI &quot;armeabi-v7a (hard-float)&quot;</span><br><span class="line">      #else</span><br><span class="line">        #define ABI &quot;armeabi-v7a&quot;</span><br><span class="line">      #endif</span><br><span class="line">    #endif</span><br><span class="line">  #else</span><br><span class="line">   #define ABI &quot;armeabi&quot;</span><br><span class="line">  #endif</span><br><span class="line">#elif defined(__i386__)</span><br><span class="line">#define ABI &quot;x86&quot;</span><br><span class="line">#elif defined(__x86_64__)</span><br><span class="line">#define ABI &quot;x86_64&quot;</span><br><span class="line">#elif defined(__mips64)  /* mips64el-* toolchain defines __mips__ too */</span><br><span class="line">#define ABI &quot;mips64&quot;</span><br><span class="line">#elif defined(__mips__)</span><br><span class="line">#define ABI &quot;mips&quot;</span><br><span class="line">#elif defined(__aarch64__)</span><br><span class="line">#define ABI &quot;arm64-v8a&quot;</span><br><span class="line">#else</span><br><span class="line">#define ABI &quot;unknown&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return 999999999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意方法的名字<strong>Java_com_example_fuckso_CCodeHelper_magicMethod，</strong>该方法与CCodeHelper中的方法对应。但多了Java_com_example_fuckso_CCodeHelper_，这是在Android项目中定义C/C++库方法的规则，规则为：“包名_类名_方法名”，在java类中直接使用方法名来进行调用。</p>
<p>但把so拿给unity使用时，必须要使用全名也就是<strong>Java_com_example_fuckso_CCodeHelper_magicMethod</strong>才能调用。</p>
<p>（如果不需要在Android Studio中调试，方法名随便写就可以。）</p>
<p>（6）再和build.gradle同级别目录新建CMakeLists.txt，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line">add_library(</span><br><span class="line">        CNativeFunction</span><br><span class="line">         SHARED</span><br><span class="line">        app/src/main/cpp/CNativeFunction.c</span><br><span class="line">)</span><br><span class="line">find_library(</span><br><span class="line">          log-lib</span><br><span class="line">          log</span><br><span class="line">)</span><br><span class="line">target_link_libraries(</span><br><span class="line">                   CNativeFunction</span><br><span class="line">                   $&#123;log-lib&#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p>（7）ctrl+F9 编译。编译成功后，会在FuckSO\app\build\intermediates\cmake\debug\obj下对应的cpu类型下找到.so文件。</p>
<h2 id="3-3-Unity调用-so"><a href="#3-3-Unity调用-so" class="headerlink" title="3.3 Unity调用.so"></a>3.3 Unity调用.so</h2><p>使用<code>nm -D libNativeCode.so</code> 来查看so中是否包含了写好的方法：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555068534.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555068534.png" alt="Image 0011555068534.png"></a></p>
<p>将.so拖入Assets-Plugins-Android文件夹。在属性面板修改库的相关设置：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555136600.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555136600.png" alt="Image 0011555136600.png"></a></p>
<p>然后新建C#脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line">public class CallNativeCode : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">  [DllImport(&quot;native&quot;)]</span><br><span class="line">  private static extern int NoArgReturnSth();</span><br><span class="line"> </span><br><span class="line">    int i = NoArgReturnSth();</span><br><span class="line">    void OnGUI ()</span><br><span class="line">  &#123;</span><br><span class="line">    float x = 3;</span><br><span class="line">    float y = 10;</span><br><span class="line">    //GUI.Label (new Rect (15, 125, 450, 100), &quot;adding &quot; + x  + &quot; and &quot; + y + &quot; in native code equals &quot; + add(x,y));</span><br><span class="line">        GUI.Label(new Rect(15, 225, 450, 100), i.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拖拽到任意物体，这是Unity会报错：DllNotFoundException: native，此时不用理会，因为.so文件无论如何也无法在windows环境下调用。所以需要打包成apk在模拟器上运行，发布设置按图片中的对应即可：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555136869.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555136869.png" alt="Image 0011555136869.png"></a></p>
<p>安装APK运行，这时可以看到c#从.so调用了方法并返回了一个值：</p>
<p><a href="http://img.dongbeigtl.top/A文章需要的截图/CSharp调用C动态链接库DLL/Image 0011555136994.png"><img src="http://img.dongbeigtl.top/A%E6%96%87%E7%AB%A0%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%AA%E5%9B%BE/CSharp%E8%B0%83%E7%94%A8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/Image%200011555136994.png" alt="Image 0011555136994.png"></a></p>
<p><strong>需要注意的几点：</strong></p>
<ul>
<li>[DllImport(“filename”)]，filename不要写lib前缀以及.so后缀，如例子中生成的.so叫libnative.so，DllImport引入时只需写native。（强制规定）</li>
<li>如果在模拟器中依然出现DllNotFoundException异常，会有几种情况： 1.发布APK时对应的.so库位数不一致；2.DllImport没有找到.so库；3.找到了.so库但是没有找到对应的方法。</li>
<li>Win32Exception提示apksigner.bat找不到，我的SDK最高API是26，但是26的文件夹下没有apksigner.bat。临时的解决办法是删除26版本。（把文件夹删除）</li>
<li>CommandInvokationFailure: Gradle build failed。解决办法：Unity编辑器 File-&gt;Build Setting-&gt;Android-&gt;Build System选择Internal</li>
</ul>
<h1 id="四-多平台适应"><a href="#四-多平台适应" class="headerlink" title="四 多平台适应"></a>四 多平台适应</h1><hr>
<p>打包出Android在模拟器运行太麻烦，可以通过配置多平台的链接库实现平台自适应。首先准备好各平台的链接库，然后在</p>
<p>File-&gt;Build Settings-Switch Platform进行平台转换。</p>
<p>适配代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line">public class NewBehaviourScript : MonoBehaviour &#123;</span><br><span class="line">#if UNITY_STANDALONE_WIN</span><br><span class="line">    const string fcuk = &quot;CFunction&quot;;</span><br><span class="line">#else</span><br><span class="line">    const string fcuk = &quot;native&quot;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    [DllImport(fcuk)]</span><br><span class="line">    private static extern int NoArgReturnSth();</span><br><span class="line"></span><br><span class="line">    void OnGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        int i = NoArgReturnSth();</span><br><span class="line">        GUI.Button(new Rect(1, 1, 200, 100), i.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五-备注"><a href="#五-备注" class="headerlink" title="五 备注"></a>五 备注</h1><p>文档中没有写关于如何生成静态库的方法，但其实和生成动态库是一样的只是参数不同。</p>
<p>生成Android可以使用的.so文件的方法不止文中写的这些，但需要注意的是有些方法生产的so库只能在Linux下使用，如利用VisualGDB和Linux虚拟机交叉编译生成的.so库（<a href="https://visualgdb.com/tutorials/linux/libraries/">使用Visual Studio创建Linux库</a>），以及在windows环境下利用gcc编译出obj再转化为.so库的方法。</p>
<p>C++的链接库生成，和语法以及一些细微的差别在文中没有介绍。</p>
<p>.dll和.so的方法参数以及传参各有不同，具体区别下篇文档再做说明。可以先看看：</p>
<ol>
<li><a href="https://yq.aliyun.com/articles/678154">C#调用C/C++ DLL 参数传递和回调函数的总结</a></li>
<li><a href="https://www.cnblogs.com/stemon/p/4515522.html">C#调用C/C++动态库 封送结构体，结构体数组</a></li>
</ol>
<p>文中部分资料摘自：</p>
<ul>
<li>微软官方资料：<a href="https://docs.microsoft.com/zh-cn/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp?view=vs-2019">创建和使用你自己动态链接库 （c + +）</a></li>
<li>C语言中文网：<a href="http://c.biancheng.net/view/228.html"> C中函数指针简介及其用法</a></li>
<li>阿里云社区：<a href="https://yq.aliyun.com/articles/678154">C#调用C/C++ DLL 参数传递和回调函数的总结</a></li>
<li><a href="https://www.cnblogs.com/stemon/p/4515522.html">C#调用C/C++动态库 封送结构体，结构体数组</a></li>
<li><a href="https://blog.csdn.net/imfengyitong/article/details/51549010">C#调用C函数(DLL)传递参数问题</a></li>
<li><a href="https://blog.csdn.net/sdl2005lyx/article/details/6796037">平台调用P-INVOKE(一)–(基础篇)</a></li>
<li><a href="https://www.cnblogs.com/cg88/p/9143866.html">CallingConvention理解</a></li>
<li><a href="https://blog.csdn.net/yapingxin/article/details/7288325">［科普小短文］在C#中调用C语言函数</a></li>
<li><a href="https://blog.csdn.net/yapingxin/article/details/7288164">Visual C++ 2010 Express Tips: 用 C 和 C++ 创建动态链接库</a></li>
<li><a href="https://blog.csdn.net/bad_boy627056049/article/details/73658073">动态库和静态库的区别</a></li>
<li><a href="https://blog.csdn.net/qq21497936/article/details/83825098">VS2017编写纯C库以及使用C#调用C库方法</a></li>
<li><a href="https://www.cnblogs.com/EltonLiang/p/7392410.html">VS2015_动态链接库学习</a></li>
<li><a href="https://blog.csdn.net/leo9150285/article/details/8804705">用VS2010将C程序做成动态链接库dll</a></li>
<li><a href="https://blog.csdn.net/zt_xcyk/article/details/78006223">VS2015设置DLL和LIB的输出目录</a></li>
<li>Android中IDE、ADT、SDK、JDK、NDK的含义解释</li>
<li><a href="https://blog.csdn.net/afei__/article/details/81272251">ABI： abiFilters 详解</a></li>
<li><a href="https://www.cnblogs.com/scotth/p/3977928.html">介绍linux/windows OS下静态库（.a、.lib）和动态库（.so、.dll）的 link &amp; load</a></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>CSharp</tag>
        <tag>C</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
